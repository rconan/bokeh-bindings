{
  "AbstractButton": {
    "name": "AbstractButton",
    "bases": [
      "bokeh.models.widgets.widget.Widget",
      "bokeh.models.widgets.buttons.ButtonLike"
    ],
    "desc": "A base class that defines common properties for all button types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"button_type\": \"default\", \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"icon\": null, \"id\": \"1001\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"label\": \"\", \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "button_type",
        "type": "Enum('default', 'primary', 'success', 'warning', 'danger')",
        "desc": "A style for the button, signifying it's role.",
        "default": "default"
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "label",
        "type": "String",
        "desc": "The text label for the button to display.",
        "default": ""
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "icon",
        "type": "Instance(AbstractIcon)",
        "desc": "An optional image appearing to the left of button's text.",
        "default": null
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "AbstractGroup": {
    "name": "AbstractGroup",
    "bases": [
      "bokeh.models.widgets.widget.Widget"
    ],
    "desc": "Abstract base class for all kinds of groups.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"1028\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"labels\": [], \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "labels",
        "type": "List(String)",
        "desc": "List of text labels contained in this group.",
        "default": []
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "AbstractIcon": {
    "name": "AbstractIcon",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "An abstract base class for icon widgets.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"1053\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "AbstractSlider": {
    "name": "AbstractSlider",
    "bases": [
      "bokeh.models.widgets.widget.Widget"
    ],
    "desc": ".. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"bar_color\": \"#e6e6e6\", \"css_classes\": [], \"default_size\": 300, \"direction\": \"ltr\", \"disabled\": false, \"format\": null, \"height\": null, \"height_policy\": \"auto\", \"id\": \"1059\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"show_value\": true, \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"tooltips\": true, \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "tooltips",
        "type": "Bool",
        "desc": "",
        "default": true
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Slider's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "format",
        "type": "Either(String, Instance(TickFormatter))",
        "desc": "",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "direction",
        "type": "Enum('ltr', 'rtl')",
        "desc": "",
        "default": "ltr"
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "bar_color",
        "type": "Color",
        "desc": "",
        "default": "#e6e6e6"
      },
      {
        "name": "show_value",
        "type": "Bool",
        "desc": "Whether or not show slider's value.",
        "default": true
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Action": {
    "name": "Action",
    "bases": [
      "bokeh.models.tools.Tool"
    ],
    "desc": "A base class for tools that are buttons in the toolbar.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"1089\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "AdaptiveTicker": {
    "name": "AdaptiveTicker",
    "bases": [
      "bokeh.models.tickers.ContinuousTicker"
    ],
    "desc": "Generate \"nice\" round ticks at any magnitude.\n\n    Creates ticks that are \"base\" multiples of a set of given\n    mantissas. For example, with ``base=10`` and\n    ``mantissas=[1, 2, 5]``, the ticker will generate the sequence::\n\n        ..., 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, ...",
    "proto": "{\"base\": 10.0, \"desired_num_ticks\": 6, \"id\": \"1095\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mantissas\": [1, 2, 5], \"max_interval\": null, \"min_interval\": 0.0, \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mantissas",
        "type": "Seq(Float)",
        "desc": "The acceptable list numbers to generate multiples of.",
        "default": [
          1,
          2,
          5
        ]
      },
      {
        "name": "base",
        "type": "Float",
        "desc": "The multiplier to use for scaling mantissas.",
        "default": 10.0
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "min_interval",
        "type": "Float",
        "desc": "The smallest allowable interval between two adjacent ticks.",
        "default": 0.0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "max_interval",
        "type": "Float",
        "desc": "The largest allowable interval between two adjacent ticks.\n\n    .. note::\n        To specify an unbounded interval, set to ``None``.",
        "default": null
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "AjaxDataSource": {
    "name": "AjaxDataSource",
    "bases": [
      "bokeh.models.sources.WebSource"
    ],
    "desc": "A data source that can populate columns by making Ajax calls to REST\n    endpoints.\n\n    The ``AjaxDataSource`` can be especially useful if you want to make a\n    standalone document (i.e. not backed by the Bokeh server) that can still\n    dynamically update using an existing REST API.\n\n    The response from the REST API should match the ``.data`` property of a\n    standard ``ColumnDataSource``, i.e. a JSON dict that maps names to arrays\n    of values:\n\n    .. code-block:: python\n\n        {\n            'x' : [1, 2, 3, ...],\n            'y' : [9, 3, 2, ...]\n        }\n\n    Alternatively, if the REST API returns a different format, a ``CustomJS``\n    callback can be provided to convert the REST response into Bokeh format,\n    via the ``adapter`` property of this data source.\n\n    Initial data can be set by specifying the ``data`` property directly.\n    This is necessary when used in conjunction with a ``FactorRange``, even\n    if the columns in `data`` are empty.\n\n    A full example can be seen at :bokeh-tree:`examples/howto/ajax_source.py`",
    "proto": "{\"adapter\": null, \"content_type\": \"application/json\", \"data\": {}, \"data_url\": null, \"http_headers\": {}, \"id\": \"1107\", \"if_modified\": false, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_size\": null, \"method\": \"POST\", \"mode\": \"replace\", \"name\": null, \"polling_interval\": null, \"selected\": {\"id\": \"1108\"}, \"selection_policy\": {\"id\": \"1109\"}, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('replace', 'append')",
        "desc": "Whether to append new data to existing data (up to ``max_size``), or to\n    replace existing data entirely.",
        "default": "replace"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "method",
        "type": "Enum('POST', 'GET')",
        "desc": "Specify the HTTP method to use for the Ajax request (GET or POST)",
        "default": "POST"
      },
      {
        "name": "max_size",
        "type": "Int",
        "desc": "Maximum size of the data columns. If a new fetch would result in columns\n    larger than ``max_size``, then earlier data is dropped to make room.",
        "default": null
      },
      {
        "name": "selected",
        "type": "Instance(Selection)",
        "desc": "An instance of a ``Selection`` that indicates selected indices on this ``DataSource``.\n    This is a read-only property. You may only change the attributes of this object\n    to change the selection (e.g., ``selected.indices``).",
        "default": "{\"id\": \"1116\"}"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "selection_policy",
        "type": "Instance(SelectionPolicy)",
        "desc": "An instance of a ``SelectionPolicy`` that determines how selections are set.",
        "default": "{\"id\": \"1119\"}"
      },
      {
        "name": "http_headers",
        "type": "Dict(String, String)",
        "desc": "Specify HTTP headers to set for the Ajax request.\n\n    Example:\n\n    .. code-block:: python\n\n        ajax_source.headers = { 'x-my-custom-header': 'some value' }",
        "default": {}
      },
      {
        "name": "polling_interval",
        "type": "Int",
        "desc": "A polling interval (in milliseconds) for updating data source.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "content_type",
        "type": "String",
        "desc": "Set the \"contentType\" parameter for the Ajax request.",
        "default": "application/json"
      },
      {
        "name": "adapter",
        "type": "Instance(CustomJS)",
        "desc": "A JavaScript callback to adapt raw JSON responses to Bokeh ``ColumnDataSource``\n    format.\n\n    If provided, this callback is executes immediately after the JSON data is\n    received, but before appending or replacing data in the data source. The\n    ``CustomJS`` callback will receive the ``AjaxDataSource`` as ``cb_obj`` and\n    will receive the raw JSON response as ``cb_data.response``. The callback\n    code should return a ``data`` object suitable for a Bokeh ``ColumnDataSource``\n    (i.e.  a mapping of string column names to arrays of data).",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "data",
        "type": "ColumnData(String, Seq(Any))",
        "desc": "Mapping of column names to sequences of data. The columns can be, e.g,\n    Python lists or tuples, NumPy arrays, etc.\n\n    The .data attribute can also be set from Pandas DataFrames or GroupBy\n    objects. In these cases, the behaviour is identical to passing the objects\n    to the ``ColumnDataSource`` initializer.",
        "default": {}
      },
      {
        "name": "data_url",
        "type": "String",
        "desc": "A URL to to fetch data from.",
        "default": null
      },
      {
        "name": "if_modified",
        "type": "Bool",
        "desc": "Whether to include an ``If-Modified-Since`` header in Ajax requests\n    to the server. If this header is supported by the server, then only\n    new data since the last request will be returned.",
        "default": false
      }
    ]
  },
  "Annotation": {
    "name": "Annotation",
    "bases": [
      "bokeh.models.renderers.Renderer"
    ],
    "desc": "Base class for all annotation models.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"1129\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "AnnularWedge": {
    "name": "AnnularWedge",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph"
    ],
    "desc": "Render annular wedges.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/AnnularWedge.py\n        :source-position: below",
    "proto": "{\"direction\": \"anticlock\", \"end_angle\": null, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"1137\", \"inner_radius\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"outer_radius\": null, \"start_angle\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the annular wedges.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the annular wedges.",
        "default": 0
      },
      {
        "name": "outer_radius",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The outer radii of the annular wedges.",
        "default": null
      },
      {
        "name": "start_angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the annular wedges.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the annular wedges.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the annular wedges.",
        "default": 1
      },
      {
        "name": "end_angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to end the annular wedges, as measured from the horizontal.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "outer_radius_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the annular wedges.",
        "default": 1.0
      },
      {
        "name": "inner_radius_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "inner_radius",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The inner radii of the annular wedges.",
        "default": null
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the center of the annular wedges.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the annular wedges.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the annular wedges.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "end_angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "direction",
        "type": "Enum('clock', 'anticlock')",
        "desc": "Which direction to stroke between the start and end angles.",
        "default": "anticlock"
      },
      {
        "name": "start_angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to start the annular wedges, as measured from the horizontal.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the annular wedges.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the center of the annular wedges.",
        "default": null
      }
    ]
  },
  "Annulus": {
    "name": "Annulus",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph"
    ],
    "desc": "Render annuli.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Annulus.py\n        :source-position: below",
    "proto": "{\"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"1163\", \"inner_radius\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"outer_radius\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the annuli.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the annuli.",
        "default": 0
      },
      {
        "name": "outer_radius",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The outer radii of the annuli.",
        "default": null
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the annuli.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the annuli.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the annuli.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "outer_radius_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the annuli.",
        "default": 1.0
      },
      {
        "name": "inner_radius_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "inner_radius",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The inner radii of the annuli.",
        "default": null
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the center of the annuli.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the annuli.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the annuli.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the annuli.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the center of the annuli.",
        "default": null
      }
    ]
  },
  "Arc": {
    "name": "Arc",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph"
    ],
    "desc": "Render arcs.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Arc.py\n        :source-position: below",
    "proto": "{\"direction\": \"anticlock\", \"end_angle\": null, \"id\": \"1184\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"radius\": null, \"start_angle\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the arcs.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the arcs.",
        "default": 0
      },
      {
        "name": "start_angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the arcs.",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the arcs.",
        "default": 1
      },
      {
        "name": "end_angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to end the arcs, as measured from the horizontal.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the arcs.",
        "default": 1.0
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the center of the arcs.",
        "default": null
      },
      {
        "name": "radius_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the arcs.",
        "default": "butt"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "end_angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "direction",
        "type": "Enum('clock', 'anticlock')",
        "desc": "Which direction to stroke between the start and end angles.",
        "default": "anticlock"
      },
      {
        "name": "radius",
        "type": "DistanceSpec(units_default='data')",
        "desc": "Radius of the arc.",
        "default": null
      },
      {
        "name": "start_angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to start the arcs, as measured from the horizontal.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the arcs.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the center of the arcs.",
        "default": null
      }
    ]
  },
  "Arrow": {
    "name": "Arrow",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render arrows as an annotation.\n\n    See :ref:`userguide_plotting_arrows` for information on plotting arrows.",
    "proto": "{\"end\": {\"id\": \"1207\"}, \"end_units\": \"data\", \"id\": \"1206\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"source\": null, \"start\": null, \"start_units\": \"data\", \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"x_end\": null, \"x_range_name\": \"default\", \"x_start\": null, \"y_end\": null, \"y_range_name\": \"default\", \"y_start\": null}",
    "props": [
      {
        "name": "end",
        "type": "Instance(ArrowHead)",
        "desc": "Instance of ``ArrowHead``.",
        "default": "{\"id\": \"1209\"}"
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the arrow body.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the arrow body.",
        "default": 0
      },
      {
        "name": "x_start",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates to locate the start of the arrows.",
        "default": null
      },
      {
        "name": "start",
        "type": "Instance(ArrowHead)",
        "desc": "Instance of ``ArrowHead``.",
        "default": null
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the arrow body.",
        "default": "black"
      },
      {
        "name": "end_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the end_x and end_y attributes. Interpreted as \"data\n    space\" units by default.",
        "default": "data"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the arrow body.",
        "default": 1
      },
      {
        "name": "source",
        "type": "Instance(DataSource)",
        "desc": "Local data source to use when rendering annotations on the plot.",
        "default": null
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the arrow body.",
        "default": 1.0
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the arrow body.",
        "default": "butt"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "start_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the start_x and start_y attributes. Interpreted as \"data\n    space\" units by default.",
        "default": "data"
      },
      {
        "name": "x_end",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates to locate the end of the arrows.",
        "default": null
      },
      {
        "name": "y_end",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates to locate the end of the arrows.",
        "default": null
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the arrow body.",
        "default": "bevel"
      },
      {
        "name": "y_start",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates to locate the start of the arrows.",
        "default": null
      }
    ]
  },
  "ArrowHead": {
    "name": "ArrowHead",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Base class for arrow heads.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"1234\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Asterisk": {
    "name": "Asterisk",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render asterisk '*' markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Asterisk.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"1242\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "AutocompleteInput": {
    "name": "AutocompleteInput",
    "bases": [
      "bokeh.models.widgets.inputs.TextInput"
    ],
    "desc": "Single-line input widget with auto-completion.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"case_sensitive\": true, \"completions\": [], \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"1262\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_characters\": 2, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"placeholder\": \"\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"value\": \"\", \"value_input\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "completions",
        "type": "List(String)",
        "desc": "A list of completion strings. This will be used to guide the\n    user upon typing the beginning of a desired value.",
        "default": []
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "min_characters",
        "type": "PositiveInt",
        "desc": "The number of characters a user must type before completions are presented.",
        "default": 2
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "placeholder",
        "type": "String",
        "desc": "Placeholder for empty input field.",
        "default": ""
      },
      {
        "name": "value",
        "type": "String",
        "desc": "Initial or entered text value.\n\n    Change events are triggered whenever <enter> is pressed.",
        "default": ""
      },
      {
        "name": "case_sensitive",
        "type": "Bool",
        "desc": "Enable or disable case sensitivity",
        "default": true
      },
      {
        "name": "value_input",
        "type": "String",
        "desc": "Initial or current value.\n\n    Change events are triggered whenever any update happens, i.e. on every\n    keypress.",
        "default": ""
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "AvgAggregator": {
    "name": "AvgAggregator",
    "bases": [
      "bokeh.models.widgets.tables.RowAggregator"
    ],
    "desc": "Simple average across multiple rows.",
    "proto": "{\"field_\": \"\", \"id\": \"1293\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "field_",
        "type": "String",
        "desc": "Refers to the table column being aggregated",
        "default": ""
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Axis": {
    "name": "Axis",
    "bases": [
      "bokeh.models.renderers.GuideRenderer"
    ],
    "desc": "A base class that defines common properties for all axis types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"axis_label\": \"\", \"axis_label_standoff\": 5, \"axis_label_text_align\": \"left\", \"axis_label_text_alpha\": 1.0, \"axis_label_text_baseline\": \"bottom\", \"axis_label_text_color\": \"#444444\", \"axis_label_text_font\": \"helvetica\", \"axis_label_text_font_size\": \"13px\", \"axis_label_text_font_style\": \"italic\", \"axis_label_text_line_height\": 1.2, \"axis_line_alpha\": 1.0, \"axis_line_cap\": \"butt\", \"axis_line_color\": \"black\", \"axis_line_dash\": [], \"axis_line_dash_offset\": 0, \"axis_line_join\": \"bevel\", \"axis_line_width\": 1, \"bounds\": \"auto\", \"fixed_location\": null, \"formatter\": null, \"id\": \"1300\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"guide\", \"major_label_orientation\": \"horizontal\", \"major_label_overrides\": {}, \"major_label_standoff\": 5, \"major_label_text_align\": \"center\", \"major_label_text_alpha\": 1.0, \"major_label_text_baseline\": \"alphabetic\", \"major_label_text_color\": \"#444444\", \"major_label_text_font\": \"helvetica\", \"major_label_text_font_size\": \"11px\", \"major_label_text_font_style\": \"normal\", \"major_label_text_line_height\": 1.2, \"major_tick_in\": 2, \"major_tick_line_alpha\": 1.0, \"major_tick_line_cap\": \"butt\", \"major_tick_line_color\": \"black\", \"major_tick_line_dash\": [], \"major_tick_line_dash_offset\": 0, \"major_tick_line_join\": \"bevel\", \"major_tick_line_width\": 1, \"major_tick_out\": 6, \"minor_tick_in\": 0, \"minor_tick_line_alpha\": 1.0, \"minor_tick_line_cap\": \"butt\", \"minor_tick_line_color\": \"black\", \"minor_tick_line_dash\": [], \"minor_tick_line_dash_offset\": 0, \"minor_tick_line_join\": \"bevel\", \"minor_tick_line_width\": 1, \"minor_tick_out\": 4, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"ticker\": null, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "axis_line_width",
        "type": "Float",
        "desc": "The line width of the axis line.",
        "default": 1
      },
      {
        "name": "major_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the major tick labels should be\n    offset from the associated ticks.",
        "default": 5
      },
      {
        "name": "axis_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the axis line.",
        "default": []
      },
      {
        "name": "major_tick_line_width",
        "type": "Float",
        "desc": "The line width of the major ticks.",
        "default": 1
      },
      {
        "name": "axis_line_color",
        "type": "Color",
        "desc": "The line color of the axis line.",
        "default": "black"
      },
      {
        "name": "axis_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the axis label.",
        "default": "italic"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default x-range.",
        "default": "default"
      },
      {
        "name": "axis_label",
        "type": "String",
        "desc": "A text label for the axis, displayed parallel to the axis rule.\n\n    .. note::\n        LaTeX notation is not currently supported; please see\n        :bokeh-issue:`647` to track progress or contribute.",
        "default": ""
      },
      {
        "name": "major_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the major ticks.",
        "default": 0
      },
      {
        "name": "minor_tick_line_width",
        "type": "Float",
        "desc": "The line width of the minor ticks.",
        "default": 1
      },
      {
        "name": "minor_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that minor ticks should extend into the\n    main plot area.",
        "default": 0
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "major_label_overrides",
        "type": "Dict(Either(Float, String), String)",
        "desc": "Provide explicit tick label values for specific tick locations that\n    override normal formatting.",
        "default": {}
      },
      {
        "name": "major_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the major tick labels.",
        "default": "center"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default y-range.",
        "default": "default"
      },
      {
        "name": "formatter",
        "type": "Instance(TickFormatter)",
        "desc": "A ``TickFormatter`` to use for formatting the visual appearance\n    of ticks.",
        "default": null
      },
      {
        "name": "major_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the major tick labels.",
        "default": "normal"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "ticker",
        "type": "Instance(Ticker)",
        "desc": "A Ticker to use for computing locations of axis components.\n\n    The property may also be passed a sequence of floating point numbers as\n    a shorthand for creating and configuring a ``FixedTicker``, e.g. the\n    following code\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n\n        p = figure()\n        p.xaxis.ticker = [10, 20, 37.4]\n\n    is equivalent to:\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n        from bokeh.models import FixedTicker\n\n        p = figure()\n        p.xaxis.ticker = FixedTicker(ticks=[10, 20, 37.4])",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "axis_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the axis labels should be offset\n    from the tick labels.",
        "default": 5
      },
      {
        "name": "major_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the major tick labels.",
        "default": "alphabetic"
      },
      {
        "name": "axis_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the axis label.",
        "default": 1.2
      },
      {
        "name": "axis_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the axis line.",
        "default": 0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "major_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the major ticks.",
        "default": 1.0
      },
      {
        "name": "major_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend into the\n    main plot area.",
        "default": 2
      },
      {
        "name": "minor_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the minor ticks.",
        "default": []
      },
      {
        "name": "major_label_text_font",
        "type": "String",
        "desc": "The text font of the major tick labels.",
        "default": "helvetica"
      },
      {
        "name": "minor_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the minor ticks.",
        "default": 1.0
      },
      {
        "name": "major_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the major tick labels.",
        "default": "11px"
      },
      {
        "name": "minor_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the minor ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the axis label.",
        "default": "left"
      },
      {
        "name": "major_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the major ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 4
      },
      {
        "name": "axis_label_text_color",
        "type": "Color",
        "desc": "The text color of the axis label.",
        "default": "#444444"
      },
      {
        "name": "fixed_location",
        "type": "Either(Float, String, Tuple(String, String), Tuple(String, String, String))",
        "desc": "Set to specify a fixed coordinate location to draw the axis. The direction\n    of ticks and major labels is determined by the side panel that the axis\n    belongs to.\n\n    .. note::\n        Axes labels are suppressed when axes are positioned at fixed locations\n        inside the central plot area.",
        "default": null
      },
      {
        "name": "major_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the major ticks.",
        "default": []
      },
      {
        "name": "major_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the major tick labels.",
        "default": 1.2
      },
      {
        "name": "minor_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the minor ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_line_color",
        "type": "Color",
        "desc": "The line color of the minor ticks.",
        "default": "black"
      },
      {
        "name": "axis_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the axis line.",
        "default": "bevel"
      },
      {
        "name": "major_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 6
      },
      {
        "name": "axis_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the axis label.",
        "default": "13px"
      },
      {
        "name": "axis_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the axis line.",
        "default": 1.0
      },
      {
        "name": "major_label_orientation",
        "type": "Either(Enum('horizontal', 'vertical'), Float)",
        "desc": "What direction the major label text should be oriented. If a\n    number is supplied, the angle of the text is measured from horizontal.",
        "default": "horizontal"
      },
      {
        "name": "minor_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the minor ticks.",
        "default": 0
      },
      {
        "name": "major_tick_line_color",
        "type": "Color",
        "desc": "The line color of the major ticks.",
        "default": "black"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "major_label_text_color",
        "type": "Color",
        "desc": "The text color of the major tick labels.",
        "default": "#444444"
      },
      {
        "name": "axis_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the axis line.",
        "default": "butt"
      },
      {
        "name": "major_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the major ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_font",
        "type": "String",
        "desc": "The text font of the axis label.",
        "default": "helvetica"
      },
      {
        "name": "axis_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the axis label.",
        "default": "bottom"
      },
      {
        "name": "axis_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the axis label.",
        "default": 1.0
      },
      {
        "name": "major_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the major tick labels.",
        "default": 1.0
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "guide"
      },
      {
        "name": "bounds",
        "type": "Either(Auto, Tuple(Float, Float), Tuple(Datetime, Datetime))",
        "desc": "Bounds for the rendered axis. If unset, the axis will span the\n    entire plot in the given dimension.",
        "default": "auto"
      }
    ]
  },
  "BBoxTileSource": {
    "name": "BBoxTileSource",
    "bases": [
      "bokeh.models.tiles.MercatorTileSource"
    ],
    "desc": "Has the same default tile origin as the ``WMTSTileSource`` but requested\n    tiles use a ``{XMIN}``, ``{YMIN}``, ``{XMAX}``, ``{YMAX}`` e.g.\n    ``http://your.custom.tile.service?bbox={XMIN},{YMIN},{XMAX},{YMAX}``.",
    "proto": "{\"attribution\": \"\", \"extra_url_vars\": {}, \"id\": \"1360\", \"initial_resolution\": 156543.03392804097, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_zoom\": 30, \"min_zoom\": 0, \"name\": null, \"snap_to_zoom\": false, \"subscribed_events\": [], \"tags\": [], \"tile_size\": 256, \"url\": \"\", \"use_latlon\": false, \"wrap_around\": true, \"x_origin_offset\": 20037508.34, \"y_origin_offset\": 20037508.34}",
    "props": [
      {
        "name": "url",
        "type": "String",
        "desc": "Tile service url e.g., http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png",
        "default": ""
      },
      {
        "name": "wrap_around",
        "type": "Bool",
        "desc": "Enables continuous horizontal panning by wrapping the x-axis based on\n    bounds of map.\n\n    ..note::\n        Axis coordinates are not wrapped. To toggle axis label visibility,\n        use ``plot.axis.visible = False``.",
        "default": true
      },
      {
        "name": "tile_size",
        "type": "Int",
        "desc": "Tile size in pixels (e.g. 256)",
        "default": 256
      },
      {
        "name": "extra_url_vars",
        "type": "Dict(String, Any)",
        "desc": "A dictionary that maps url variable template keys to values.\n\n    These variables are useful for parts of tile urls which do not change from\n    tile to tile (e.g. server host name, or layer name).",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "initial_resolution",
        "type": "Float",
        "desc": "Resolution (plot_units / pixels) of minimum zoom level of tileset\n    projection. None to auto-compute.",
        "default": 156543.03392804097
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "y_origin_offset",
        "type": "Float",
        "desc": "A y-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "x_origin_offset",
        "type": "Float",
        "desc": "An x-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "max_zoom",
        "type": "Int",
        "desc": "A maximum zoom level for the tile layer. This is the most zoomed-in level.",
        "default": 30
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "min_zoom",
        "type": "Int",
        "desc": "A minimum zoom level for the tile layer. This is the most zoomed-out level.",
        "default": 0
      },
      {
        "name": "use_latlon",
        "type": "Bool",
        "desc": "Flag which indicates option to output ``{XMIN}``, ``{YMIN}``, ``{XMAX}``, ``{YMAX}`` in meters or latitude and longitude.",
        "default": false
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "snap_to_zoom",
        "type": "Bool",
        "desc": "Forces initial extents to snap to the closest larger zoom level.",
        "default": false
      },
      {
        "name": "attribution",
        "type": "String",
        "desc": "Data provider attribution content. This can include HTML content.",
        "default": ""
      }
    ]
  },
  "Band": {
    "name": "Band",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render a filled area band along a dimension.\n\n    See :ref:`userguide_plotting_bands` for information on plotting bands.",
    "proto": "{\"base\": null, \"dimension\": \"height\", \"fill_alpha\": 0.4, \"fill_color\": \"#fff9ba\", \"id\": \"1378\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"line_alpha\": 0.3, \"line_cap\": \"butt\", \"line_color\": \"#cccccc\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"lower\": null, \"name\": null, \"source\": {\"id\": \"1379\"}, \"subscribed_events\": [], \"tags\": [], \"upper\": null, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the band.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the band.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the band.",
        "default": "#cccccc"
      },
      {
        "name": "fill_color",
        "type": "Color",
        "desc": "The fill color values for the band.",
        "default": "#fff9ba"
      },
      {
        "name": "source",
        "type": "Instance(DataSource)",
        "desc": "Local data source to use when rendering annotations on the plot.",
        "default": "{\"data\": {}, \"id\": \"1385\"}"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the band.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the band.",
        "default": 0.3
      },
      {
        "name": "dimension",
        "type": "Enum('width', 'height')",
        "desc": "The direction of the band can be specified by setting this property\n    to \"height\" (``y`` direction) or \"width\" (``x`` direction).",
        "default": "height"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "base",
        "type": "PropertyUnitsSpec(units_default='data')",
        "desc": "The orthogonal coordinates of the upper and lower values.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the band.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the band.",
        "default": 0.4
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "upper",
        "type": "PropertyUnitsSpec(units_default='data')",
        "desc": "The coordinates of the upper portion of the filled area band.",
        "default": null
      },
      {
        "name": "base_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "upper_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "lower",
        "type": "PropertyUnitsSpec(units_default='data')",
        "desc": "The coordinates of the lower portion of the filled area band.",
        "default": null
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the band.",
        "default": "bevel"
      },
      {
        "name": "lower_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      }
    ]
  },
  "BasicTickFormatter": {
    "name": "BasicTickFormatter",
    "bases": [
      "bokeh.models.formatters.TickFormatter"
    ],
    "desc": "Display tick values from continuous ranges as \"basic numbers\",\n    using scientific notation when appropriate by default.",
    "proto": "{\"id\": \"1407\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"power_limit_high\": 5, \"power_limit_low\": -3, \"precision\": \"auto\", \"subscribed_events\": [], \"tags\": [], \"use_scientific\": true}",
    "props": [
      {
        "name": "precision",
        "type": "Either(Auto, Int)",
        "desc": "How many digits of precision to display in tick labels.",
        "default": "auto"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "power_limit_low",
        "type": "Int",
        "desc": "Limit the use of scientific notation to when::\n\n        log(x) <= power_limit_low",
        "default": -3
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "use_scientific",
        "type": "Bool",
        "desc": "Whether to ever display scientific notation. If ``True``, then\n    when to use scientific notation is controlled by ``power_limit_low``\n    and ``power_limit_high``.",
        "default": true
      },
      {
        "name": "power_limit_high",
        "type": "Int",
        "desc": "Limit the use of scientific notation to when::\n\n        log(x) >= power_limit_high",
        "default": 5
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "BasicTicker": {
    "name": "BasicTicker",
    "bases": [
      "bokeh.models.tickers.AdaptiveTicker"
    ],
    "desc": "Generate ticks on a linear scale.\n\n    .. note::\n        This class may be renamed to ``LinearTicker`` in the future.",
    "proto": "{\"base\": 10.0, \"desired_num_ticks\": 6, \"id\": \"1417\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mantissas\": [1, 2, 5], \"max_interval\": null, \"min_interval\": 0.0, \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mantissas",
        "type": "Seq(Float)",
        "desc": "The acceptable list numbers to generate multiples of.",
        "default": [
          1,
          2,
          5
        ]
      },
      {
        "name": "base",
        "type": "Float",
        "desc": "The multiplier to use for scaling mantissas.",
        "default": 10.0
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "min_interval",
        "type": "Float",
        "desc": "The smallest allowable interval between two adjacent ticks.",
        "default": 0.0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "max_interval",
        "type": "Float",
        "desc": "The largest allowable interval between two adjacent ticks.\n\n    .. note::\n        To specify an unbounded interval, set to ``None``.",
        "default": null
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "Bezier": {
    "name": "Bezier",
    "bases": [
      "bokeh.models.glyph.LineGlyph"
    ],
    "desc": "Render Bezier curves.\n\n    For more information consult the `Wikipedia article for Bezier curve`_.\n\n    .. _Wikipedia article for Bezier curve: http://en.wikipedia.org/wiki/Bezier_curve\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Bezier.py\n        :source-position: below",
    "proto": "{\"cx0\": null, \"cx1\": null, \"cy0\": null, \"cy1\": null, \"id\": \"1429\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x0\": null, \"x1\": null, \"y0\": null, \"y1\": null}",
    "props": [
      {
        "name": "cy1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of second control points.",
        "default": null
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the Bezier curves.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the Bezier curves.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the Bezier curves.",
        "default": "black"
      },
      {
        "name": "cx0",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of first control points.",
        "default": null
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the Bezier curves.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "y1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the ending points.",
        "default": null
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the Bezier curves.",
        "default": 1.0
      },
      {
        "name": "cy0",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of first control points.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the Bezier curves.",
        "default": "butt"
      },
      {
        "name": "x1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the ending points.",
        "default": null
      },
      {
        "name": "y0",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the starting points.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "x0",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the starting points.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the Bezier curves.",
        "default": "bevel"
      },
      {
        "name": "cx1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of second control points.",
        "default": null
      }
    ]
  },
  "BooleanFilter": {
    "name": "BooleanFilter",
    "bases": [
      "bokeh.models.filters.Filter"
    ],
    "desc": "A ``BooleanFilter`` filters data by returning the subset of data corresponding to indices\n    where the values of the booleans array is True.",
    "proto": "{\"booleans\": null, \"filter\": null, \"id\": \"1450\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "booleans",
        "type": "Seq(Bool)",
        "desc": "A list of booleans indicating which rows of data to select.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "filter",
        "type": "Either(Seq(Int), Seq(Bool))",
        "desc": "A list that can be either integer indices or booleans representing a row-wise subset of data.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "BooleanFormatter": {
    "name": "BooleanFormatter",
    "bases": [
      "bokeh.models.widgets.tables.CellFormatter"
    ],
    "desc": "Boolean (check mark) cell formatter.",
    "proto": "{\"icon\": \"check\", \"id\": \"1458\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "icon",
        "type": "Enum('check', 'check-circle', 'check-circle-o', 'check-square', 'check-square-o')",
        "desc": "The icon visualizing the check mark.",
        "default": "check"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Box": {
    "name": "Box",
    "bases": [
      "bokeh.models.layouts.LayoutDOM"
    ],
    "desc": "Abstract base class for Row and Column. Do not use directly.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"children\": [], \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"1465\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"sizing_mode\": null, \"spacing\": 0, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "children",
        "type": "List(Instance(LayoutDOM))",
        "desc": "The list of children, which can be other components including plots, rows, columns, and widgets.",
        "default": []
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "spacing",
        "type": "Int",
        "desc": "The gap between children (in pixels).",
        "default": 0
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "BoxAnnotation": {
    "name": "BoxAnnotation",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render a shaded rectangular region as an annotation.\n\n    See :ref:`userguide_plotting_box_annotations` for information on plotting box annotations.",
    "proto": "{\"bottom\": null, \"bottom_units\": \"data\", \"fill_alpha\": 0.4, \"fill_color\": \"#fff9ba\", \"id\": \"1489\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"left\": null, \"left_units\": \"data\", \"level\": \"annotation\", \"line_alpha\": 0.3, \"line_cap\": \"butt\", \"line_color\": \"#cccccc\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"name\": null, \"render_mode\": \"canvas\", \"right\": null, \"right_units\": \"data\", \"subscribed_events\": [], \"tags\": [], \"top\": null, \"top_units\": \"data\", \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "left_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the left attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the box.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the box.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the box.",
        "default": "#cccccc"
      },
      {
        "name": "bottom",
        "type": "Either(Auto, NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float))",
        "desc": "The y-coordinates of the bottom edge of the box annotation.\n\n    Datetime values are also accepted, but note that they are immediately\n    converted to milliseconds-since-epoch.",
        "default": null
      },
      {
        "name": "fill_color",
        "type": "Color",
        "desc": "The fill color values for the box.",
        "default": "#fff9ba"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the box.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering box annotations on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "right_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the right attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the box.",
        "default": 0.3
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering box annotations on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the box.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the box.",
        "default": 0.4
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "left",
        "type": "Either(Auto, NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float))",
        "desc": "The x-coordinates of the left edge of the box annotation.\n\n    Datetime values are also accepted, but note that they are immediately\n    converted to milliseconds-since-epoch.",
        "default": null
      },
      {
        "name": "right",
        "type": "Either(Auto, NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float))",
        "desc": "The x-coordinates of the right edge of the box annotation.\n\n    Datetime values are also accepted, but note that they are immediately\n    converted to milliseconds-since-epoch.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "top_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the top attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "bottom_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the bottom attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the box.",
        "default": "bevel"
      },
      {
        "name": "render_mode",
        "type": "Enum('canvas', 'css')",
        "desc": "Specifies whether the box is rendered as a canvas element or as an\n    css element overlaid on the canvas. The default mode is \"canvas\".\n\n    .. note:\n        This property is deprecated and will be removed in bokeh 3.0.\n\n    .. warning::\n        The line_dash and line_dash_offset attributes aren't supported if\n        the render_mode is set to \"css\"",
        "default": "canvas"
      },
      {
        "name": "top",
        "type": "Either(Auto, NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float))",
        "desc": "The y-coordinates of the top edge of the box annotation.\n\n    Datetime values are also accepted, but note that they are immediately\n    converted to milliseconds-since-epoch.",
        "default": null
      }
    ]
  },
  "BoxEditTool": {
    "name": "BoxEditTool",
    "bases": [
      "bokeh.models.tools.EditTool",
      "bokeh.models.tools.Drag",
      "bokeh.models.tools.Tap"
    ],
    "desc": "*toolbar icon*: |box_edit_icon|\n\n    Allows drawing, dragging and deleting ``Rect`` glyphs on one or more\n    renderers by editing the underlying ``ColumnDataSource`` data. Like other\n    drawing tools, the renderers that are to be edited must be supplied\n    explicitly as a list. When drawing a new box the data will always be added\n    to the ``ColumnDataSource`` on the first supplied renderer.\n\n    The tool will modify the columns on the data source corresponding to the\n    ``x``, ``y``, ``width`` and ``height`` values of the glyph. Any additional\n    columns in the data source will be padded with ``empty_value``, when adding\n    a new box.\n\n    The supported actions include:\n\n    * Add box: Hold shift then click and drag anywhere on the plot or double\n      tap once to start drawing, move the mouse and double tap again to finish\n      drawing.\n\n    * Move box: Click and drag an existing box, the box will be dropped once\n      you let go of the mouse button.\n\n    * Delete box: Tap a box to select it then press <<backspace>> key while the\n      mouse is within the plot area.\n\n    To **Move** or **Delete** multiple boxes at once:\n\n    * Move selection: Select box(es) with <<shift>>+tap (or another selection\n      tool) then drag anywhere on the plot. Selecting and then dragging on a\n      specific box will move both.\n\n    * Delete selection: Select box(es) with <<shift>>+tap (or another selection\n      tool) then press <<backspace>> while the mouse is within the plot area.\n\n    .. |box_edit_icon| image:: /_images/icons/BoxEdit.png\n        :height: 24px",
    "proto": "{\"custom_icon\": null, \"custom_tooltip\": null, \"dimensions\": \"both\", \"empty_value\": null, \"id\": \"1517\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_objects\": 0, \"renderers\": [], \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "custom_icon",
        "type": "Image",
        "desc": "An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.",
        "default": null
      },
      {
        "name": "empty_value",
        "type": "Either(Bool, Int, Float, Date, Datetime, Color, String)",
        "desc": "Defines the value to insert on non-coordinate columns when a new\n    glyph is inserted into the ``ColumnDataSource`` columns, e.g. when a\n    circle glyph defines 'x', 'y' and 'color' columns, adding a new\n    point will add the x and y-coordinates to 'x' and 'y' columns and\n    the color column will be filled with the defined empty value.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "custom_tooltip",
        "type": "String",
        "desc": "A custom tooltip label to override the default name.",
        "default": null
      },
      {
        "name": "num_objects",
        "type": "Int",
        "desc": "Defines a limit on the number of boxes that can be drawn. By default there\n    is no limit on the number of objects, but if enabled the oldest drawn box\n    will be dropped to make space for the new box being added.",
        "default": 0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "dimensions",
        "type": "Enum('width', 'height', 'both')",
        "desc": "Which dimensions the box drawing is to be free in. By default, users may\n    freely draw boxes with any dimensions. If only \"width\" is set, the box will\n    be constrained to span the entire vertical space of the plot, only the\n    horizontal dimension can be controlled. If only \"height\" is set, the box\n    will be constrained to span the entire horizontal space of the plot, and the\n    vertical dimension can be controlled.",
        "default": "both"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "An explicit list of renderers corresponding to scatter glyphs that may\n    be edited.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "BoxSelectTool": {
    "name": "BoxSelectTool",
    "bases": [
      "bokeh.models.tools.Drag",
      "bokeh.models.tools.SelectTool"
    ],
    "desc": "*toolbar icon*: |box_select_icon|\n\n    The box selection tool allows users to make selections on a Plot by showing\n    a rectangular region by dragging the mouse or a finger over the plot area.\n    The end of the drag event indicates the selection region is ready.\n\n    See :ref:`userguide_styling_selected_unselected_glyphs` for information\n    on styling selected and unselected glyphs.\n\n\n    .. |box_select_icon| image:: /_images/icons/BoxSelect.png\n        :height: 24px",
    "proto": "{\"dimensions\": \"both\", \"id\": \"1529\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mode\": \"replace\", \"name\": null, \"names\": [], \"origin\": \"corner\", \"overlay\": {\"id\": \"1530\"}, \"renderers\": \"auto\", \"select_every_mousemove\": false, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('replace', 'append', 'intersect', 'subtract')",
        "desc": "Defines what should happen when a new selection is made. The default\n    is to replace the existing selection. Other options are to append to\n    the selection, intersect with it or subtract from it.",
        "default": "replace"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "origin",
        "type": "Enum('corner', 'center')",
        "desc": "Indicates whether the rectangular selection area should originate from a corner\n    (top-left or bottom-right depending on direction) or the center of the box.",
        "default": "corner"
      },
      {
        "name": "select_every_mousemove",
        "type": "Bool",
        "desc": "Whether a selection computation should happen on every mouse event, or only\n    once, when the selection region is completed. Default: False",
        "default": false
      },
      {
        "name": "names",
        "type": "List(String)",
        "desc": "A list of names to query for. If set, only renderers that have a matching\n    value for their ``name`` attribute will be used.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "overlay",
        "type": "Instance(BoxAnnotation)",
        "desc": "A shaded annotation drawn to indicate the selection region.",
        "default": "{\"bottom_units\": \"screen\", \"fill_alpha\": 0.5, \"fill_color\": \"lightgrey\", \"id\": \"1539\", \"left_units\": \"screen\", \"level\": \"overlay\", \"line_alpha\": 1.0, \"line_color\": \"black\", \"line_dash\": [4, 4], \"line_width\": 2, \"right_units\": \"screen\", \"top_units\": \"screen\"}"
      },
      {
        "name": "dimensions",
        "type": "Enum('width', 'height', 'both')",
        "desc": "Which dimensions the box selection is to be free in. By default, users may\n    freely draw selections boxes with any dimensions. If only \"width\" is set,\n    the box will be constrained to span the entire vertical space of the plot,\n    only the horizontal dimension can be controlled. If only \"height\" is set,\n    the box will be constrained to span the entire horizontal space of the\n    plot, and the vertical dimension can be controlled.",
        "default": "both"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "renderers",
        "type": "Either(Auto, List(Instance(Renderer)))",
        "desc": "An explicit list of renderers to hit test against. If unset,\n    defaults to all renderers on a plot.",
        "default": "auto"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "BoxZoomTool": {
    "name": "BoxZoomTool",
    "bases": [
      "bokeh.models.tools.Drag"
    ],
    "desc": "*toolbar icon*: |box_zoom_icon|\n\n    The box zoom tool allows users to define a rectangular egion of a Plot to\n    zoom to by dragging he mouse or a finger over the plot region. The end of\n    the drag event indicates the selection region is ready.\n\n    .. |box_zoom_icon| image:: /_images/icons/BoxZoom.png\n        :height: 24px\n\n    .. note::\n        ``BoxZoomTool`` is incompatible with ``GMapPlot`` due to the manner in\n        which Google Maps exert explicit control over aspect ratios. Adding\n        this tool to a ``GMapPlot`` will have no effect.",
    "proto": "{\"dimensions\": \"both\", \"id\": \"1544\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"match_aspect\": false, \"name\": null, \"origin\": \"corner\", \"overlay\": {\"id\": \"1545\"}, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "match_aspect",
        "type": "Bool",
        "desc": "Whether the box zoom region should be restricted to have the same\n    aspect ratio as the plot region.\n\n    .. note::\n        If the tool is restricted to one dimension, this value has\n        no effect.",
        "default": false
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "origin",
        "type": "Enum('corner', 'center')",
        "desc": "Indicates whether the rectangular zoom area should originate from a corner\n    (top-left or bottom-right depending on direction) or the center of the box.",
        "default": "corner"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "overlay",
        "type": "Instance(BoxAnnotation)",
        "desc": "A shaded annotation drawn to indicate the selection region.",
        "default": "{\"bottom_units\": \"screen\", \"fill_alpha\": 0.5, \"fill_color\": \"lightgrey\", \"id\": \"1552\", \"left_units\": \"screen\", \"level\": \"overlay\", \"line_alpha\": 1.0, \"line_color\": \"black\", \"line_dash\": [4, 4], \"line_width\": 2, \"right_units\": \"screen\", \"top_units\": \"screen\"}"
      },
      {
        "name": "dimensions",
        "type": "Enum('width', 'height', 'both')",
        "desc": "Which dimensions the zoom box is to be free in. By default, users may\n    freely draw zoom boxes with any dimensions. If only \"width\" is supplied,\n    the box will be constrained to span the entire vertical space of the plot,\n    only the horizontal dimension can be controlled. If only \"height\" is\n    supplied, the box will be constrained to span the entire horizontal space\n    of the plot, and the vertical dimension can be controlled.",
        "default": "both"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Button": {
    "name": "Button",
    "bases": [
      "bokeh.models.widgets.buttons.AbstractButton"
    ],
    "desc": "A click button.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"button_type\": \"default\", \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"icon\": null, \"id\": \"1556\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"label\": \"Button\", \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "button_type",
        "type": "Enum('default', 'primary', 'success', 'warning', 'danger')",
        "desc": "A style for the button, signifying it's role.",
        "default": "default"
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "label",
        "type": "String",
        "desc": "The text label for the button to display.",
        "default": "Button"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "icon",
        "type": "Instance(AbstractIcon)",
        "desc": "An optional image appearing to the left of button's text.",
        "default": null
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "ButtonGroup": {
    "name": "ButtonGroup",
    "bases": [
      "bokeh.models.widgets.groups.AbstractGroup",
      "bokeh.models.widgets.buttons.ButtonLike"
    ],
    "desc": "Abstract base class for groups with items rendered as buttons.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"button_type\": \"default\", \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"1583\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"labels\": [], \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "button_type",
        "type": "Enum('default', 'primary', 'success', 'warning', 'danger')",
        "desc": "A style for the button, signifying it's role.",
        "default": "default"
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "labels",
        "type": "List(String)",
        "desc": "List of text labels contained in this group.",
        "default": []
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "CDSView": {
    "name": "CDSView",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A view into a ``ColumnDataSource`` that represents a row-wise subset.",
    "proto": "{\"filters\": [], \"id\": \"1609\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"source\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "filters",
        "type": "List(Instance(Filter))",
        "desc": "List of filters that the view comprises.",
        "default": []
      },
      {
        "name": "source",
        "type": "Instance(ColumnarDataSource)",
        "desc": "The ``ColumnDataSource`` associated with this view. Used to determine\n    the length of the columns.",
        "default": null
      }
    ]
  },
  "Callback": {
    "name": "Callback",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Base class for interactive callback.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"1617\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CanvasTexture": {
    "name": "CanvasTexture",
    "bases": [
      "bokeh.models.textures.Texture"
    ],
    "desc": "",
    "proto": "{\"code\": null, \"id\": \"1623\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"repetition\": \"repeat\", \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "code",
        "type": "String",
        "desc": "A snippet of JavaScript code to execute in the browser.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "repetition",
        "type": "Enum('repeat', 'repeat_x', 'repeat_y', 'no_repeat')",
        "desc": "",
        "default": "repeat"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CategoricalAxis": {
    "name": "CategoricalAxis",
    "bases": [
      "bokeh.models.axes.Axis"
    ],
    "desc": "An axis that displays ticks and labels for categorical ranges.\n\n    The ``CategoricalAxis`` can handle factor ranges with up to two levels of\n    nesting, including drawing a separator line between top-level groups of\n    factors.",
    "proto": "{\"axis_label\": \"\", \"axis_label_standoff\": 5, \"axis_label_text_align\": \"left\", \"axis_label_text_alpha\": 1.0, \"axis_label_text_baseline\": \"bottom\", \"axis_label_text_color\": \"#444444\", \"axis_label_text_font\": \"helvetica\", \"axis_label_text_font_size\": \"13px\", \"axis_label_text_font_style\": \"italic\", \"axis_label_text_line_height\": 1.2, \"axis_line_alpha\": 1.0, \"axis_line_cap\": \"butt\", \"axis_line_color\": \"black\", \"axis_line_dash\": [], \"axis_line_dash_offset\": 0, \"axis_line_join\": \"bevel\", \"axis_line_width\": 1, \"bounds\": \"auto\", \"fixed_location\": null, \"formatter\": {\"id\": \"1633\"}, \"group_label_orientation\": \"parallel\", \"group_text_align\": \"left\", \"group_text_alpha\": 1.0, \"group_text_baseline\": \"bottom\", \"group_text_color\": \"grey\", \"group_text_font\": \"helvetica\", \"group_text_font_size\": \"11px\", \"group_text_font_style\": \"bold\", \"group_text_line_height\": 1.2, \"id\": \"1631\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"guide\", \"major_label_orientation\": \"horizontal\", \"major_label_overrides\": {}, \"major_label_standoff\": 5, \"major_label_text_align\": \"center\", \"major_label_text_alpha\": 1.0, \"major_label_text_baseline\": \"alphabetic\", \"major_label_text_color\": \"#444444\", \"major_label_text_font\": \"helvetica\", \"major_label_text_font_size\": \"11px\", \"major_label_text_font_style\": \"normal\", \"major_label_text_line_height\": 1.2, \"major_tick_in\": 2, \"major_tick_line_alpha\": 1.0, \"major_tick_line_cap\": \"butt\", \"major_tick_line_color\": \"black\", \"major_tick_line_dash\": [], \"major_tick_line_dash_offset\": 0, \"major_tick_line_join\": \"bevel\", \"major_tick_line_width\": 1, \"major_tick_out\": 6, \"minor_tick_in\": 0, \"minor_tick_line_alpha\": 1.0, \"minor_tick_line_cap\": \"butt\", \"minor_tick_line_color\": \"black\", \"minor_tick_line_dash\": [], \"minor_tick_line_dash_offset\": 0, \"minor_tick_line_join\": \"bevel\", \"minor_tick_line_width\": 1, \"minor_tick_out\": 4, \"name\": null, \"separator_line_alpha\": 1.0, \"separator_line_cap\": \"butt\", \"separator_line_color\": \"lightgrey\", \"separator_line_dash\": [], \"separator_line_dash_offset\": 0, \"separator_line_join\": \"bevel\", \"separator_line_width\": 2, \"subgroup_label_orientation\": \"parallel\", \"subgroup_text_align\": \"left\", \"subgroup_text_alpha\": 1.0, \"subgroup_text_baseline\": \"bottom\", \"subgroup_text_color\": \"#444444\", \"subgroup_text_font\": \"helvetica\", \"subgroup_text_font_size\": \"11px\", \"subgroup_text_font_style\": \"bold\", \"subgroup_text_line_height\": 1.2, \"subscribed_events\": [], \"tags\": [], \"ticker\": {\"id\": \"1632\"}, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "subgroup_text_color",
        "type": "Color",
        "desc": "The text color of the subgroup categorical labels.\n\n    This property always applies to factors in the middle level of nesting.\n    If the list of categorical factors is has only zero or one levels of nesting,\n    then this property has no effect.",
        "default": "#444444"
      },
      {
        "name": "subgroup_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the subgroup categorical labels.\n\n    This property always applies to factors in the middle level of nesting.\n    If the list of categorical factors is has only zero or one levels of nesting,\n    then this property has no effect.",
        "default": "bold"
      },
      {
        "name": "major_tick_line_width",
        "type": "Float",
        "desc": "The line width of the major ticks.",
        "default": 1
      },
      {
        "name": "separator_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the separator line between top-level categorical groups.\n\n    This property always applies to factors in the outermost level of nesting.",
        "default": 1.0
      },
      {
        "name": "group_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the group categorical labels.\n\n    This property always applies to factors in the outermost level of nesting.\n    If the list of categorical factors is flat (i.e. no nesting) then this\n    property has no effect.",
        "default": 1.0
      },
      {
        "name": "axis_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the axis label.",
        "default": "italic"
      },
      {
        "name": "separator_line_width",
        "type": "Float",
        "desc": "The line width of the separator line between top-level categorical groups.\n\n    This property always applies to factors in the outermost level of nesting.",
        "default": 2
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default x-range.",
        "default": "default"
      },
      {
        "name": "minor_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that minor ticks should extend into the\n    main plot area.",
        "default": 0
      },
      {
        "name": "minor_tick_line_width",
        "type": "Float",
        "desc": "The line width of the minor ticks.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subgroup_text_font",
        "type": "String",
        "desc": "The text font of the subgroup categorical labels.\n\n    This property always applies to factors in the middle level of nesting.\n    If the list of categorical factors is has only zero or one levels of nesting,\n    then this property has no effect.",
        "default": "helvetica"
      },
      {
        "name": "major_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the major tick labels.",
        "default": "center"
      },
      {
        "name": "major_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the major tick labels.",
        "default": "normal"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "separator_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the separator line between top-level categorical groups.\n\n    This property always applies to factors in the outermost level of nesting.",
        "default": []
      },
      {
        "name": "ticker",
        "type": "Instance(Ticker)",
        "desc": "A Ticker to use for computing locations of axis components.\n\n    The property may also be passed a sequence of floating point numbers as\n    a shorthand for creating and configuring a ``FixedTicker``, e.g. the\n    following code\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n\n        p = figure()\n        p.xaxis.ticker = [10, 20, 37.4]\n\n    is equivalent to:\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n        from bokeh.models import FixedTicker\n\n        p = figure()\n        p.xaxis.ticker = FixedTicker(ticks=[10, 20, 37.4])",
        "default": "{\"id\": \"1652\"}"
      },
      {
        "name": "separator_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the separator line between top-level categorical groups.\n\n    This property always applies to factors in the outermost level of nesting.",
        "default": "butt"
      },
      {
        "name": "subgroup_label_orientation",
        "type": "Either(Enum('horizontal', 'vertical', 'parallel', 'normal'), Float)",
        "desc": "What direction the subgroup label text should be oriented.\n\n    If a number is supplied, the angle of the text is measured from horizontal.\n\n    This property always applies to factors in the middle level of nesting.\n    If the list of categorical factors is has only zero or one levels of nesting,\n    then this property has no effect.",
        "default": "parallel"
      },
      {
        "name": "axis_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the axis labels should be offset\n    from the tick labels.",
        "default": 5
      },
      {
        "name": "axis_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the axis label.",
        "default": 1.2
      },
      {
        "name": "axis_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the axis line.",
        "default": 0
      },
      {
        "name": "group_text_font",
        "type": "String",
        "desc": "The text font of the group categorical labels.\n\n    This property always applies to factors in the outermost level of nesting.\n    If the list of categorical factors is flat (i.e. no nesting) then this\n    property has no effect.",
        "default": "helvetica"
      },
      {
        "name": "fixed_location",
        "type": "Either(Float, String, Tuple(String, String), Tuple(String, String, String))",
        "desc": "Set to specify a fixed coordinate location to draw the axis. The direction\n    of ticks and major labels is determined by the side panel that the axis\n    belongs to.\n\n    .. note::\n        Axes labels are suppressed when axes are positioned at fixed locations\n        inside the central plot area.",
        "default": null
      },
      {
        "name": "major_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the major ticks.",
        "default": "butt"
      },
      {
        "name": "major_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the major ticks.",
        "default": []
      },
      {
        "name": "major_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the major tick labels.",
        "default": 1.2
      },
      {
        "name": "minor_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the minor ticks.",
        "default": "butt"
      },
      {
        "name": "major_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 6
      },
      {
        "name": "axis_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the axis label.",
        "default": "13px"
      },
      {
        "name": "axis_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the axis line.",
        "default": 1.0
      },
      {
        "name": "group_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the group categorical labels.\n\n    This property always applies to factors in the outermost level of nesting.\n    If the list of categorical factors is flat (i.e. no nesting) then this\n    property has no effect.",
        "default": "left"
      },
      {
        "name": "group_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the group categorical labels.\n\n    This property always applies to factors in the outermost level of nesting.\n    If the list of categorical factors is flat (i.e. no nesting) then this\n    property has no effect.",
        "default": "bottom"
      },
      {
        "name": "group_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the group categorical labels.\n\n    This property always applies to factors in the outermost level of nesting.\n    If the list of categorical factors is flat (i.e. no nesting) then this\n    property has no effect.",
        "default": "bold"
      },
      {
        "name": "major_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the major ticks.",
        "default": "bevel"
      },
      {
        "name": "major_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the major tick labels.",
        "default": 1.0
      },
      {
        "name": "group_text_color",
        "type": "Color",
        "desc": "The text color of the group categorical labels.\n\n    This property always applies to factors in the outermost level of nesting.\n    If the list of categorical factors is flat (i.e. no nesting) then this\n    property has no effect.",
        "default": "grey"
      },
      {
        "name": "axis_line_width",
        "type": "Float",
        "desc": "The line width of the axis line.",
        "default": 1
      },
      {
        "name": "major_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the major tick labels should be\n    offset from the associated ticks.",
        "default": 5
      },
      {
        "name": "axis_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the axis line.",
        "default": []
      },
      {
        "name": "axis_line_color",
        "type": "Color",
        "desc": "The line color of the axis line.",
        "default": "black"
      },
      {
        "name": "separator_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the separator line between top-level categorical groups.\n\n    This property always applies to factors in the outermost level of nesting.",
        "default": 0
      },
      {
        "name": "subgroup_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the subgroup categorical labels.\n\n    This property always applies to factors in the middle level of nesting.\n    If the list of categorical factors is has only zero or one levels of nesting,\n    then this property has no effect.",
        "default": "left"
      },
      {
        "name": "axis_label",
        "type": "String",
        "desc": "A text label for the axis, displayed parallel to the axis rule.\n\n    .. note::\n        LaTeX notation is not currently supported; please see\n        :bokeh-issue:`647` to track progress or contribute.",
        "default": ""
      },
      {
        "name": "subgroup_text_line_height",
        "type": "Float",
        "desc": "The text line height of the subgroup categorical labels.\n\n    This property always applies to factors in the middle level of nesting.\n    If the list of categorical factors is has only zero or one levels of nesting,\n    then this property has no effect.",
        "default": 1.2
      },
      {
        "name": "major_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the major ticks.",
        "default": 0
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "subgroup_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the subgroup categorical labels.\n\n    This property always applies to factors in the middle level of nesting.\n    If the list of categorical factors is has only zero or one levels of nesting,\n    then this property has no effect.",
        "default": 1.0
      },
      {
        "name": "major_label_overrides",
        "type": "Dict(Either(Float, String), String)",
        "desc": "Provide explicit tick label values for specific tick locations that\n    override normal formatting.",
        "default": {}
      },
      {
        "name": "formatter",
        "type": "Instance(TickFormatter)",
        "desc": "A ``TickFormatter`` to use for formatting the visual appearance\n    of ticks.",
        "default": "{\"id\": \"1686\"}"
      },
      {
        "name": "group_label_orientation",
        "type": "Either(Enum('horizontal', 'vertical', 'parallel', 'normal'), Float)",
        "desc": "What direction the group label text should be oriented.\n\n    If a number is supplied, the angle of the text is measured from horizontal.\n\n    This property always applies to factors in the outermost level of nesting.\n    If the list of categorical factors is flat (i.e. no nesting) then this\n    property has no effect.",
        "default": "parallel"
      },
      {
        "name": "separator_line_color",
        "type": "Color",
        "desc": "The line color of the separator line between top-level categorical groups.\n\n    This property always applies to factors in the outermost level of nesting.",
        "default": "lightgrey"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "major_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the major tick labels.",
        "default": "alphabetic"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "major_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the major ticks.",
        "default": 1.0
      },
      {
        "name": "major_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend into the\n    main plot area.",
        "default": 2
      },
      {
        "name": "minor_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the minor ticks.",
        "default": []
      },
      {
        "name": "major_label_text_font",
        "type": "String",
        "desc": "The text font of the major tick labels.",
        "default": "helvetica"
      },
      {
        "name": "minor_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the minor ticks.",
        "default": 1.0
      },
      {
        "name": "major_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the major tick labels.",
        "default": "11px"
      },
      {
        "name": "minor_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the minor ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the axis label.",
        "default": "left"
      },
      {
        "name": "minor_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 4
      },
      {
        "name": "axis_label_text_color",
        "type": "Color",
        "desc": "The text color of the axis label.",
        "default": "#444444"
      },
      {
        "name": "subgroup_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the subgroup categorical labels.\n\n    This property always applies to factors in the middle level of nesting.\n    If the list of categorical factors is has only zero or one levels of nesting,\n    then this property has no effect.",
        "default": "11px"
      },
      {
        "name": "separator_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the separator line between top-level categorical groups.\n\n    This property always applies to factors in the outermost level of nesting.",
        "default": "bevel"
      },
      {
        "name": "minor_tick_line_color",
        "type": "Color",
        "desc": "The line color of the minor ticks.",
        "default": "black"
      },
      {
        "name": "axis_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the axis line.",
        "default": "bevel"
      },
      {
        "name": "major_label_orientation",
        "type": "Either(Enum('horizontal', 'vertical'), Float)",
        "desc": "What direction the major label text should be oriented. If a\n    number is supplied, the angle of the text is measured from horizontal.",
        "default": "horizontal"
      },
      {
        "name": "minor_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the minor ticks.",
        "default": 0
      },
      {
        "name": "major_tick_line_color",
        "type": "Color",
        "desc": "The line color of the major ticks.",
        "default": "black"
      },
      {
        "name": "group_text_line_height",
        "type": "Float",
        "desc": "The text line height of the group categorical labels.\n\n    This property always applies to factors in the outermost level of nesting.\n    If the list of categorical factors is flat (i.e. no nesting) then this\n    property has no effect.",
        "default": 1.2
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "major_label_text_color",
        "type": "Color",
        "desc": "The text color of the major tick labels.",
        "default": "#444444"
      },
      {
        "name": "group_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the group categorical labels.\n\n    This property always applies to factors in the outermost level of nesting.\n    If the list of categorical factors is flat (i.e. no nesting) then this\n    property has no effect.",
        "default": "11px"
      },
      {
        "name": "axis_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the axis line.",
        "default": "butt"
      },
      {
        "name": "axis_label_text_font",
        "type": "String",
        "desc": "The text font of the axis label.",
        "default": "helvetica"
      },
      {
        "name": "axis_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the axis label.",
        "default": "bottom"
      },
      {
        "name": "axis_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the axis label.",
        "default": 1.0
      },
      {
        "name": "subgroup_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the subgroup categorical labels.\n\n    This property always applies to factors in the middle level of nesting.\n    If the list of categorical factors is has only zero or one levels of nesting,\n    then this property has no effect.",
        "default": "bottom"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "guide"
      },
      {
        "name": "bounds",
        "type": "Either(Auto, Tuple(Float, Float), Tuple(Datetime, Datetime))",
        "desc": "Bounds for the rendered axis. If unset, the axis will span the\n    entire plot in the given dimension.",
        "default": "auto"
      }
    ]
  },
  "CategoricalColorMapper": {
    "name": "CategoricalColorMapper",
    "bases": [
      "bokeh.models.mappers.CategoricalMapper",
      "bokeh.models.mappers.ColorMapper"
    ],
    "desc": "Map categorical factors to colors.\n\n    Values that are passed to this mapper that are not in the factors list\n    will be mapped to ``nan_color``.",
    "proto": "{\"end\": null, \"factors\": null, \"id\": \"1720\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"nan_color\": \"gray\", \"palette\": null, \"start\": 0, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "end",
        "type": "Int",
        "desc": "A start index to \"slice\" data factors with before mapping.\n\n    For example, if the data to color map consists of 2-level factors such\n    as ``[\"2016\", \"sales\"]`` and ``[\"2017\", \"marketing\"]``, then setting\n    ``end=1`` will perform color mapping only based on the first sub-factor\n    (i.e. in this case based on the year ``\"2016\"`` or ``\"2017\"``)\n\n    If ``None`` then all sub-factors from ``start`` to the end of the\n    factor will be used for color mapping.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "start",
        "type": "Int",
        "desc": "A start index to \"slice\" data factors with before mapping.\n\n    For example, if the data to color map consists of 2-level factors such\n    as ``[\"2016\", \"sales\"]`` and ``[\"2016\", \"marketing\"]``, then setting\n    ``start=1`` will perform color mapping only based on the second sub-factor\n    (i.e. in this case based on the department ``\"sales\"`` or ``\"marketing\"``)",
        "default": 0
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "factors",
        "type": "Either(Seq(String), Seq(Tuple(String, String)), Seq(Tuple(String, String, String)))",
        "desc": "A sequence of factors / categories that map to the some target range. For\n    example the following color mapper:\n\n    .. code-block:: python\n\n        mapper = CategoricalColorMapper(palette=[\"red\", \"blue\"], factors=[\"foo\", \"bar\"])\n\n    will map the factor ``\"foo\"`` to red and the factor ``\"bar\"`` to blue.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "nan_color",
        "type": "Color",
        "desc": "Color to be used if data is NaN or otherwise not mappable. (Default: 'gray')",
        "default": "gray"
      },
      {
        "name": "palette",
        "type": "Seq(Color)",
        "desc": "A sequence of colors to use as the target palette for mapping.\n\n    This property can also be set as a ``String``, to the name of any of the\n    palettes shown in :ref:`bokeh.palettes`.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CategoricalMapper": {
    "name": "CategoricalMapper",
    "bases": [
      "bokeh.models.mappers.Mapper"
    ],
    "desc": "Base class for mappers that map categorical factors to other values.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"end\": null, \"factors\": null, \"id\": \"1731\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"start\": 0, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "end",
        "type": "Int",
        "desc": "A start index to \"slice\" data factors with before mapping.\n\n    For example, if the data to color map consists of 2-level factors such\n    as ``[\"2016\", \"sales\"]`` and ``[\"2017\", \"marketing\"]``, then setting\n    ``end=1`` will perform color mapping only based on the first sub-factor\n    (i.e. in this case based on the year ``\"2016\"`` or ``\"2017\"``)\n\n    If ``None`` then all sub-factors from ``start`` to the end of the\n    factor will be used for color mapping.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "start",
        "type": "Int",
        "desc": "A start index to \"slice\" data factors with before mapping.\n\n    For example, if the data to color map consists of 2-level factors such\n    as ``[\"2016\", \"sales\"]`` and ``[\"2016\", \"marketing\"]``, then setting\n    ``start=1`` will perform color mapping only based on the second sub-factor\n    (i.e. in this case based on the department ``\"sales\"`` or ``\"marketing\"``)",
        "default": 0
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "factors",
        "type": "Either(Seq(String), Seq(Tuple(String, String)), Seq(Tuple(String, String, String)))",
        "desc": "A sequence of factors / categories that map to the some target range. For\n    example the following color mapper:\n\n    .. code-block:: python\n\n        mapper = CategoricalColorMapper(palette=[\"red\", \"blue\"], factors=[\"foo\", \"bar\"])\n\n    will map the factor ``\"foo\"`` to red and the factor ``\"bar\"`` to blue.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CategoricalMarkerMapper": {
    "name": "CategoricalMarkerMapper",
    "bases": [
      "bokeh.models.mappers.CategoricalMapper"
    ],
    "desc": "Map categorical factors to marker types.\n\n    Values that are passed to this mapper that are not in the factors list\n    will be mapped to ``default_value``.\n\n    .. note::\n        This mappers is primarily only useful with the ``Scatter`` marker\n        glyph that be parameterized by marker type.",
    "proto": "{\"default_value\": \"circle\", \"end\": null, \"factors\": null, \"id\": \"1740\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"markers\": null, \"name\": null, \"start\": 0, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "end",
        "type": "Int",
        "desc": "A start index to \"slice\" data factors with before mapping.\n\n    For example, if the data to color map consists of 2-level factors such\n    as ``[\"2016\", \"sales\"]`` and ``[\"2017\", \"marketing\"]``, then setting\n    ``end=1`` will perform color mapping only based on the first sub-factor\n    (i.e. in this case based on the year ``\"2016\"`` or ``\"2017\"``)\n\n    If ``None`` then all sub-factors from ``start`` to the end of the\n    factor will be used for color mapping.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "start",
        "type": "Int",
        "desc": "A start index to \"slice\" data factors with before mapping.\n\n    For example, if the data to color map consists of 2-level factors such\n    as ``[\"2016\", \"sales\"]`` and ``[\"2016\", \"marketing\"]``, then setting\n    ``start=1`` will perform color mapping only based on the second sub-factor\n    (i.e. in this case based on the department ``\"sales\"`` or ``\"marketing\"``)",
        "default": 0
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "markers",
        "type": "Seq(MarkerType('asterisk', 'circle', 'circle_cross', 'circle_dot', 'circle_x', 'circle_y', 'cross', 'dash', 'diamond', 'diamond_cross', 'diamond_dot', 'dot', 'hex', 'hex_dot', 'inverted_triangle', 'plus', 'square', 'square_cross', 'square_dot', 'square_pin', 'square_x', 'triangle', 'triangle_dot', 'triangle_pin', 'x', 'y'))",
        "desc": "A sequence of marker types to use as the target for mapping.",
        "default": null
      },
      {
        "name": "factors",
        "type": "Either(Seq(String), Seq(Tuple(String, String)), Seq(Tuple(String, String, String)))",
        "desc": "A sequence of factors / categories that map to the some target range. For\n    example the following color mapper:\n\n    .. code-block:: python\n\n        mapper = CategoricalColorMapper(palette=[\"red\", \"blue\"], factors=[\"foo\", \"bar\"])\n\n    will map the factor ``\"foo\"`` to red and the factor ``\"bar\"`` to blue.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "default_value",
        "type": "MarkerType('asterisk', 'circle', 'circle_cross', 'circle_dot', 'circle_x', 'circle_y', 'cross', 'dash', 'diamond', 'diamond_cross', 'diamond_dot', 'dot', 'hex', 'hex_dot', 'inverted_triangle', 'plus', 'square', 'square_cross', 'square_dot', 'square_pin', 'square_x', 'triangle', 'triangle_dot', 'triangle_pin', 'x', 'y')",
        "desc": "A marker type to use in case an unrecognized factor is passed in to be\n    mapped.",
        "default": "circle"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CategoricalPatternMapper": {
    "name": "CategoricalPatternMapper",
    "bases": [
      "bokeh.models.mappers.CategoricalMapper"
    ],
    "desc": "Map categorical factors to hatch fill patterns.\n\n    Values that are passed to this mapper that are not in the factors list\n    will be mapped to ``default_value``.\n\n    Added in version 1.1.1",
    "proto": "{\"default_value\": \" \", \"end\": null, \"factors\": null, \"id\": \"1751\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"patterns\": null, \"start\": 0, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "end",
        "type": "Int",
        "desc": "A start index to \"slice\" data factors with before mapping.\n\n    For example, if the data to color map consists of 2-level factors such\n    as ``[\"2016\", \"sales\"]`` and ``[\"2017\", \"marketing\"]``, then setting\n    ``end=1`` will perform color mapping only based on the first sub-factor\n    (i.e. in this case based on the year ``\"2016\"`` or ``\"2017\"``)\n\n    If ``None`` then all sub-factors from ``start`` to the end of the\n    factor will be used for color mapping.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "start",
        "type": "Int",
        "desc": "A start index to \"slice\" data factors with before mapping.\n\n    For example, if the data to color map consists of 2-level factors such\n    as ``[\"2016\", \"sales\"]`` and ``[\"2016\", \"marketing\"]``, then setting\n    ``start=1`` will perform color mapping only based on the second sub-factor\n    (i.e. in this case based on the department ``\"sales\"`` or ``\"marketing\"``)",
        "default": 0
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "factors",
        "type": "Either(Seq(String), Seq(Tuple(String, String)), Seq(Tuple(String, String, String)))",
        "desc": "A sequence of factors / categories that map to the some target range. For\n    example the following color mapper:\n\n    .. code-block:: python\n\n        mapper = CategoricalColorMapper(palette=[\"red\", \"blue\"], factors=[\"foo\", \"bar\"])\n\n    will map the factor ``\"foo\"`` to red and the factor ``\"bar\"`` to blue.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "patterns",
        "type": "Seq(HatchPatternType)",
        "desc": "A sequence of marker types to use as the target for mapping.",
        "default": null
      },
      {
        "name": "default_value",
        "type": "HatchPatternType",
        "desc": "A hatch pattern to use in case an unrecognized factor is passed in to be\n    mapped.",
        "default": " "
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CategoricalScale": {
    "name": "CategoricalScale",
    "bases": [
      "bokeh.models.scales.Scale"
    ],
    "desc": "Represent a scale transformation between a categorical source range and\n    continuous target range.",
    "proto": "{\"id\": \"1762\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CategoricalTickFormatter": {
    "name": "CategoricalTickFormatter",
    "bases": [
      "bokeh.models.formatters.TickFormatter"
    ],
    "desc": "Display tick values from categorical ranges as string\n    values.",
    "proto": "{\"id\": \"1768\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CategoricalTicker": {
    "name": "CategoricalTicker",
    "bases": [
      "bokeh.models.tickers.Ticker"
    ],
    "desc": "Generate ticks for categorical ranges.",
    "proto": "{\"id\": \"1774\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CellEditor": {
    "name": "CellEditor",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Abstract base class for data table's cell editors.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"1780\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CellFormatter": {
    "name": "CellFormatter",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Abstract base class for data table's cell formatters.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"1786\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CheckboxButtonGroup": {
    "name": "CheckboxButtonGroup",
    "bases": [
      "bokeh.models.widgets.groups.ButtonGroup"
    ],
    "desc": "A group of check boxes rendered as toggle buttons.",
    "proto": "{\"active\": [], \"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"button_type\": \"default\", \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"1792\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"labels\": [], \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "button_type",
        "type": "Enum('default', 'primary', 'success', 'warning', 'danger')",
        "desc": "A style for the button, signifying it's role.",
        "default": "default"
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "active",
        "type": "List(Int)",
        "desc": "The list of indices of selected check boxes.",
        "default": []
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "labels",
        "type": "List(String)",
        "desc": "List of text labels contained in this group.",
        "default": []
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "CheckboxEditor": {
    "name": "CheckboxEditor",
    "bases": [
      "bokeh.models.widgets.tables.CellEditor"
    ],
    "desc": "Boolean value cell editor.",
    "proto": "{\"id\": \"1819\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CheckboxGroup": {
    "name": "CheckboxGroup",
    "bases": [
      "bokeh.models.widgets.groups.Group"
    ],
    "desc": "A group of check boxes.",
    "proto": "{\"active\": [], \"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"1825\", \"inline\": false, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"labels\": [], \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "active",
        "type": "List(Int)",
        "desc": "The list of indices of selected check boxes.",
        "default": []
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "labels",
        "type": "List(String)",
        "desc": "List of text labels contained in this group.",
        "default": []
      },
      {
        "name": "inline",
        "type": "Bool",
        "desc": "Should items be arrange vertically (``False``) or horizontally\n    in-line (``True``).",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Circle": {
    "name": "Circle",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render circle markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Circle.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"1852\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"radius\": null, \"radius_dimension\": \"x\", \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "radius_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "radius",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The radius values for circle markers (in \"data space\" units, by default).\n\n    .. note::\n        Circle markers are slightly unusual in that they support specifying\n        a radius in addition to a size. Only one of ``radius`` or ``size``\n        should be given.\n\n    .. warning::\n        Note that ``Circle`` glyphs are always drawn as circles on the screen,\n        even in cases where the data space aspect ratio is not 1-1. In all\n        cases where radius values are specified, the \"distance\" for the radius\n        is measured along the dimension specified by ``radius_dimension``. If\n        the aspect ratio is very large or small, the drawn circles may appear\n        much larger or smaller than expected. See :bokeh-issue:`626` for more\n        information.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "radius_dimension",
        "type": "Enum('x', 'y', 'max', 'min')",
        "desc": "What dimension to measure circle radii along.\n\n    When the data space aspect ratio is not 1-1, then the size of the drawn\n    circles depends on what direction is used to measure the \"distance\" of\n    the radius. This property allows that direction to be controlled.\n\n    Setting this dimension to 'max' will calculate the radius on both the x\n    and y dimensions and use the maximum of the two, 'min' selects the minimum.",
        "default": "x"
      }
    ]
  },
  "CircleCross": {
    "name": "CircleCross",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render circle markers with a '+' cross through the center. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/CircleCross.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"1875\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "CircleDot": {
    "name": "CircleDot",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render circle markers with center dots. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/CircleDot.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"1895\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "CircleX": {
    "name": "CircleX",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render circle markers with an 'X' cross through the center. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/CircleX.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"1915\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "CircleY": {
    "name": "CircleY",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render circle markers with an 'Y' cross through the center. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/CircleY.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"1935\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "ColorBar": {
    "name": "ColorBar",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render a color bar based on a color mapper.\n\n    See :ref:`userguide_plotting_color_bars` for information on plotting color bars.",
    "proto": "{\"background_fill_alpha\": 0.95, \"background_fill_color\": \"#ffffff\", \"bar_line_alpha\": 1.0, \"bar_line_cap\": \"butt\", \"bar_line_color\": null, \"bar_line_dash\": [], \"bar_line_dash_offset\": 0, \"bar_line_join\": \"bevel\", \"bar_line_width\": 1, \"border_line_alpha\": 1.0, \"border_line_cap\": \"butt\", \"border_line_color\": null, \"border_line_dash\": [], \"border_line_dash_offset\": 0, \"border_line_join\": \"bevel\", \"border_line_width\": 1, \"color_mapper\": null, \"formatter\": {\"id\": \"1957\"}, \"height\": \"auto\", \"id\": \"1955\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"label_standoff\": 5, \"level\": \"annotation\", \"location\": \"top_right\", \"major_label_overrides\": {}, \"major_label_text_align\": \"center\", \"major_label_text_alpha\": 1.0, \"major_label_text_baseline\": \"middle\", \"major_label_text_color\": \"#444444\", \"major_label_text_font\": \"helvetica\", \"major_label_text_font_size\": \"11px\", \"major_label_text_font_style\": \"normal\", \"major_label_text_line_height\": 1.2, \"major_tick_in\": 5, \"major_tick_line_alpha\": 1.0, \"major_tick_line_cap\": \"butt\", \"major_tick_line_color\": \"#ffffff\", \"major_tick_line_dash\": [], \"major_tick_line_dash_offset\": 0, \"major_tick_line_join\": \"bevel\", \"major_tick_line_width\": 1, \"major_tick_out\": 0, \"margin\": 30, \"minor_tick_in\": 0, \"minor_tick_line_alpha\": 1.0, \"minor_tick_line_cap\": \"butt\", \"minor_tick_line_color\": null, \"minor_tick_line_dash\": [], \"minor_tick_line_dash_offset\": 0, \"minor_tick_line_join\": \"bevel\", \"minor_tick_line_width\": 1, \"minor_tick_out\": 0, \"name\": null, \"orientation\": \"vertical\", \"padding\": 10, \"scale_alpha\": 1.0, \"subscribed_events\": [], \"tags\": [], \"ticker\": {\"id\": \"1956\"}, \"title\": null, \"title_standoff\": 2, \"title_text_align\": \"left\", \"title_text_alpha\": 1.0, \"title_text_baseline\": \"bottom\", \"title_text_color\": \"#444444\", \"title_text_font\": \"helvetica\", \"title_text_font_size\": \"13px\", \"title_text_font_style\": \"italic\", \"title_text_line_height\": 1.2, \"visible\": true, \"width\": \"auto\"}",
    "props": [
      {
        "name": "major_tick_line_width",
        "type": "Float",
        "desc": "The line width of the major ticks.",
        "default": 1
      },
      {
        "name": "title_text_font_size",
        "type": "FontSize",
        "desc": "The text font size values for the title text.",
        "default": "13px"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "minor_tick_in",
        "type": "Int",
        "desc": "The distance (in pixels) that minor ticks should extend into the\n    main plot area.",
        "default": 0
      },
      {
        "name": "minor_tick_line_width",
        "type": "Float",
        "desc": "The line width of the minor ticks.",
        "default": 1
      },
      {
        "name": "bar_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap for the color scale bar outline.",
        "default": "butt"
      },
      {
        "name": "border_line_width",
        "type": "Float",
        "desc": "The line width for the color bar border outline.",
        "default": 1
      },
      {
        "name": "border_line_color",
        "type": "Color",
        "desc": "The line color for the color bar border outline.",
        "default": null
      },
      {
        "name": "major_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the major tick labels.",
        "default": "center"
      },
      {
        "name": "major_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the major tick labels.",
        "default": "normal"
      },
      {
        "name": "title_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align values for the title text.",
        "default": "left"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "ticker",
        "type": "Instance(ContinuousTicker)",
        "desc": "A Ticker to use for computing locations of axis components.",
        "default": "{\"id\": \"1971\"}"
      },
      {
        "name": "bar_line_dash",
        "type": "DashPattern",
        "desc": "The line dash for the color scale bar outline.",
        "default": []
      },
      {
        "name": "background_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha for the color bar background style.",
        "default": 0.95
      },
      {
        "name": "padding",
        "type": "Int",
        "desc": "Amount of padding (in pixels) between the color scale and color bar border.",
        "default": 10
      },
      {
        "name": "scale_alpha",
        "type": "Float",
        "desc": "The alpha with which to render the color scale.",
        "default": 1.0
      },
      {
        "name": "major_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the major ticks.",
        "default": "butt"
      },
      {
        "name": "major_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the major ticks.",
        "default": []
      },
      {
        "name": "bar_line_color",
        "type": "Color",
        "desc": "The line color for the color scale bar outline.",
        "default": null
      },
      {
        "name": "major_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the major tick labels.",
        "default": 1.2
      },
      {
        "name": "minor_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the minor ticks.",
        "default": "butt"
      },
      {
        "name": "major_tick_out",
        "type": "Int",
        "desc": "The distance (in pixels) that major ticks should extend out of the\n    main plot area.",
        "default": 0
      },
      {
        "name": "color_mapper",
        "type": "Instance(ContinuousColorMapper)",
        "desc": "A continuous color mapper containing a color palette to render.\n\n    .. warning::\n        If the `low` and `high` attributes of the ``ColorMapper`` aren't set, ticks\n        and tick labels won't be rendered. Additionally, if a ``LogTicker`` is\n        passed to the `ticker` argument and either or both of the logarithms\n        of `low` and `high` values of the color_mapper are non-numeric\n        (i.e. `low=0`), the tick and tick labels won't be rendered.",
        "default": null
      },
      {
        "name": "title",
        "type": "String",
        "desc": "The title text to render.",
        "default": null
      },
      {
        "name": "border_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset for the color bar border outline.",
        "default": 0
      },
      {
        "name": "major_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the major ticks.",
        "default": "bevel"
      },
      {
        "name": "major_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the major tick labels.",
        "default": 1.0
      },
      {
        "name": "background_fill_color",
        "type": "Color",
        "desc": "The fill color for the color bar background style.",
        "default": "#ffffff"
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Whether the color bar should be oriented vertically or horizontally.",
        "default": "vertical"
      },
      {
        "name": "title_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style values for the title text.",
        "default": "italic"
      },
      {
        "name": "title_text_color",
        "type": "Color",
        "desc": "The text color values for the title text.",
        "default": "#444444"
      },
      {
        "name": "bar_line_width",
        "type": "Float",
        "desc": "The line width for the color scale bar outline.",
        "default": 1
      },
      {
        "name": "major_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the major ticks.",
        "default": 0
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "width",
        "type": "Either(Auto, Int)",
        "desc": "The width (in pixels) that the color scale should occupy.",
        "default": "auto"
      },
      {
        "name": "title_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline values for the title text.",
        "default": "bottom"
      },
      {
        "name": "major_label_overrides",
        "type": "Dict(Either(Float, String), String)",
        "desc": "Provide explicit tick label values for specific tick locations that\n    override normal formatting.",
        "default": {}
      },
      {
        "name": "formatter",
        "type": "Instance(TickFormatter)",
        "desc": "A ``TickFormatter`` to use for formatting the visual appearance of ticks.",
        "default": "{\"id\": \"1998\"}"
      },
      {
        "name": "height",
        "type": "Either(Auto, Int)",
        "desc": "The height (in pixels) that the color scale should occupy.",
        "default": "auto"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "major_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the major tick labels.",
        "default": "middle"
      },
      {
        "name": "title_standoff",
        "type": "Int",
        "desc": "The distance (in pixels) to separate the title from the color bar.",
        "default": 2
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "major_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the major ticks.",
        "default": 1.0
      },
      {
        "name": "major_tick_in",
        "type": "Int",
        "desc": "The distance (in pixels) that major ticks should extend into the\n    main plot area.",
        "default": 5
      },
      {
        "name": "minor_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the minor ticks.",
        "default": []
      },
      {
        "name": "major_label_text_font",
        "type": "String",
        "desc": "The text font of the major tick labels.",
        "default": "helvetica"
      },
      {
        "name": "border_line_alpha",
        "type": "Percent",
        "desc": "The line alpha for the color bar border outline.",
        "default": 1.0
      },
      {
        "name": "margin",
        "type": "Int",
        "desc": "Amount of margin (in pixels) around the outside of the color bar.",
        "default": 30
      },
      {
        "name": "minor_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the minor ticks.",
        "default": 1.0
      },
      {
        "name": "major_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the major tick labels.",
        "default": "11px"
      },
      {
        "name": "title_text_font",
        "type": "String",
        "desc": "The text font values for the title text.",
        "default": "helvetica"
      },
      {
        "name": "border_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap for the color bar border outline.",
        "default": "butt"
      },
      {
        "name": "bar_line_alpha",
        "type": "Percent",
        "desc": "The line alpha for the color scale bar outline.",
        "default": 1.0
      },
      {
        "name": "minor_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the minor ticks.",
        "default": "bevel"
      },
      {
        "name": "minor_tick_out",
        "type": "Int",
        "desc": "The distance (in pixels) that major ticks should extend out of the\n    main plot area.",
        "default": 0
      },
      {
        "name": "title_text_alpha",
        "type": "Percent",
        "desc": "The text alpha values for the title text.",
        "default": 1.0
      },
      {
        "name": "label_standoff",
        "type": "Int",
        "desc": "The distance (in pixels) to separate the tick labels from the color bar.",
        "default": 5
      },
      {
        "name": "minor_tick_line_color",
        "type": "Color",
        "desc": "The line color of the minor ticks.",
        "default": null
      },
      {
        "name": "location",
        "type": "Either(Enum('top_left', 'top_center', 'top_right', 'center_left', 'center', 'center_right', 'bottom_left', 'bottom_center', 'bottom_right'), Tuple(Float, Float))",
        "desc": "The location where the color bar should draw itself. It's either one of\n    ``bokeh.core.enums.LegendLocation``'s enumerated values, or a ``(x, y)``\n    tuple indicating an absolute location absolute location in screen\n    coordinates (pixels from the bottom-left corner).\n\n    .. warning::\n        If the color bar is placed in a side panel, the location will likely\n        have to be set to `(0,0)`.",
        "default": "top_right"
      },
      {
        "name": "title_text_line_height",
        "type": "Float",
        "desc": "The text line height values for the title text.",
        "default": 1.2
      },
      {
        "name": "minor_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the minor ticks.",
        "default": 0
      },
      {
        "name": "bar_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join for the color scale bar outline.",
        "default": "bevel"
      },
      {
        "name": "major_tick_line_color",
        "type": "Color",
        "desc": "The line color of the major ticks.",
        "default": "#ffffff"
      },
      {
        "name": "bar_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset for the color scale bar outline.",
        "default": 0
      },
      {
        "name": "border_line_dash",
        "type": "DashPattern",
        "desc": "The line dash for the color bar border outline.",
        "default": []
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "major_label_text_color",
        "type": "Color",
        "desc": "The text color of the major tick labels.",
        "default": "#444444"
      },
      {
        "name": "border_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join for the color bar border outline.",
        "default": "bevel"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      }
    ]
  },
  "ColorMapper": {
    "name": "ColorMapper",
    "bases": [
      "bokeh.models.mappers.Mapper"
    ],
    "desc": "Base class for color mapper types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"2031\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"nan_color\": \"gray\", \"palette\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "nan_color",
        "type": "Color",
        "desc": "Color to be used if data is NaN or otherwise not mappable. (Default: 'gray')",
        "default": "gray"
      },
      {
        "name": "palette",
        "type": "Seq(Color)",
        "desc": "A sequence of colors to use as the target palette for mapping.\n\n    This property can also be set as a ``String``, to the name of any of the\n    palettes shown in :ref:`bokeh.palettes`.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ColorPicker": {
    "name": "ColorPicker",
    "bases": [
      "bokeh.models.widgets.inputs.InputWidget"
    ],
    "desc": "Color picker widget\n\n    .. warning::\n        This widget as a limited support on *Internet Explorer* (it will be displayed\n        as a simple text input).",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"color\": \"#000000\", \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"2039\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "color",
        "type": "ColorHex",
        "desc": "The initial color of the picked color (named or hexadecimal)",
        "default": "#000000"
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Column": {
    "name": "Column",
    "bases": [
      "bokeh.models.layouts.Box"
    ],
    "desc": "Lay out child components in a single vertical row.\n\n    Children can be specified as positional arguments, as a single argument\n    that is a sequence, or using the ``children`` keyword argument.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"children\": [], \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"2065\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"rows\": \"auto\", \"sizing_mode\": null, \"spacing\": 0, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "children",
        "type": "List(Instance(LayoutDOM))",
        "desc": "The list of children, which can be other components including plots, rows, columns, and widgets.",
        "default": []
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "rows",
        "type": "Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Dict(Either(Int, String), Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Struct(policy=Enum('auto', 'min'), align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fixed'), height=Int, align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fit', 'max'), flex=Float, align=Either(Auto, Enum('start', 'center', 'end'))))))",
        "desc": "Describes how the component should maintain its rows' heights.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion.",
        "default": "auto"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "spacing",
        "type": "Int",
        "desc": "The gap between children (in pixels).",
        "default": 0
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "ColumnDataSource": {
    "name": "ColumnDataSource",
    "bases": [
      "bokeh.models.sources.ColumnarDataSource"
    ],
    "desc": "Maps names of columns to sequences or arrays.\n\n    The ``ColumnDataSource`` is a fundamental data structure of Bokeh. Most\n    plots, data tables, etc. will be driven by a ``ColumnDataSource``.\n\n    If the ``ColumnDataSource`` initializer is called with a single argument that\n    can be any of the following:\n\n    * A Python ``dict`` that maps string names to sequences of values, e.g.\n      lists, arrays, etc.\n\n      .. code-block:: python\n\n          data = {'x': [1,2,3,4], 'y': np.ndarray([10.0, 20.0, 30.0, 40.0])}\n\n          source = ColumnDataSource(data)\n\n    .. note::\n        ``ColumnDataSource`` only creates a shallow copy of ``data``. Use e.g.\n        ``ColumnDataSource(copy.deepcopy(data))`` if initializing from another\n        ``ColumnDataSource.data`` object that you want to keep independent.\n\n    * A Pandas ``DataFrame`` object\n\n      .. code-block:: python\n\n          source = ColumnDataSource(df)\n\n      In this case the CDS will have columns corresponding to the columns of\n      the ``DataFrame``. If the ``DataFrame`` columns have multiple levels,\n      they will be flattened using an underscore (e.g. level_0_col_level_1_col).\n      The index of the ``DataFrame`` will be flattened to an ``Index`` of tuples\n      if it's a ``MultiIndex``, and then reset using ``reset_index``. The result\n      will be a column with the same name if the index was named, or\n      level_0_name_level_1_name if it was a named ``MultiIndex``. If the\n      ``Index`` did not have a name or the ``MultiIndex`` name could not be\n      flattened/determined, the ``reset_index`` function will name the index column\n      ``index``, or ``level_0`` if the name ``index`` is not available.\n\n    * A Pandas ``GroupBy`` object\n\n      .. code-block:: python\n\n          group = df.groupby(('colA', 'ColB'))\n\n      In this case the CDS will have columns corresponding to the result of\n      calling ``group.describe()``. The ``describe`` method generates columns\n      for statistical measures such as ``mean`` and ``count`` for all the\n      non-grouped original columns. The CDS columns are formed by joining\n      original column names with the computed measure. For example, if a\n      ``DataFrame`` has columns ``'year'`` and ``'mpg'``. Then passing\n      ``df.groupby('year')`` to a CDS will result in columns such as\n      ``'mpg_mean'``\n\n      If the ``GroupBy.describe`` result has a named index column, then\n      CDS will also have a column with this name. However, if the index name\n      (or any subname of a ``MultiIndex``) is ``None``, then the CDS will have\n      a column generically named ``index`` for the index.\n\n      Note this capability to adapt ``GroupBy`` objects may only work with\n      Pandas ``>=0.20.0``.\n\n    .. note::\n        There is an implicit assumption that all the columns in a given\n        ``ColumnDataSource`` all have the same length at all times. For this\n        reason, it is usually preferable to update the ``.data`` property\n        of a data source \"all at once\".",
    "proto": "{\"data\": {}, \"id\": \"2090\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"selected\": {\"id\": \"2091\"}, \"selection_policy\": {\"id\": \"2092\"}, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "selected",
        "type": "Instance(Selection)",
        "desc": "An instance of a ``Selection`` that indicates selected indices on this ``DataSource``.\n    This is a read-only property. You may only change the attributes of this object\n    to change the selection (e.g., ``selected.indices``).",
        "default": "{\"id\": \"2096\"}"
      },
      {
        "name": "selection_policy",
        "type": "Instance(SelectionPolicy)",
        "desc": "An instance of a ``SelectionPolicy`` that determines how selections are set.",
        "default": "{\"id\": \"2098\"}"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "data",
        "type": "ColumnData(String, Seq(Any))",
        "desc": "Mapping of column names to sequences of data. The columns can be, e.g,\n    Python lists or tuples, NumPy arrays, etc.\n\n    The .data attribute can also be set from Pandas DataFrames or GroupBy\n    objects. In these cases, the behaviour is identical to passing the objects\n    to the ``ColumnDataSource`` initializer.",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ColumnarDataSource": {
    "name": "ColumnarDataSource",
    "bases": [
      "bokeh.models.sources.DataSource"
    ],
    "desc": "A base class for data source types, which can be mapped onto\n    a columnar format.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"2103\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"selected\": {\"id\": \"2104\"}, \"selection_policy\": {\"id\": \"2105\"}, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "selected",
        "type": "Instance(Selection)",
        "desc": "An instance of a ``Selection`` that indicates selected indices on this ``DataSource``.\n    This is a read-only property. You may only change the attributes of this object\n    to change the selection (e.g., ``selected.indices``).",
        "default": "{\"id\": \"2111\"}"
      },
      {
        "name": "selection_policy",
        "type": "Instance(SelectionPolicy)",
        "desc": "An instance of a ``SelectionPolicy`` that determines how selections are set.",
        "default": "{\"id\": \"2113\"}"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CompositeTicker": {
    "name": "CompositeTicker",
    "bases": [
      "bokeh.models.tickers.ContinuousTicker"
    ],
    "desc": "Combine different tickers at different scales.\n\n    Uses the ``min_interval`` and ``max_interval`` interval attributes\n    of the tickers to select the appropriate ticker at different\n    scales.",
    "proto": "{\"desired_num_ticks\": 6, \"id\": \"2115\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": [], \"tickers\": []}",
    "props": [
      {
        "name": "tickers",
        "type": "Seq(Instance(Ticker))",
        "desc": "A list of Ticker objects to combine at different scales in order\n    to generate tick values. The supplied tickers should be in order.\n    Specifically, if S comes before T, then it should be the case that::\n\n        S.get_max_interval() < T.get_min_interval()",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "ConnectedXYGlyph": {
    "name": "ConnectedXYGlyph",
    "bases": [
      "bokeh.models.glyph.XYGlyph"
    ],
    "desc": "Base class of glyphs with `x` and `y` coordinate attributes and\n    a connected topology.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"2124\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ContinuousAxis": {
    "name": "ContinuousAxis",
    "bases": [
      "bokeh.models.axes.Axis"
    ],
    "desc": "A base class for all numeric, non-categorical axes types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"axis_label\": \"\", \"axis_label_standoff\": 5, \"axis_label_text_align\": \"left\", \"axis_label_text_alpha\": 1.0, \"axis_label_text_baseline\": \"bottom\", \"axis_label_text_color\": \"#444444\", \"axis_label_text_font\": \"helvetica\", \"axis_label_text_font_size\": \"13px\", \"axis_label_text_font_style\": \"italic\", \"axis_label_text_line_height\": 1.2, \"axis_line_alpha\": 1.0, \"axis_line_cap\": \"butt\", \"axis_line_color\": \"black\", \"axis_line_dash\": [], \"axis_line_dash_offset\": 0, \"axis_line_join\": \"bevel\", \"axis_line_width\": 1, \"bounds\": \"auto\", \"fixed_location\": null, \"formatter\": null, \"id\": \"2130\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"guide\", \"major_label_orientation\": \"horizontal\", \"major_label_overrides\": {}, \"major_label_standoff\": 5, \"major_label_text_align\": \"center\", \"major_label_text_alpha\": 1.0, \"major_label_text_baseline\": \"alphabetic\", \"major_label_text_color\": \"#444444\", \"major_label_text_font\": \"helvetica\", \"major_label_text_font_size\": \"11px\", \"major_label_text_font_style\": \"normal\", \"major_label_text_line_height\": 1.2, \"major_tick_in\": 2, \"major_tick_line_alpha\": 1.0, \"major_tick_line_cap\": \"butt\", \"major_tick_line_color\": \"black\", \"major_tick_line_dash\": [], \"major_tick_line_dash_offset\": 0, \"major_tick_line_join\": \"bevel\", \"major_tick_line_width\": 1, \"major_tick_out\": 6, \"minor_tick_in\": 0, \"minor_tick_line_alpha\": 1.0, \"minor_tick_line_cap\": \"butt\", \"minor_tick_line_color\": \"black\", \"minor_tick_line_dash\": [], \"minor_tick_line_dash_offset\": 0, \"minor_tick_line_join\": \"bevel\", \"minor_tick_line_width\": 1, \"minor_tick_out\": 4, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"ticker\": null, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "axis_line_width",
        "type": "Float",
        "desc": "The line width of the axis line.",
        "default": 1
      },
      {
        "name": "major_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the major tick labels should be\n    offset from the associated ticks.",
        "default": 5
      },
      {
        "name": "axis_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the axis line.",
        "default": []
      },
      {
        "name": "major_tick_line_width",
        "type": "Float",
        "desc": "The line width of the major ticks.",
        "default": 1
      },
      {
        "name": "axis_line_color",
        "type": "Color",
        "desc": "The line color of the axis line.",
        "default": "black"
      },
      {
        "name": "axis_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the axis label.",
        "default": "italic"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default x-range.",
        "default": "default"
      },
      {
        "name": "axis_label",
        "type": "String",
        "desc": "A text label for the axis, displayed parallel to the axis rule.\n\n    .. note::\n        LaTeX notation is not currently supported; please see\n        :bokeh-issue:`647` to track progress or contribute.",
        "default": ""
      },
      {
        "name": "major_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the major ticks.",
        "default": 0
      },
      {
        "name": "minor_tick_line_width",
        "type": "Float",
        "desc": "The line width of the minor ticks.",
        "default": 1
      },
      {
        "name": "minor_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that minor ticks should extend into the\n    main plot area.",
        "default": 0
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "major_label_overrides",
        "type": "Dict(Either(Float, String), String)",
        "desc": "Provide explicit tick label values for specific tick locations that\n    override normal formatting.",
        "default": {}
      },
      {
        "name": "major_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the major tick labels.",
        "default": "center"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default y-range.",
        "default": "default"
      },
      {
        "name": "formatter",
        "type": "Instance(TickFormatter)",
        "desc": "A ``TickFormatter`` to use for formatting the visual appearance\n    of ticks.",
        "default": null
      },
      {
        "name": "major_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the major tick labels.",
        "default": "normal"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "ticker",
        "type": "Instance(Ticker)",
        "desc": "A Ticker to use for computing locations of axis components.\n\n    The property may also be passed a sequence of floating point numbers as\n    a shorthand for creating and configuring a ``FixedTicker``, e.g. the\n    following code\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n\n        p = figure()\n        p.xaxis.ticker = [10, 20, 37.4]\n\n    is equivalent to:\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n        from bokeh.models import FixedTicker\n\n        p = figure()\n        p.xaxis.ticker = FixedTicker(ticks=[10, 20, 37.4])",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "axis_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the axis labels should be offset\n    from the tick labels.",
        "default": 5
      },
      {
        "name": "major_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the major tick labels.",
        "default": "alphabetic"
      },
      {
        "name": "axis_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the axis label.",
        "default": 1.2
      },
      {
        "name": "axis_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the axis line.",
        "default": 0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "major_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the major ticks.",
        "default": 1.0
      },
      {
        "name": "major_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend into the\n    main plot area.",
        "default": 2
      },
      {
        "name": "minor_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the minor ticks.",
        "default": []
      },
      {
        "name": "major_label_text_font",
        "type": "String",
        "desc": "The text font of the major tick labels.",
        "default": "helvetica"
      },
      {
        "name": "minor_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the minor ticks.",
        "default": 1.0
      },
      {
        "name": "major_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the major tick labels.",
        "default": "11px"
      },
      {
        "name": "minor_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the minor ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the axis label.",
        "default": "left"
      },
      {
        "name": "major_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the major ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 4
      },
      {
        "name": "axis_label_text_color",
        "type": "Color",
        "desc": "The text color of the axis label.",
        "default": "#444444"
      },
      {
        "name": "fixed_location",
        "type": "Either(Float, String, Tuple(String, String), Tuple(String, String, String))",
        "desc": "Set to specify a fixed coordinate location to draw the axis. The direction\n    of ticks and major labels is determined by the side panel that the axis\n    belongs to.\n\n    .. note::\n        Axes labels are suppressed when axes are positioned at fixed locations\n        inside the central plot area.",
        "default": null
      },
      {
        "name": "major_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the major ticks.",
        "default": []
      },
      {
        "name": "major_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the major tick labels.",
        "default": 1.2
      },
      {
        "name": "minor_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the minor ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_line_color",
        "type": "Color",
        "desc": "The line color of the minor ticks.",
        "default": "black"
      },
      {
        "name": "axis_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the axis line.",
        "default": "bevel"
      },
      {
        "name": "major_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 6
      },
      {
        "name": "axis_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the axis label.",
        "default": "13px"
      },
      {
        "name": "axis_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the axis line.",
        "default": 1.0
      },
      {
        "name": "major_label_orientation",
        "type": "Either(Enum('horizontal', 'vertical'), Float)",
        "desc": "What direction the major label text should be oriented. If a\n    number is supplied, the angle of the text is measured from horizontal.",
        "default": "horizontal"
      },
      {
        "name": "minor_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the minor ticks.",
        "default": 0
      },
      {
        "name": "major_tick_line_color",
        "type": "Color",
        "desc": "The line color of the major ticks.",
        "default": "black"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "major_label_text_color",
        "type": "Color",
        "desc": "The text color of the major tick labels.",
        "default": "#444444"
      },
      {
        "name": "axis_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the axis line.",
        "default": "butt"
      },
      {
        "name": "major_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the major ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_font",
        "type": "String",
        "desc": "The text font of the axis label.",
        "default": "helvetica"
      },
      {
        "name": "axis_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the axis label.",
        "default": "bottom"
      },
      {
        "name": "axis_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the axis label.",
        "default": 1.0
      },
      {
        "name": "major_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the major tick labels.",
        "default": 1.0
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "guide"
      },
      {
        "name": "bounds",
        "type": "Either(Auto, Tuple(Float, Float), Tuple(Datetime, Datetime))",
        "desc": "Bounds for the rendered axis. If unset, the axis will span the\n    entire plot in the given dimension.",
        "default": "auto"
      }
    ]
  },
  "ContinuousColorMapper": {
    "name": "ContinuousColorMapper",
    "bases": [
      "bokeh.models.mappers.ColorMapper"
    ],
    "desc": "Base class for continuous color mapper types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"high\": null, \"high_color\": null, \"id\": \"2190\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"low\": null, \"low_color\": null, \"name\": null, \"nan_color\": \"gray\", \"palette\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "low",
        "type": "Float",
        "desc": "The minimum value of the range to map into the palette. Values below\n    this are clamped to ``low``.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "nan_color",
        "type": "Color",
        "desc": "Color to be used if data is NaN or otherwise not mappable. (Default: 'gray')",
        "default": "gray"
      },
      {
        "name": "palette",
        "type": "Seq(Color)",
        "desc": "A sequence of colors to use as the target palette for mapping.\n\n    This property can also be set as a ``String``, to the name of any of the\n    palettes shown in :ref:`bokeh.palettes`.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "high",
        "type": "Float",
        "desc": "The maximum value of the range to map into the palette. Values above\n    this are clamped to ``high``.",
        "default": null
      },
      {
        "name": "low_color",
        "type": "Color",
        "desc": "Color to be used if data is lower than ``low`` value. If None,\n    values lower than ``low`` are mapped to the first color in the palette.",
        "default": null
      },
      {
        "name": "high_color",
        "type": "Color",
        "desc": "Color to be used if data is higher than ``high`` value. If None,\n    values higher than ``high`` are mapped to the last color in the palette.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ContinuousScale": {
    "name": "ContinuousScale",
    "bases": [
      "bokeh.models.scales.Scale"
    ],
    "desc": "Represent a scale transformation between continuous ranges.",
    "proto": "{\"id\": \"2202\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ContinuousTicker": {
    "name": "ContinuousTicker",
    "bases": [
      "bokeh.models.tickers.Ticker"
    ],
    "desc": "A base class for non-categorical ticker types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"desired_num_ticks\": 6, \"id\": \"2208\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "Cross": {
    "name": "Cross",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render '+' cross markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Cross.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"2216\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "CrosshairTool": {
    "name": "CrosshairTool",
    "bases": [
      "bokeh.models.tools.Inspection"
    ],
    "desc": "*toolbar icon*: |crosshair_icon|\n\n    The crosshair tool is a passive inspector tool. It is generally on at all\n    times, but can be configured in the inspector's menu associated with the\n    *toolbar icon* shown above.\n\n    The crosshair tool draws a crosshair annotation over the plot, centered on\n    the current mouse position. The crosshair tool may be configured to draw\n    across only one dimension by setting the ``dimension`` property to only\n    ``width`` or ``height``.\n\n    .. |crosshair_icon| image:: /_images/icons/Crosshair.png\n        :height: 24px",
    "proto": "{\"dimensions\": \"both\", \"id\": \"2236\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": 1.0, \"line_color\": \"black\", \"line_width\": 1, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"toggleable\": true}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "A color to use to stroke paths with.\n\n    Acceptable values are:\n\n    - any of the 147 named `CSS colors`_, e.g ``'green'``, ``'indigo'``\n    - an RGB(A) hex value, e.g., ``'#FF0000'``, ``'#44444444'``\n    - a 3-tuple of integers (r,g,b) between 0 and 255\n    - a 4-tuple of (r,g,b,a) where r,g,b are integers between 0..255 and a is between 0..1\n\n    .. _CSS colors: http://www.w3schools.com/cssref/css_colornames.asp",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "Stroke width in units of pixels.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "dimensions",
        "type": "Enum('width', 'height', 'both')",
        "desc": "Which dimensions the crosshair tool is to track. By default, both vertical\n    and horizontal lines will be drawn. If only \"width\" is supplied, only a\n    horizontal line will be drawn. If only \"height\" is supplied, only a\n    vertical line will be drawn.",
        "default": "both"
      },
      {
        "name": "line_alpha",
        "type": "Float",
        "desc": "An alpha value to use to stroke paths with.\n\n    Acceptable values are floating point numbers between 0 (transparent)\n    and 1 (opaque).",
        "default": 1.0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "toggleable",
        "type": "Bool",
        "desc": "Whether an on/off toggle button should appear in the toolbar for this\n    inspection tool. If ``False``, the viewers of a plot will not be able to\n    toggle the inspector on or off using the toolbar.",
        "default": true
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "CumSum": {
    "name": "CumSum",
    "bases": [
      "bokeh.models.expressions.Expression"
    ],
    "desc": "An expression for generating arrays by cumulatively summing a single\n    column from a ``ColumnDataSource``.",
    "proto": "{\"field\": null, \"id\": \"2247\", \"include_zero\": false, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "field",
        "type": "String",
        "desc": "The name of a ``ColumnDataSource`` column to cumulatively sum for new values.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "include_zero",
        "type": "Bool",
        "desc": "Whether to include zero at the start of the result. Note that the length\n    of the result is always the same as the input column. Therefore if this\n    property is True, then the last value of the column will not be included\n    in the sum.\n\n    .. code-block:: python\n\n        source = ColumnDataSource(data=dict(foo=[1, 2, 3, 4]))\n\n        CumSum(field='foo')\n        # -> [1, 3, 6, 10]\n\n        CumSum(field='foo', include_zero=True)\n        # -> [0, 1, 3, 6]",
        "default": false
      }
    ]
  },
  "CustomAction": {
    "name": "CustomAction",
    "bases": [
      "bokeh.models.tools.Action"
    ],
    "desc": "Execute a custom action, e.g. ``CustomJS`` callback when a toolbar\n    icon is activated.\n\n    Example:\n\n        .. code-block:: python\n\n            tool = CustomAction(icon=\"icon.png\",\n                                callback=CustomJS(code='alert(\"foo\")'))\n\n            plot.add_tools(tool)",
    "proto": "{\"action_tooltip\": \"Perform a Custom Action\", \"callback\": null, \"icon\": null, \"id\": \"2255\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "callback",
        "type": "Instance(Callback)",
        "desc": "A Bokeh callback to execute when the custom action icon is activated.",
        "default": null
      },
      {
        "name": "icon",
        "type": "Image",
        "desc": "An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.",
        "default": null
      },
      {
        "name": "action_tooltip",
        "type": "String",
        "desc": "Tooltip displayed when hovering over the custom action icon.",
        "default": "Perform a Custom Action"
      }
    ]
  },
  "CustomJS": {
    "name": "CustomJS",
    "bases": [
      "bokeh.models.callbacks.Callback"
    ],
    "desc": "Execute a JavaScript function.\n\n    .. warning::\n        The explicit purpose of this Bokeh Model is to embed *raw JavaScript\n        code* for a browser to execute. If any part of the code is derived\n        from untrusted user inputs, then you must take appropriate care to\n        sanitize the user input prior to passing to Bokeh.",
    "proto": "{\"args\": {}, \"code\": \"\", \"id\": \"2264\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "code",
        "type": "String",
        "desc": "A snippet of JavaScript code to execute in the browser. The\n    code is made into the body of a function, and all of of the named objects in\n    ``args`` are available as parameters that the code can use. Additionally,\n    a ``cb_obj`` parameter contains the object that triggered the callback\n    and an optional ``cb_data`` parameter that contains any tool-specific data\n    (i.e. mouse coordinates and hovered glyph indices for the ``HoverTool``).",
        "default": ""
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "args",
        "type": "Dict(String, AnyRef)",
        "desc": "A mapping of names to Python objects. In particular those can be bokeh's models.\n    These objects are made available to the callback's code snippet as the values of\n    named parameters to the callback.",
        "default": {}
      }
    ]
  },
  "CustomJSFilter": {
    "name": "CustomJSFilter",
    "bases": [
      "bokeh.models.filters.Filter"
    ],
    "desc": "Filter data sources with a custom defined JavaScript function.\n\n    .. warning::\n        The explicit purpose of this Bokeh Model is to embed *raw JavaScript\n        code* for a browser to execute. If any part of the code is derived\n        from untrusted user inputs, then you must take appropriate care to\n        sanitize the user input prior to passing to Bokeh.",
    "proto": "{\"args\": {}, \"code\": \"\", \"filter\": null, \"id\": \"2272\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "filter",
        "type": "Either(Seq(Int), Seq(Bool))",
        "desc": "A list that can be either integer indices or booleans representing a row-wise subset of data.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "code",
        "type": "String",
        "desc": "A snippet of JavaScript code to filter data contained in a columnar data source.\n    The code is made into the body of a function, and all of of the named objects in\n    ``args`` are available as parameters that the code can use. The variable\n    ``source`` will contain the data source that is associated with the ``CDSView`` this\n    filter is added to.\n\n    The code should either return the indices of the subset or an array of booleans\n    to use to subset data source rows.\n\n    Example:\n\n        .. code-block\n\n            code = '''\n            const indices = []\n            for (var i = 0; i <= source.data['some_column'].length; i++) {\n                if (source.data['some_column'][i] == 'some_value') {\n                    indices.push(i)\n                }\n            }\n            return indices\n            '''",
        "default": ""
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "args",
        "type": "Dict(String, AnyRef)",
        "desc": "A mapping of names to Python objects. In particular those can be bokeh's models.\n    These objects are made available to the callback's code snippet as the values of\n    named parameters to the callback.",
        "default": {}
      }
    ]
  },
  "CustomJSHover": {
    "name": "CustomJSHover",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Define a custom formatter to apply to a hover tool field.\n\n    This model can be configured with JavaScript code to format hover tooltips.\n    The JavaScript code has access to the current value to format, some special\n    variables, and any format configured on the tooltip. The variable ``value``\n    will contain the untransformed value. The variable ``special_vars`` will\n    provide a dict with the following contents:\n\n    * ``x`` data-space x-coordinate of the mouse\n    * ``y`` data-space y-coordinate of the mouse\n    * ``sx`` screen-space x-coordinate of the mouse\n    * ``sy`` screen-space y-coordinate of the mouse\n    * ``data_x`` data-space x-coordinate of the hovered glyph\n    * ``data_y`` data-space y-coordinate of the hovered glyph\n    * ``indices`` column indices of all currently hovered glyphs\n    * ``name`` value of the ``name`` property of the hovered glyph renderer\n\n    If the hover is over a \"multi\" glyph such as ``Patches`` or ``MultiLine``\n    then a ``segment_index`` key will also be present.\n\n    Finally, the value of the format passed in the tooltip specification is\n    available as the ``format`` variable.\n\n    Example:\n\n        As an example, the following code adds a custom formatter to format\n        WebMercator northing coordinates (in meters) as a latitude:\n\n        .. code-block:: python\n\n            lat_custom = CustomJSHover(code=\"\"\"\n                var projections = Bokeh.require(\"core/util/projections\");\n                var x = special_vars.x\n                var y = special_vars.y\n                var coords = projections.wgs84_mercator.inverse([x, y])\n                return \"\" + coords[1]\n            \"\"\")\n\n            p.add_tools(HoverTool(\n                tooltips=[( 'lat','@y{custom}' )],\n                formatters=dict(y=lat_custom)\n            ))\n\n    .. warning::\n        The explicit purpose of this Bokeh Model is to embed *raw JavaScript\n        code* for a browser to execute. If any part of the code is derived\n        from untrusted user inputs, then you must take appropriate care to\n        sanitize the user input prior to passing to Bokeh.",
    "proto": "{\"args\": {}, \"code\": \"\", \"id\": \"2281\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "code",
        "type": "String",
        "desc": "A snippet of JavaScript code to transform a single value. The variable\n    ``value`` will contain the untransformed value and can be expected to be\n    present in the function namespace at render time. Additionally, the\n    variable ``special_vars`` will be available, and will provide a dict\n    with the following contents:\n\n    * ``x`` data-space x-coordinate of the mouse\n    * ``y`` data-space y-coordinate of the mouse\n    * ``sx`` screen-space x-coordinate of the mouse\n    * ``sy`` screen-space y-coordinate of the mouse\n    * ``data_x`` data-space x-coordinate of the hovered glyph\n    * ``data_y`` data-space y-coordinate of the hovered glyph\n    * ``indices`` column indices of all currently hovered glyphs\n\n    If the hover is over a \"multi\" glyph such as ``Patches`` or ``MultiLine``\n    then a ``segment_index`` key will also be present.\n\n    Finally, the value of the format passed in the tooltip specification is\n    available as the ``format`` variable.\n\n    The snippet will be made into the body of a function and therefore requires\n    a return statement.\n\n    Example:\n\n        .. code-block:: javascript\n\n            code = '''\n            return value + \" total\"\n            '''",
        "default": ""
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "args",
        "type": "Dict(String, Instance(Model))",
        "desc": "A mapping of names to Bokeh plot objects. These objects are made available\n    to the callback code snippet as the values of named parameters to the\n    callback.",
        "default": {}
      }
    ]
  },
  "CustomJSTransform": {
    "name": "CustomJSTransform",
    "bases": [
      "bokeh.models.transforms.Transform"
    ],
    "desc": "Apply a custom defined transform to data.\n\n    .. warning::\n        The explicit purpose of this Bokeh Model is to embed *raw JavaScript\n        code* for a browser to execute. If any part of the code is derived\n        from untrusted user inputs, then you must take appropriate care to\n        sanitize the user input prior to passing to Bokeh.",
    "proto": "{\"args\": {}, \"func\": \"\", \"id\": \"2289\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"v_func\": \"\"}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "func",
        "type": "String",
        "desc": "A snippet of JavaScript code to transform a single value. The variable\n    ``x`` will contain the untransformed value and can be expected to be\n    present in the function namespace at render time. The snippet will be\n    into the body of a function and therefore requires a return statement.\n\n    Example:\n\n        .. code-block:: javascript\n\n            func = '''\n            return Math.floor(x) + 0.5\n            '''",
        "default": ""
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "v_func",
        "type": "String",
        "desc": "A snippet of JavaScript code to transform an array of values. The variable\n    ``xs`` will contain the untransformed array and can be expected to be\n    present in the function namespace at render time. The snippet will be\n    into the body of a function and therefore requires a return statement.\n\n    Example:\n\n        .. code-block:: javascript\n\n            v_func = '''\n            var new_xs = new Array(xs.length)\n            for(var i = 0; i < xs.length; i++) {\n                new_xs[i] = xs[i] + 0.5\n            }\n            return new_xs\n            '''\n\n    .. warning::\n        The vectorized function, ``v_func``, must return an array of the\n        same length as the input ``xs`` array.",
        "default": ""
      },
      {
        "name": "args",
        "type": "Dict(String, AnyRef)",
        "desc": "A mapping of names to Python objects. In particular those can be bokeh's models.\n    These objects are made available to the transform' code snippet as the values of\n    named parameters to the callback.",
        "default": {}
      }
    ]
  },
  "Dash": {
    "name": "Dash",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render dash markers. Use ``angle`` to rotate and create vertically\n    oriented short lines.\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Dash.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"2298\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "DataCube": {
    "name": "DataCube",
    "bases": [
      "bokeh.models.widgets.tables.DataTable"
    ],
    "desc": "Specialized DataTable with collapsing groups, totals, and sub-totals.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"columns\": [], \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"editable\": false, \"fit_columns\": true, \"grouping\": [], \"header_row\": true, \"height\": 400, \"height_policy\": \"auto\", \"id\": \"2318\", \"index_header\": \"#\", \"index_position\": 0, \"index_width\": 40, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"reorderable\": true, \"row_height\": 25, \"scroll_to_selection\": true, \"selectable\": true, \"sizing_mode\": null, \"sortable\": true, \"source\": null, \"subscribed_events\": [], \"tags\": [], \"target\": null, \"view\": {\"id\": \"2319\"}, \"visible\": true, \"width\": 600, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "header_row",
        "type": "Bool",
        "desc": "Whether to show a header row with column names at the top of the table.",
        "default": true
      },
      {
        "name": "grouping",
        "type": "List(Instance(GroupingInfo))",
        "desc": "Describe what aggregation operations used to define sub-totals and totals",
        "default": []
      },
      {
        "name": "index_header",
        "type": "String",
        "desc": "The column header to display for the index column, if it is present.",
        "default": "#"
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "source",
        "type": "Instance(DataSource)",
        "desc": "The source of data for the widget.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "editable",
        "type": "Bool",
        "desc": "Allows to edit table's contents. Needs cell editors to be configured on\n    columns that are required to be editable.",
        "default": false
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": 600
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "index_width",
        "type": "Int",
        "desc": "The width of the index column, if present.",
        "default": 40
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": 400
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "index_position",
        "type": "Int",
        "desc": "Where among the list of columns to insert a column displaying the row\n    index. Negative indices are supported, and specify an index position\n    from the end of the list of columns (i.e. standard Python behaviour).\n\n    To prevent the index column from being added, set to None.\n\n    If the absolute value of index_position  is larger than the length of\n    the columns, then the index will appear at the beginning or end, depending\n    on the sign.",
        "default": 0
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "sortable",
        "type": "Bool",
        "desc": "Allows to sort table's contents. By default natural order is preserved.\n    To sort a column, click on it's header. Clicking one more time changes\n    sort direction. Use Ctrl + click to return to natural order. Use\n    Shift + click to sort multiple columns simultaneously.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "reorderable",
        "type": "Bool",
        "desc": "Allows the reordering of a table's columns. To reorder a column,\n    click and drag a table's header to the desired location in the table.\n    The columns on either side will remain in their previous order.",
        "default": true
      },
      {
        "name": "selectable",
        "type": "Either(Bool, Enum('checkbox'))",
        "desc": "Whether a table's rows can be selected or not. Using ``checkbox`` is\n    equivalent  to ``True``, but makes selection visible through a checkbox\n    for each row,  instead of highlighting rows. Multiple selection is\n    allowed and can be achieved by either clicking multiple checkboxes (if\n    enabled) or using Shift + click on rows.",
        "default": true
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "columns",
        "type": "List(Instance(TableColumn))",
        "desc": "The list of child column widgets.",
        "default": []
      },
      {
        "name": "fit_columns",
        "type": "Bool",
        "desc": "Whether columns should be fit to the available width. This results in no\n    horizontal scrollbar showing up, but data can get unreadable if there is\n    no enough space available. If set to ``True``, columns' width is\n    understood as maximum width.",
        "default": true
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "scroll_to_selection",
        "type": "Bool",
        "desc": "Whenever a selection is made on the data source, scroll the selected\n    rows into the table's viewport if none of the selected rows are already\n    in the viewport.",
        "default": true
      },
      {
        "name": "view",
        "type": "Instance(CDSView)",
        "desc": "A view into the data source to use when rendering table rows. A default view\n    of the entire data source is created if a view is not passed in during\n    initialization.",
        "default": null
      },
      {
        "name": "row_height",
        "type": "Int",
        "desc": "The height of each row in pixels.",
        "default": 25
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "target",
        "type": "Instance(DataSource)",
        "desc": "Two column datasource (row_indices & labels) describing which rows of the\n    data cubes are expanded or collapsed",
        "default": null
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      }
    ]
  },
  "DataRange": {
    "name": "DataRange",
    "bases": [
      "bokeh.models.ranges.Range"
    ],
    "desc": "A base class for all data range types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"2398\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"names\": [], \"renderers\": [], \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "names",
        "type": "List(String)",
        "desc": "A list of names to query for. If set, only renderers that\n    have a matching value for their ``name`` attribute will be used\n    for autoranging.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "An explicit list of renderers to autorange against. If unset,\n    defaults to all renderers on a plot.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "DataRange1d": {
    "name": "DataRange1d",
    "bases": [
      "bokeh.models.ranges.DataRange"
    ],
    "desc": "An auto-fitting range in a continuous scalar dimension.\n\n    By default the ``start`` and ``end`` of the range automatically\n    assume min and max values of the data for associated renderers.",
    "proto": "{\"bounds\": null, \"default_span\": 2.0, \"end\": null, \"flipped\": false, \"follow\": null, \"follow_interval\": null, \"id\": \"2406\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_interval\": null, \"min_interval\": null, \"name\": null, \"names\": [], \"only_visible\": false, \"range_padding\": 0.1, \"range_padding_units\": \"percent\", \"renderers\": [], \"start\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "end",
        "type": "Either(Float, Datetime, TimeDelta)",
        "desc": "An explicitly supplied range end. If provided, will override\n    automatically computed end value.",
        "default": null
      },
      {
        "name": "follow",
        "type": "Enum('start', 'end')",
        "desc": "Configure the data to follow one or the other data extreme, with a\n    maximum range size of ``follow_interval``.\n\n    If set to ``\"start\"`` then the range will adjust so that ``start`` always\n    corresponds to the minimum data value (or maximum, if ``flipped`` is\n    ``True``).\n\n    If set to ``\"end\"`` then the range will adjust so that ``end`` always\n    corresponds to the maximum data value (or minimum, if ``flipped`` is\n    ``True``).\n\n    If set to ``None`` (default), then auto-ranging does not follow, and\n    the range will encompass both the minimum and maximum data values.\n\n    ``follow`` cannot be used with bounds, and if set, bounds will be set to\n    ``None``.",
        "default": null
      },
      {
        "name": "range_padding_units",
        "type": "Enum('percent', 'absolute')",
        "desc": "Whether the ``range_padding`` should be interpreted as a percentage, or\n    as an absolute quantity. (default: ``\"percent\"``)",
        "default": "percent"
      },
      {
        "name": "start",
        "type": "Either(Float, Datetime, TimeDelta)",
        "desc": "An explicitly supplied range start. If provided, will override\n    automatically computed start value.",
        "default": null
      },
      {
        "name": "only_visible",
        "type": "Bool",
        "desc": "If True, renderers that that are not visible will be excluded from automatic\n    bounds computations.",
        "default": false
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "min_interval",
        "type": "Either(Float, TimeDelta)",
        "desc": "The level that the range is allowed to zoom in, expressed as the\n    minimum visible interval. If set to ``None`` (default), the minimum\n    interval is not bound.",
        "default": null
      },
      {
        "name": "flipped",
        "type": "Bool",
        "desc": "Whether the range should be \"flipped\" from its normal direction when\n    auto-ranging.",
        "default": false
      },
      {
        "name": "max_interval",
        "type": "Either(Float, TimeDelta)",
        "desc": "The level that the range is allowed to zoom out, expressed as the\n    maximum visible interval. Note that ``bounds`` can impose an\n    implicit constraint on the maximum interval as well.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "default_span",
        "type": "Either(Float, TimeDelta)",
        "desc": "A default width for the interval, in case ``start`` is equal to ``end``\n    (if used with a log axis, default_span is in powers of 10).",
        "default": 2.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "names",
        "type": "List(String)",
        "desc": "A list of names to query for. If set, only renderers that\n    have a matching value for their ``name`` attribute will be used\n    for autoranging.",
        "default": []
      },
      {
        "name": "range_padding",
        "type": "Either(Float, TimeDelta)",
        "desc": "How much padding to add around the computed data bounds.\n\n    When ``range_padding_units`` is set to ``\"percent\"``, the span of the\n    range span is expanded to make the range ``range_padding`` percent larger.\n\n    When ``range_padding_units`` is set to ``\"absolute\"``, the start and end\n    of the range span are extended by the amount ``range_padding``.",
        "default": 0.1
      },
      {
        "name": "follow_interval",
        "type": "Either(Float, TimeDelta)",
        "desc": "If ``follow`` is set to ``\"start\"`` or ``\"end\"`` then the range will\n    always be constrained to that::\n\n         abs(r.start - r.end) <= follow_interval\n\n    is maintained.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "bounds",
        "type": "MinMaxBounds(Auto, Tuple(Float, Float), Tuple(TimeDelta, TimeDelta), Tuple(Datetime, Datetime))",
        "desc": "The bounds that the range is allowed to go to. Typically used to prevent\n    the user from panning/zooming/etc away from the data.\n\n    By default, the bounds will be None, allowing your plot to pan/zoom as far\n    as you want. If bounds are 'auto' they will be computed to be the same as\n    the start and end of the ``DataRange1d``.\n\n    Bounds are provided as a tuple of ``(min, max)`` so regardless of whether\n    your range is increasing or decreasing, the first item should be the\n    minimum value of the range and the second item should be the maximum.\n    Setting ``min > max`` will result in a ``ValueError``.\n\n    If you only want to constrain one end of the plot, you can set ``min`` or\n    ``max`` to ``None`` e.g. ``DataRange1d(bounds=(None, 12))``",
        "default": null
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "An explicit list of renderers to autorange against. If unset,\n    defaults to all renderers on a plot.",
        "default": []
      }
    ]
  },
  "DataRenderer": {
    "name": "DataRenderer",
    "bases": [
      "bokeh.models.renderers.Renderer"
    ],
    "desc": "An abstract base class for data renderer types (e.g. ``GlyphRenderer``, ``TileRenderer``, ``GraphRenderer``).\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"2426\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"glyph\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering glyphs on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "glyph"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering glyphs on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "DataSource": {
    "name": "DataSource",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A base class for data source types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"2436\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"selected\": {\"id\": \"2437\"}, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "selected",
        "type": "Instance(Selection)",
        "desc": "An instance of a ``Selection`` that indicates selected indices on this ``DataSource``.\n    This is a read-only property. You may only change the attributes of this object\n    to change the selection (e.g., ``selected.indices``).",
        "default": "{\"id\": \"2443\"}"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "DataTable": {
    "name": "DataTable",
    "bases": [
      "bokeh.models.widgets.tables.TableWidget"
    ],
    "desc": "Two dimensional grid for visualisation and editing large amounts\n    of data.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"columns\": [], \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"editable\": false, \"fit_columns\": true, \"header_row\": true, \"height\": 400, \"height_policy\": \"auto\", \"id\": \"2445\", \"index_header\": \"#\", \"index_position\": 0, \"index_width\": 40, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"reorderable\": true, \"row_height\": 25, \"scroll_to_selection\": true, \"selectable\": true, \"sizing_mode\": null, \"sortable\": true, \"source\": null, \"subscribed_events\": [], \"tags\": [], \"view\": {\"id\": \"2446\"}, \"visible\": true, \"width\": 600, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "header_row",
        "type": "Bool",
        "desc": "Whether to show a header row with column names at the top of the table.",
        "default": true
      },
      {
        "name": "index_header",
        "type": "String",
        "desc": "The column header to display for the index column, if it is present.",
        "default": "#"
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "source",
        "type": "Instance(DataSource)",
        "desc": "The source of data for the widget.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "editable",
        "type": "Bool",
        "desc": "Allows to edit table's contents. Needs cell editors to be configured on\n    columns that are required to be editable.",
        "default": false
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": 600
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "index_width",
        "type": "Int",
        "desc": "The width of the index column, if present.",
        "default": 40
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": 400
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "index_position",
        "type": "Int",
        "desc": "Where among the list of columns to insert a column displaying the row\n    index. Negative indices are supported, and specify an index position\n    from the end of the list of columns (i.e. standard Python behaviour).\n\n    To prevent the index column from being added, set to None.\n\n    If the absolute value of index_position  is larger than the length of\n    the columns, then the index will appear at the beginning or end, depending\n    on the sign.",
        "default": 0
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "sortable",
        "type": "Bool",
        "desc": "Allows to sort table's contents. By default natural order is preserved.\n    To sort a column, click on it's header. Clicking one more time changes\n    sort direction. Use Ctrl + click to return to natural order. Use\n    Shift + click to sort multiple columns simultaneously.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "reorderable",
        "type": "Bool",
        "desc": "Allows the reordering of a table's columns. To reorder a column,\n    click and drag a table's header to the desired location in the table.\n    The columns on either side will remain in their previous order.",
        "default": true
      },
      {
        "name": "selectable",
        "type": "Either(Bool, Enum('checkbox'))",
        "desc": "Whether a table's rows can be selected or not. Using ``checkbox`` is\n    equivalent  to ``True``, but makes selection visible through a checkbox\n    for each row,  instead of highlighting rows. Multiple selection is\n    allowed and can be achieved by either clicking multiple checkboxes (if\n    enabled) or using Shift + click on rows.",
        "default": true
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "columns",
        "type": "List(Instance(TableColumn))",
        "desc": "The list of child column widgets.",
        "default": []
      },
      {
        "name": "fit_columns",
        "type": "Bool",
        "desc": "Whether columns should be fit to the available width. This results in no\n    horizontal scrollbar showing up, but data can get unreadable if there is\n    no enough space available. If set to ``True``, columns' width is\n    understood as maximum width.",
        "default": true
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "scroll_to_selection",
        "type": "Bool",
        "desc": "Whenever a selection is made on the data source, scroll the selected\n    rows into the table's viewport if none of the selected rows are already\n    in the viewport.",
        "default": true
      },
      {
        "name": "view",
        "type": "Instance(CDSView)",
        "desc": "A view into the data source to use when rendering table rows. A default view\n    of the entire data source is created if a view is not passed in during\n    initialization.",
        "default": null
      },
      {
        "name": "row_height",
        "type": "Int",
        "desc": "The height of each row in pixels.",
        "default": 25
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      }
    ]
  },
  "DateEditor": {
    "name": "DateEditor",
    "bases": [
      "bokeh.models.widgets.tables.CellEditor"
    ],
    "desc": "Calendar-based date cell editor.",
    "proto": "{\"id\": \"2521\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "DateFormatter": {
    "name": "DateFormatter",
    "bases": [
      "bokeh.models.widgets.tables.CellFormatter"
    ],
    "desc": "Date cell formatter.",
    "proto": "{\"format\": \"ISO-8601\", \"id\": \"2527\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "format",
        "type": "Either(Enum('ATOM', 'W3C', 'RFC-3339', 'ISO-8601', 'COOKIE', 'RFC-822', 'RFC-850', 'RFC-1036', 'RFC-1123', 'RFC-2822', 'RSS', 'TIMESTAMP'), String)",
        "desc": "The date format can be any standard  `strftime`_ format string, as well\n    as any of the following predefined format names:\n\n    ================================================ ================== ===================\n    Format name(s)                                   Format string      Example Output\n    ================================================ ================== ===================\n    ``ATOM`` / ``W3C`` / ``RFC-3339`` / ``ISO-8601`` ``\"%Y-%m-%d\"``     2014-03-01\n    ``COOKIE``                                       ``\"%a, %d %b %Y\"`` Sat, 01 Mar 2014\n    ``RFC-850``                                      ``\"%A, %d-%b-%y\"`` Saturday, 01-Mar-14\n    ``RFC-1123`` / ``RFC-2822``                      ``\"%a, %e %b %Y\"`` Sat, 1 Mar 2014\n    ``RSS`` / ``RFC-822`` / ``RFC-1036``             ``\"%a, %e %b %y\"`` Sat, 1 Mar 14\n    ``TIMESTAMP``                                    (ms since epoch)   1393632000000\n    ================================================ ================== ===================\n\n    Note that in the table some of the format names are synonymous, with\n    identical format names separated by slashes.\n\n    This list of supported `strftime`_ format codes is reproduced below.\n\n    %a\n        The abbreviated name of the day of the week according to the\n        current locale.\n\n    %A\n        The full name of the day of the week according to the current\n        locale.\n\n    %b\n        The abbreviated month name according to the current locale.\n\n    %B\n        The full month name according to the current locale.\n\n    %c\n        The preferred date and time representation for the current\n        locale.\n\n    %C\n        The century number (year/100) as a 2-digit integer.\n\n    %d\n        The day of the month as a decimal number (range 01 to 31).\n\n    %D\n        Equivalent to %m/%d/%y.  (Americans should note that in many\n        other countries %d/%m/%y is rather common. This means that in\n        international context this format is ambiguous and should not\n        be used.)\n\n    %e\n        Like %d, the day of the month as a decimal number, but a\n        leading zero is replaced by a space.\n\n    %f\n        Microsecond as a decimal number, zero-padded on the left (range\n        000000-999999). This is an extension to the set of directives\n        available to `timezone`_.\n\n    %F\n        Equivalent to %Y-%m-%d (the ISO 8601 date format).\n\n    %G\n        The ISO 8601 week-based year with century as a decimal number.\n        The 4-digit year corresponding to the ISO week number (see %V).\n        This has the same format and value as %Y, except that if the\n        ISO week number belongs to the previous or next year, that year\n        is used instead.\n\n    %g\n        Like %G, but without century, that is, with a 2-digit year (00-99).\n\n    %h\n        Equivalent to %b.\n\n    %H\n        The hour as a decimal number using a 24-hour clock (range 00\n        to 23).\n\n    %I\n        The hour as a decimal number using a 12-hour clock (range 01\n        to 12).\n\n    %j\n        The day of the year as a decimal number (range 001 to 366).\n\n    %k\n        The hour (24-hour clock) as a decimal number (range 0 to 23).\n        Single digits are preceded by a blank.  (See also %H.)\n\n    %l\n        The hour (12-hour clock) as a decimal number (range 1 to 12).\n        Single digits are preceded by a blank.  (See also %I.)  (TZ)\n\n    %m\n        The month as a decimal number (range 01 to 12).\n\n    %M\n        The minute as a decimal number (range 00 to 59).\n\n    %n\n        A newline character. Bokeh text does not currently support\n        newline characters.\n\n    %N\n        Nanosecond as a decimal number, zero-padded on the left (range\n        000000000-999999999). Supports a padding width specifier, i.e.\n        %3N displays 3 leftmost digits. However, this is only accurate\n        to the millisecond level of precision due to limitations of\n        `timezone`_.\n\n    %p\n        Either \"AM\" or \"PM\" according to the given time value, or the\n        corresponding strings for the current locale.  Noon is treated\n        as \"PM\" and midnight as \"AM\".\n\n    %P\n        Like %p but in lowercase: \"am\" or \"pm\" or a corresponding\n        string for the current locale.\n\n    %r\n        The time in a.m. or p.m. notation.  In the POSIX locale this\n        is equivalent to %I:%M:%S %p.\n\n    %R\n        The time in 24-hour notation (%H:%M). For a version including\n        the seconds, see %T below.\n\n    %s\n        The number of seconds since the Epoch, 1970-01-01 00:00:00\n        +0000 (UTC).\n\n    %S\n        The second as a decimal number (range 00 to 60).  (The range\n        is up to 60 to allow for occasional leap seconds.)\n\n    %t\n        A tab character. Bokeh text does not currently support tab\n        characters.\n\n    %T\n        The time in 24-hour notation (%H:%M:%S).\n\n    %u\n        The day of the week as a decimal, range 1 to 7, Monday being 1.\n        See also %w.\n\n    %U\n        The week number of the current year as a decimal number, range\n        00 to 53, starting with the first Sunday as the first day of\n        week 01.  See also %V and %W.\n\n    %V\n        The ISO 8601 week number (see NOTES) of the current year as a\n        decimal number, range 01 to 53, where week 1 is the first week\n        that has at least 4 days in the new year.  See also %U and %W.\n\n    %w\n        The day of the week as a decimal, range 0 to 6, Sunday being 0.\n        See also %u.\n\n    %W\n        The week number of the current year as a decimal number, range\n        00 to 53, starting with the first Monday as the first day of\n        week 01.\n\n    %x\n        The preferred date representation for the current locale\n        without the time.\n\n    %X\n        The preferred time representation for the current locale\n        without the date.\n\n    %y\n        The year as a decimal number without a century (range 00 to 99).\n\n    %Y\n        The year as a decimal number including the century.\n\n    %z\n        The +hhmm or -hhmm numeric timezone (that is, the hour and\n        minute offset from UTC).\n\n    %Z\n        The timezone name or abbreviation.\n\n    %%\n        A literal '%' character.\n\n    .. warning::\n        The client library BokehJS uses the `timezone`_ library to\n        format datetimes. The inclusion of the list below is based on the\n        claim that `timezone`_ makes to support \"the full compliment\n        of GNU date format specifiers.\" However, this claim has not\n        been tested exhaustively against this list. If you find formats\n        that do not function as expected, please submit a `github issue`_,\n        so that the documentation can be updated appropriately.\n\n    .. _strftime: http://man7.org/linux/man-pages/man3/strftime.3.html\n    .. _timezone: http://bigeasy.github.io/timezone/\n    .. _github issue: https://github.com/bokeh/bokeh/issues",
        "default": "ISO-8601"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "DatePicker": {
    "name": "DatePicker",
    "bases": [
      "bokeh.models.widgets.inputs.InputWidget"
    ],
    "desc": "Calendar-based date picker widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"disabled_dates\": [], \"enabled_dates\": [], \"height\": null, \"height_policy\": \"auto\", \"id\": \"2534\", \"inline\": false, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_date\": null, \"max_height\": null, \"max_width\": null, \"min_date\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"position\": \"auto\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"value\": null, \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "disabled_dates",
        "type": "List(Either(Date, Tuple(Date, Date)))",
        "desc": "A list of dates of ``(start, end)`` date ranges to make unavailable for\n    selection. All other dates will be avalable.\n\n    .. note::\n        Only one of ``disabled_dates`` and ``enabled_dates`` should be specified.",
        "default": []
      },
      {
        "name": "min_date",
        "type": "Date",
        "desc": "Optional earliest allowable date.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "enabled_dates",
        "type": "List(Either(Date, Tuple(Date, Date)))",
        "desc": "A list of dates of ``(start, end)`` date ranges to make available for\n    selection. All other dates will be unavailable.\n\n    .. note::\n        Only one of ``disabled_dates`` and ``enabled_dates`` should be specified.",
        "default": []
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "inline",
        "type": "Bool",
        "desc": "Whether the calendar sholud be displayed inline.",
        "default": false
      },
      {
        "name": "max_date",
        "type": "Date",
        "desc": "Optional latest allowable date.",
        "default": null
      },
      {
        "name": "value",
        "type": "Date",
        "desc": "The initial or picked date.",
        "default": null
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "position",
        "type": "Enum('auto', 'above', 'below')",
        "desc": "Where the calendar is rendered relative to the input when ``inline`` is False.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "DateRangeSlider": {
    "name": "DateRangeSlider",
    "bases": [
      "bokeh.models.widgets.sliders.AbstractSlider"
    ],
    "desc": "Slider-based date range selection widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"bar_color\": \"#e6e6e6\", \"css_classes\": [], \"default_size\": 300, \"direction\": \"ltr\", \"disabled\": false, \"end\": null, \"format\": \"%d %b %Y\", \"height\": null, \"height_policy\": \"auto\", \"id\": \"2566\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"show_value\": true, \"sizing_mode\": null, \"start\": null, \"step\": 1, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"tooltips\": true, \"value\": null, \"value_throttled\": null, \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "end",
        "type": "Datetime",
        "desc": "The maximum allowable value.",
        "default": null
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "tooltips",
        "type": "Bool",
        "desc": "",
        "default": true
      },
      {
        "name": "start",
        "type": "Datetime",
        "desc": "The minimum allowable value.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Slider's label.",
        "default": ""
      },
      {
        "name": "step",
        "type": "Int",
        "desc": "The step between consecutive values.",
        "default": 1
      },
      {
        "name": "format",
        "type": "Either(String, Instance(TickFormatter))",
        "desc": "",
        "default": "%d %b %Y"
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "direction",
        "type": "Enum('ltr', 'rtl')",
        "desc": "",
        "default": "ltr"
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "bar_color",
        "type": "Color",
        "desc": "",
        "default": "#e6e6e6"
      },
      {
        "name": "value",
        "type": "Tuple(Datetime, Datetime)",
        "desc": "Initial or selected range.",
        "default": null
      },
      {
        "name": "show_value",
        "type": "Bool",
        "desc": "Whether or not show slider's value.",
        "default": true
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "value_throttled",
        "type": "Tuple(Datetime, Datetime)",
        "desc": "Initial or selected value, throttled to report only on mouseup.",
        "default": null
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "DateSlider": {
    "name": "DateSlider",
    "bases": [
      "bokeh.models.widgets.sliders.AbstractSlider"
    ],
    "desc": "Slider-based date selection widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"bar_color\": \"#e6e6e6\", \"css_classes\": [], \"default_size\": 300, \"direction\": \"ltr\", \"disabled\": false, \"end\": null, \"format\": \"%d %b %Y\", \"height\": null, \"height_policy\": \"auto\", \"id\": \"2601\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"show_value\": true, \"sizing_mode\": null, \"start\": null, \"step\": 1, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"tooltips\": true, \"value\": null, \"value_throttled\": null, \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "end",
        "type": "Datetime",
        "desc": "The maximum allowable value.",
        "default": null
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "tooltips",
        "type": "Bool",
        "desc": "",
        "default": true
      },
      {
        "name": "start",
        "type": "Datetime",
        "desc": "The minimum allowable value.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Slider's label.",
        "default": ""
      },
      {
        "name": "step",
        "type": "Int",
        "desc": "The step between consecutive values.",
        "default": 1
      },
      {
        "name": "format",
        "type": "Either(String, Instance(TickFormatter))",
        "desc": "",
        "default": "%d %b %Y"
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "direction",
        "type": "Enum('ltr', 'rtl')",
        "desc": "",
        "default": "ltr"
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "bar_color",
        "type": "Color",
        "desc": "",
        "default": "#e6e6e6"
      },
      {
        "name": "value",
        "type": "Datetime",
        "desc": "Initial or selected value.",
        "default": null
      },
      {
        "name": "show_value",
        "type": "Bool",
        "desc": "Whether or not show slider's value.",
        "default": true
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "value_throttled",
        "type": "Datetime",
        "desc": "Initial or selected value, throttled to report only on mouseup.",
        "default": null
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "DatetimeAxis": {
    "name": "DatetimeAxis",
    "bases": [
      "bokeh.models.axes.LinearAxis"
    ],
    "desc": "A ``LinearAxis`` that picks nice numbers for tick locations on\n    a datetime scale. Configured with a ``DatetimeTickFormatter`` by\n    default.",
    "proto": "{\"axis_label\": \"\", \"axis_label_standoff\": 5, \"axis_label_text_align\": \"left\", \"axis_label_text_alpha\": 1.0, \"axis_label_text_baseline\": \"bottom\", \"axis_label_text_color\": \"#444444\", \"axis_label_text_font\": \"helvetica\", \"axis_label_text_font_size\": \"13px\", \"axis_label_text_font_style\": \"italic\", \"axis_label_text_line_height\": 1.2, \"axis_line_alpha\": 1.0, \"axis_line_cap\": \"butt\", \"axis_line_color\": \"black\", \"axis_line_dash\": [], \"axis_line_dash_offset\": 0, \"axis_line_join\": \"bevel\", \"axis_line_width\": 1, \"bounds\": \"auto\", \"fixed_location\": null, \"formatter\": {\"id\": \"2637\"}, \"id\": \"2636\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"guide\", \"major_label_orientation\": \"horizontal\", \"major_label_overrides\": {}, \"major_label_standoff\": 5, \"major_label_text_align\": \"center\", \"major_label_text_alpha\": 1.0, \"major_label_text_baseline\": \"alphabetic\", \"major_label_text_color\": \"#444444\", \"major_label_text_font\": \"helvetica\", \"major_label_text_font_size\": \"11px\", \"major_label_text_font_style\": \"normal\", \"major_label_text_line_height\": 1.2, \"major_tick_in\": 2, \"major_tick_line_alpha\": 1.0, \"major_tick_line_cap\": \"butt\", \"major_tick_line_color\": \"black\", \"major_tick_line_dash\": [], \"major_tick_line_dash_offset\": 0, \"major_tick_line_join\": \"bevel\", \"major_tick_line_width\": 1, \"major_tick_out\": 6, \"minor_tick_in\": 0, \"minor_tick_line_alpha\": 1.0, \"minor_tick_line_cap\": \"butt\", \"minor_tick_line_color\": \"black\", \"minor_tick_line_dash\": [], \"minor_tick_line_dash_offset\": 0, \"minor_tick_line_join\": \"bevel\", \"minor_tick_line_width\": 1, \"minor_tick_out\": 4, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"ticker\": {\"id\": \"2638\"}, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "axis_line_width",
        "type": "Float",
        "desc": "The line width of the axis line.",
        "default": 1
      },
      {
        "name": "major_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the major tick labels should be\n    offset from the associated ticks.",
        "default": 5
      },
      {
        "name": "axis_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the axis line.",
        "default": []
      },
      {
        "name": "major_tick_line_width",
        "type": "Float",
        "desc": "The line width of the major ticks.",
        "default": 1
      },
      {
        "name": "axis_line_color",
        "type": "Color",
        "desc": "The line color of the axis line.",
        "default": "black"
      },
      {
        "name": "axis_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the axis label.",
        "default": "italic"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default x-range.",
        "default": "default"
      },
      {
        "name": "axis_label",
        "type": "String",
        "desc": "A text label for the axis, displayed parallel to the axis rule.\n\n    .. note::\n        LaTeX notation is not currently supported; please see\n        :bokeh-issue:`647` to track progress or contribute.",
        "default": ""
      },
      {
        "name": "major_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the major ticks.",
        "default": 0
      },
      {
        "name": "minor_tick_line_width",
        "type": "Float",
        "desc": "The line width of the minor ticks.",
        "default": 1
      },
      {
        "name": "minor_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that minor ticks should extend into the\n    main plot area.",
        "default": 0
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "major_label_overrides",
        "type": "Dict(Either(Float, String), String)",
        "desc": "Provide explicit tick label values for specific tick locations that\n    override normal formatting.",
        "default": {}
      },
      {
        "name": "major_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the major tick labels.",
        "default": "center"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default y-range.",
        "default": "default"
      },
      {
        "name": "formatter",
        "type": "Instance(TickFormatter)",
        "desc": "A ``TickFormatter`` to use for formatting the visual appearance\n    of ticks.",
        "default": "{\"id\": \"2656\"}"
      },
      {
        "name": "major_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the major tick labels.",
        "default": "normal"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "ticker",
        "type": "Instance(Ticker)",
        "desc": "A Ticker to use for computing locations of axis components.\n\n    The property may also be passed a sequence of floating point numbers as\n    a shorthand for creating and configuring a ``FixedTicker``, e.g. the\n    following code\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n\n        p = figure()\n        p.xaxis.ticker = [10, 20, 37.4]\n\n    is equivalent to:\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n        from bokeh.models import FixedTicker\n\n        p = figure()\n        p.xaxis.ticker = FixedTicker(ticks=[10, 20, 37.4])",
        "default": "{\"id\": \"2660\"}"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "axis_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the axis labels should be offset\n    from the tick labels.",
        "default": 5
      },
      {
        "name": "major_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the major tick labels.",
        "default": "alphabetic"
      },
      {
        "name": "axis_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the axis label.",
        "default": 1.2
      },
      {
        "name": "axis_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the axis line.",
        "default": 0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "major_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the major ticks.",
        "default": 1.0
      },
      {
        "name": "major_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend into the\n    main plot area.",
        "default": 2
      },
      {
        "name": "minor_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the minor ticks.",
        "default": []
      },
      {
        "name": "major_label_text_font",
        "type": "String",
        "desc": "The text font of the major tick labels.",
        "default": "helvetica"
      },
      {
        "name": "minor_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the minor ticks.",
        "default": 1.0
      },
      {
        "name": "major_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the major tick labels.",
        "default": "11px"
      },
      {
        "name": "minor_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the minor ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the axis label.",
        "default": "left"
      },
      {
        "name": "major_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the major ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 4
      },
      {
        "name": "axis_label_text_color",
        "type": "Color",
        "desc": "The text color of the axis label.",
        "default": "#444444"
      },
      {
        "name": "fixed_location",
        "type": "Either(Float, String, Tuple(String, String), Tuple(String, String, String))",
        "desc": "Set to specify a fixed coordinate location to draw the axis. The direction\n    of ticks and major labels is determined by the side panel that the axis\n    belongs to.\n\n    .. note::\n        Axes labels are suppressed when axes are positioned at fixed locations\n        inside the central plot area.",
        "default": null
      },
      {
        "name": "major_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the major ticks.",
        "default": []
      },
      {
        "name": "major_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the major tick labels.",
        "default": 1.2
      },
      {
        "name": "minor_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the minor ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_line_color",
        "type": "Color",
        "desc": "The line color of the minor ticks.",
        "default": "black"
      },
      {
        "name": "axis_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the axis line.",
        "default": "bevel"
      },
      {
        "name": "major_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 6
      },
      {
        "name": "axis_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the axis label.",
        "default": "13px"
      },
      {
        "name": "axis_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the axis line.",
        "default": 1.0
      },
      {
        "name": "major_label_orientation",
        "type": "Either(Enum('horizontal', 'vertical'), Float)",
        "desc": "What direction the major label text should be oriented. If a\n    number is supplied, the angle of the text is measured from horizontal.",
        "default": "horizontal"
      },
      {
        "name": "minor_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the minor ticks.",
        "default": 0
      },
      {
        "name": "major_tick_line_color",
        "type": "Color",
        "desc": "The line color of the major ticks.",
        "default": "black"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "major_label_text_color",
        "type": "Color",
        "desc": "The text color of the major tick labels.",
        "default": "#444444"
      },
      {
        "name": "axis_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the axis line.",
        "default": "butt"
      },
      {
        "name": "major_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the major ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_font",
        "type": "String",
        "desc": "The text font of the axis label.",
        "default": "helvetica"
      },
      {
        "name": "axis_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the axis label.",
        "default": "bottom"
      },
      {
        "name": "axis_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the axis label.",
        "default": 1.0
      },
      {
        "name": "major_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the major tick labels.",
        "default": 1.0
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "guide"
      },
      {
        "name": "bounds",
        "type": "Either(Auto, Tuple(Float, Float), Tuple(Datetime, Datetime))",
        "desc": "Bounds for the rendered axis. If unset, the axis will span the\n    entire plot in the given dimension.",
        "default": "auto"
      }
    ]
  },
  "DatetimeTickFormatter": {
    "name": "DatetimeTickFormatter",
    "bases": [
      "bokeh.models.formatters.TickFormatter"
    ],
    "desc": "A ``TickFormatter`` for displaying datetime values nicely across a\n    range of scales.\n\n    ``DatetimeTickFormatter`` has the following properties (listed together\n    with their default values) that can be used to control the formatting\n    of axis ticks at different scales scales:\n\n    .. code-block:: python\n\n        microseconds = ['%fus']\n\n        milliseconds = ['%3Nms', '%S.%3Ns']\n\n        seconds = ['%Ss']\n\n        minsec = [':%M:%S']\n\n        minutes = [':%M', '%Mm']\n\n        hourmin = ['%H:%M']\n\n        hours = ['%Hh', '%H:%M']\n\n        days = ['%m/%d', '%a%d']\n\n        months = ['%m/%Y', '%b %Y']\n\n        years = ['%Y']\n\n    Each scale property can be set to format or list of formats to use for\n    formatting datetime tick values that fall in in that \"time scale\".\n    By default, only the first format string passed for each time scale\n    will be used. By default, all leading zeros are stripped away from\n    the formatted labels.\n\n    This list of supported `strftime`_ formats is reproduced below.\n\n    %a\n        The abbreviated name of the day of the week according to the\n        current locale.\n\n    %A\n        The full name of the day of the week according to the current\n        locale.\n\n    %b\n        The abbreviated month name according to the current locale.\n\n    %B\n        The full month name according to the current locale.\n\n    %c\n        The preferred date and time representation for the current\n        locale.\n\n    %C\n        The century number (year/100) as a 2-digit integer.\n\n    %d\n        The day of the month as a decimal number (range 01 to 31).\n\n    %D\n        Equivalent to %m/%d/%y.  (Americans should note that in many\n        other countries %d/%m/%y is rather common. This means that in\n        international context this format is ambiguous and should not\n        be used.)\n\n    %e\n        Like %d, the day of the month as a decimal number, but a\n        leading zero is replaced by a space.\n\n    %f\n        Microsecond as a decimal number, zero-padded on the left (range\n        000000-999999). This is an extension to the set of directives\n        available to `timezone`_.\n\n    %F\n        Equivalent to %Y-%m-%d (the ISO 8601 date format).\n\n    %G\n        The ISO 8601 week-based year with century as a decimal number.\n        The 4-digit year corresponding to the ISO week number (see %V).\n        This has the same format and value as %Y, except that if the\n        ISO week number belongs to the previous or next year, that year\n        is used instead.\n\n    %g\n        Like %G, but without century, that is, with a 2-digit year (00-99).\n\n    %h\n        Equivalent to %b.\n\n    %H\n        The hour as a decimal number using a 24-hour clock (range 00\n        to 23).\n\n    %I\n        The hour as a decimal number using a 12-hour clock (range 01\n        to 12).\n\n    %j\n        The day of the year as a decimal number (range 001 to 366).\n\n    %k\n        The hour (24-hour clock) as a decimal number (range 0 to 23).\n        Single digits are preceded by a blank.  (See also %H.)\n\n    %l\n        The hour (12-hour clock) as a decimal number (range 1 to 12).\n        Single digits are preceded by a blank.  (See also %I.)  (TZ)\n\n    %m\n        The month as a decimal number (range 01 to 12).\n\n    %M\n        The minute as a decimal number (range 00 to 59).\n\n    %n\n        A newline character. Bokeh text does not currently support\n        newline characters.\n\n    %N\n        Nanosecond as a decimal number, zero-padded on the left (range\n        000000000-999999999). Supports a padding width specifier, i.e.\n        %3N displays 3 leftmost digits. However, this is only accurate\n        to the millisecond level of precision due to limitations of\n        `timezone`_.\n\n    %p\n        Either \"AM\" or \"PM\" according to the given time value, or the\n        corresponding strings for the current locale.  Noon is treated\n        as \"PM\" and midnight as \"AM\".\n\n    %P\n        Like %p but in lowercase: \"am\" or \"pm\" or a corresponding\n        string for the current locale.\n\n    %r\n        The time in a.m. or p.m. notation.  In the POSIX locale this\n        is equivalent to %I:%M:%S %p.\n\n    %R\n        The time in 24-hour notation (%H:%M). For a version including\n        the seconds, see %T below.\n\n    %s\n        The number of seconds since the Epoch, 1970-01-01 00:00:00\n        +0000 (UTC).\n\n    %S\n        The second as a decimal number (range 00 to 60).  (The range\n        is up to 60 to allow for occasional leap seconds.)\n\n    %t\n        A tab character. Bokeh text does not currently support tab\n        characters.\n\n    %T\n        The time in 24-hour notation (%H:%M:%S).\n\n    %u\n        The day of the week as a decimal, range 1 to 7, Monday being 1.\n        See also %w.\n\n    %U\n        The week number of the current year as a decimal number, range\n        00 to 53, starting with the first Sunday as the first day of\n        week 01.  See also %V and %W.\n\n    %V\n        The ISO 8601 week number (see NOTES) of the current year as a\n        decimal number, range 01 to 53, where week 1 is the first week\n        that has at least 4 days in the new year.  See also %U and %W.\n\n    %w\n        The day of the week as a decimal, range 0 to 6, Sunday being 0.\n        See also %u.\n\n    %W\n        The week number of the current year as a decimal number, range\n        00 to 53, starting with the first Monday as the first day of\n        week 01.\n\n    %x\n        The preferred date representation for the current locale\n        without the time.\n\n    %X\n        The preferred time representation for the current locale\n        without the date.\n\n    %y\n        The year as a decimal number without a century (range 00 to 99).\n\n    %Y\n        The year as a decimal number including the century.\n\n    %z\n        The +hhmm or -hhmm numeric timezone (that is, the hour and\n        minute offset from UTC).\n\n    %Z\n        The timezone name or abbreviation.\n\n    %%\n        A literal '%' character.\n\n    .. warning::\n        The client library BokehJS uses the `timezone`_ library to\n        format datetimes. The inclusion of the list below is based on the\n        claim that `timezone`_ makes to support \"the full compliment\n        of GNU date format specifiers.\" However, this claim has not\n        been tested exhaustively against this list. If you find formats\n        that do not function as expected, please submit a `github issue`_,\n        so that the documentation can be updated appropriately.\n\n    .. _strftime: http://man7.org/linux/man-pages/man3/strftime.3.html\n    .. _timezone: http://bigeasy.github.io/timezone/\n    .. _github issue: https://github.com/bokeh/bokeh/issues",
    "proto": "{\"days\": [\"%m/%d\", \"%a%d\"], \"hourmin\": [\"%H:%M\"], \"hours\": [\"%Hh\", \"%H:%M\"], \"id\": \"2700\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"microseconds\": [\"%fus\"], \"milliseconds\": [\"%3Nms\", \"%S.%3Ns\"], \"minsec\": [\":%M:%S\"], \"minutes\": [\":%M\", \"%Mm\"], \"months\": [\"%m/%Y\", \"%b %Y\"], \"name\": null, \"seconds\": [\"%Ss\"], \"subscribed_events\": [], \"tags\": [], \"years\": [\"%Y\"]}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "milliseconds",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``milliseconds`` range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          "%3Nms",
          "%S.%3Ns"
        ]
      },
      {
        "name": "months",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``months`` range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          "%m/%Y",
          "%b %Y"
        ]
      },
      {
        "name": "minsec",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``minsec`` (for combined minutes and seconds) range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          ":%M:%S"
        ]
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "years",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``years`` range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          "%Y"
        ]
      },
      {
        "name": "seconds",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``seconds`` range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          "%Ss"
        ]
      },
      {
        "name": "microseconds",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``microseconds`` range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          "%fus"
        ]
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "hourmin",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``hourmin`` (for combined hours and minutes) range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          "%H:%M"
        ]
      },
      {
        "name": "minutes",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``minutes`` range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          ":%M",
          "%Mm"
        ]
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "hours",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``hours`` range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          "%Hh",
          "%H:%M"
        ]
      },
      {
        "name": "days",
        "type": "List(String)",
        "desc": "Formats for displaying datetime values in the ``days`` range.\n\n    See the :class:`~bokeh.models.formatters.DatetimeTickFormatter` help for a list of all supported formats.",
        "default": [
          "%m/%d",
          "%a%d"
        ]
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "DatetimeTicker": {
    "name": "DatetimeTicker",
    "bases": [
      "bokeh.models.tickers.CompositeTicker"
    ],
    "desc": "Generate nice ticks across different date and time scales.",
    "proto": "{\"desired_num_ticks\": 6, \"id\": \"2716\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_minor_ticks\": 0, \"subscribed_events\": [], \"tags\": [], \"tickers\": [{\"id\": \"2717\"}, {\"id\": \"2718\"}, {\"id\": \"2719\"}, {\"id\": \"2720\"}, {\"id\": \"2721\"}, {\"id\": \"2722\"}, {\"id\": \"2723\"}, {\"id\": \"2724\"}, {\"id\": \"2725\"}, {\"id\": \"2726\"}, {\"id\": \"2727\"}, {\"id\": \"2728\"}]}",
    "props": [
      {
        "name": "tickers",
        "type": "Seq(Instance(Ticker))",
        "desc": "A list of Ticker objects to combine at different scales in order\n    to generate tick values. The supplied tickers should be in order.\n    Specifically, if S comes before T, then it should be the case that::\n\n        S.get_max_interval() < T.get_min_interval()",
        "default": [
          "{\"id\": \"2730\", \"mantissas\": [1, 2, 5], \"max_interval\": 500.0, \"num_minor_ticks\": 0}",
          "{\"base\": 60, \"id\": \"2731\", \"mantissas\": [1, 2, 5, 10, 15, 20, 30], \"max_interval\": 1800000.0, \"min_interval\": 1000.0, \"num_minor_ticks\": 0}",
          "{\"base\": 24, \"id\": \"2732\", \"mantissas\": [1, 2, 4, 6, 8, 12], \"max_interval\": 43200000.0, \"min_interval\": 3600000.0, \"num_minor_ticks\": 0}",
          "{\"days\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31], \"id\": \"2733\"}",
          "{\"days\": [1, 4, 7, 10, 13, 16, 19, 22, 25, 28], \"id\": \"2734\"}",
          "{\"days\": [1, 8, 15, 22], \"id\": \"2735\"}",
          "{\"days\": [1, 15], \"id\": \"2736\"}",
          "{\"id\": \"2737\", \"months\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]}",
          "{\"id\": \"2738\", \"months\": [0, 2, 4, 6, 8, 10]}",
          "{\"id\": \"2739\", \"months\": [0, 4, 8]}",
          "{\"id\": \"2740\", \"months\": [0, 6]}",
          "{\"id\": \"2741\"}"
        ]
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 0
      }
    ]
  },
  "DaysTicker": {
    "name": "DaysTicker",
    "bases": [
      "bokeh.models.tickers.SingleIntervalTicker"
    ],
    "desc": "Generate ticks spaced apart by specific, even multiples of days.",
    "proto": "{\"days\": [], \"desired_num_ticks\": 6, \"id\": \"2749\", \"interval\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_minor_ticks\": 0, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "interval",
        "type": "Float",
        "desc": "The interval between adjacent ticks.",
        "default": null
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "days",
        "type": "Seq(Int)",
        "desc": "The intervals of days to use.",
        "default": []
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 0
      }
    ]
  },
  "Diamond": {
    "name": "Diamond",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render diamond markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Diamond.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"2759\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "DiamondCross": {
    "name": "DiamondCross",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render diamond markers with a '+' cross through the center. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/DiamondCross.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"2779\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "DiamondDot": {
    "name": "DiamondDot",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render diamond markers with center dots. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/DiamondDot.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"2799\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "Div": {
    "name": "Div",
    "bases": [
      "bokeh.models.widgets.markups.Markup"
    ],
    "desc": "A block (div) of text.\n\n    This Bokeh model corresponds to an HTML ``<div>`` element.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../sphinx/source/docs/user_guide/examples/interaction_div.py\n        :source-position: below",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"2819\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"render_as_text\": false, \"sizing_mode\": null, \"style\": {}, \"subscribed_events\": [], \"tags\": [], \"text\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "render_as_text",
        "type": "Bool",
        "desc": "Whether the contents should be rendered as raw text or as interpreted HTML.\n    The default value is ``False``, meaning contents are rendered as HTML.",
        "default": false
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "style",
        "type": "Dict(String, Any)",
        "desc": "Raw CSS style declaration. Note this may be web browser dependent.",
        "default": {}
      },
      {
        "name": "text",
        "type": "String",
        "desc": "The text or HTML contents of the widget.\n\n    .. note::\n        If the HTML content contains elements which size depends on\n        on external, asynchronously loaded resources, the size of\n        the widget may be computed incorrectly. This is in particular\n        an issue with images (``<img>``). To remedy this problem, one\n        either has to set explicit dimensions using CSS properties,\n        HTML attributes or model's ``width`` and ``height`` properties,\n        or inline images' contents using data URIs.",
        "default": ""
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Dodge": {
    "name": "Dodge",
    "bases": [
      "bokeh.models.transforms.Transform"
    ],
    "desc": "Apply either fixed dodge amount to data.",
    "proto": "{\"id\": \"2846\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"range\": null, \"subscribed_events\": [], \"tags\": [], \"value\": 0}",
    "props": [
      {
        "name": "range",
        "type": "Instance(Range)",
        "desc": "When applying ``Dodge`` to categorical data values, the corresponding\n    ``FactorRange`` must be supplied as the ``range`` property.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "value",
        "type": "Float",
        "desc": "The amount to dodge the input data.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Dot": {
    "name": "Dot",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render dots (one-quarter radius circles). \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Dot.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"2854\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "Drag": {
    "name": "Drag",
    "bases": [
      "bokeh.models.tools.Gesture"
    ],
    "desc": "A base class for tools that respond to drag events.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"2874\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Dropdown": {
    "name": "Dropdown",
    "bases": [
      "bokeh.models.widgets.buttons.AbstractButton"
    ],
    "desc": "A dropdown button.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"button_type\": \"default\", \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"icon\": null, \"id\": \"2880\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"label\": \"Dropdown\", \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"menu\": [], \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"split\": false, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "button_type",
        "type": "Enum('default', 'primary', 'success', 'warning', 'danger')",
        "desc": "A style for the button, signifying it's role.",
        "default": "default"
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "split",
        "type": "Bool",
        "desc": "",
        "default": false
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "label",
        "type": "String",
        "desc": "The text label for the button to display.",
        "default": "Dropdown"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "icon",
        "type": "Instance(AbstractIcon)",
        "desc": "An optional image appearing to the left of button's text.",
        "default": null
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "menu",
        "type": "List(Either(String, Tuple(String, Either(String, Instance(Callback)))))",
        "desc": "Button's dropdown menu consisting of entries containing item's text and\n    value name. Use ``None`` as a menu separator.",
        "default": []
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "EdgesAndLinkedNodes": {
    "name": "EdgesAndLinkedNodes",
    "bases": [
      "bokeh.models.graphs.GraphHitTestPolicy"
    ],
    "desc": "With the ``EdgesAndLinkedNodes`` policy, inspection or selection of graph\n    edges will result in the inspection or selection of the edge and of the\n    linked graph nodes. There is no direct selection or inspection of graph\n    nodes.",
    "proto": "{\"id\": \"2909\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "EditTool": {
    "name": "EditTool",
    "bases": [
      "bokeh.models.tools.Gesture"
    ],
    "desc": "A base class for all interactive draw tool types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"custom_icon\": null, \"custom_tooltip\": null, \"empty_value\": null, \"id\": \"2915\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"renderers\": [], \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "custom_icon",
        "type": "Image",
        "desc": "An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.",
        "default": null
      },
      {
        "name": "empty_value",
        "type": "Either(Bool, Int, Float, Date, Datetime, Color, String)",
        "desc": "Defines the value to insert on non-coordinate columns when a new\n    glyph is inserted into the ``ColumnDataSource`` columns, e.g. when a\n    circle glyph defines 'x', 'y' and 'color' columns, adding a new\n    point will add the x and y-coordinates to 'x' and 'y' columns and\n    the color column will be filled with the defined empty value.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "custom_tooltip",
        "type": "String",
        "desc": "A custom tooltip label to override the default name.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "An explicit list of renderers corresponding to scatter glyphs that may\n    be edited.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Ellipse": {
    "name": "Ellipse",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph"
    ],
    "desc": "Render ellipses.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Ellipse.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"height\": null, \"id\": \"2925\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"width\": null, \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the ovals.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the ovals.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the ovals.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the ovals.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the ovals.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the ovals.",
        "default": 1.0
      },
      {
        "name": "width",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The widths of each ellipse.",
        "default": null
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the centers of the ellipses.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "height",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The heights of each ellipse.",
        "default": null
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angle the ellipses are rotated from horizontal. [rad]",
        "default": 0.0
      },
      {
        "name": "height_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the ovals.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the ovals.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "width_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the ovals.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the centers of the ellipses.",
        "default": null
      }
    ]
  },
  "Expression": {
    "name": "Expression",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Base class for ``Expression`` models that represent a computation\n    to be carried out on the client-side.\n\n    JavaScript implementations should implement the following methods:\n\n    .. code-block\n\n        v_compute(source: ColumnarDataSource): Arrayable {\n            # compute and return array of values\n        }\n\n    .. note::\n        If you wish for results to be cached per source and updated only if\n        the source changes, implement ``_v_compute: (source)`` instead.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"2948\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "FactorRange": {
    "name": "FactorRange",
    "bases": [
      "bokeh.models.ranges.Range"
    ],
    "desc": "A Range of values for a categorical dimension.\n\n    In addition to supplying ``factors`` as a keyword argument to the\n    ``FactorRange`` initializer, you may also instantiate with a sequence of\n    positional arguments:\n\n    .. code-block:: python\n\n        FactorRange(\"foo\", \"bar\") # equivalent to FactorRange(factors=[\"foo\", \"bar\"])\n\n    Users will normally supply categorical values directly:\n\n    .. code-block:: python\n\n        p.circle(x=[\"foo\", \"bar\"], ...)\n\n    BokehJS will create a mapping from ``\"foo\"`` and ``\"bar\"`` to a numerical\n    coordinate system called *synthetic coordinates*. In the simplest cases,\n    factors are separated by a distance of 1.0 in synthetic coordinates,\n    however the exact mapping from factors to synthetic coordinates is\n    affected by he padding properties as well as whether the number of levels\n    the factors have.\n\n    Users typically do not need to worry about the details of this mapping,\n    however it can be useful to fine tune positions by adding offsets. When\n    supplying factors as coordinates or values, it is possible to add an\n    offset in the synthetic coordinate space by adding a final number value\n    to a factor tuple. For example:\n\n    .. code-block:: python\n\n        p.circle(x=[(\"foo\", 0.3), ...], ...)\n\n    will position the first circle at an ``x`` position that is offset by\n    adding 0.3 to the synthetic coordinate for ``\"foo\"``.",
    "proto": "{\"bounds\": null, \"factor_padding\": 0.0, \"factors\": [], \"group_padding\": 1.4, \"id\": \"2954\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_interval\": null, \"min_interval\": null, \"name\": null, \"range_padding\": 0, \"range_padding_units\": \"percent\", \"subgroup_padding\": 0.8, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "end",
        "type": "Float",
        "desc": "The end of the range, in synthetic coordinates.\n\n    .. note::\n        Synthetic coordinates are only computed in the browser, based on the\n        factors and various padding properties. The value of ``end`` will only\n        be available in situations where bidirectional communication is\n        available (e.g. server, notebook).",
        "default": null
      },
      {
        "name": "range_padding_units",
        "type": "Enum('percent', 'absolute')",
        "desc": "Whether the ``range_padding`` should be interpreted as a percentage, or\n    as an absolute quantity. (default: ``\"percent\"``)",
        "default": "percent"
      },
      {
        "name": "group_padding",
        "type": "Float",
        "desc": "How much padding to add in between top-level groups of factors. This\n    property only applies when the overall range factors have either two or\n    three levels. For example, with:\n\n    .. code-block:: python\n\n        FactorRange(factors=[[\"foo\", \"1'], [\"foo\", \"2'], [\"bar\", \"1\"]])\n\n    The top level groups correspond to ``\"foo\"` and ``\"bar\"``, and the\n    group padding will be applied between the factors ``[\"foo\", \"2']`` and\n    ``[\"bar\", \"1\"]``",
        "default": 1.4
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "start",
        "type": "Float",
        "desc": "The start of the range, in synthetic coordinates.\n\n        Synthetic coordinates are only computed in the browser, based on the\n        factors and various padding properties. The value of ``start`` will only\n        be available in situations where bidirectional communication is\n        available (e.g. server, notebook).",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "factor_padding",
        "type": "Float",
        "desc": "How much padding to add in between all lowest-level factors. When\n    ``factor_padding`` is non-zero, every factor in every group will have the\n    padding value applied.",
        "default": 0.0
      },
      {
        "name": "subgroup_padding",
        "type": "Float",
        "desc": "How much padding to add in between mid-level groups of factors. This\n    property only applies when the overall factors have three levels. For\n    example with:\n\n    .. code-block:: python\n\n        FactorRange(factors=[\n            ['foo', 'A', '1'],  ['foo', 'A', '2'], ['foo', 'A', '3'],\n            ['foo', 'B', '2'],\n            ['bar', 'A', '1'],  ['bar', 'A', '2']\n        ])\n\n    This property dictates how much padding to add between the three factors\n    in the `['foo', 'A']` group, and between the two factors in the the\n    [`bar`]",
        "default": 0.8
      },
      {
        "name": "factors",
        "type": "Either(Seq(String), Seq(Tuple(String, String)), Seq(Tuple(String, String, String)))",
        "desc": "A sequence of factors to define this categorical range.\n\n    Factors may have 1, 2, or 3 levels. For 1-level factors, each factor is\n    simply a string. For example:\n\n    .. code-block:: python\n\n        FactorRange(factors=[\"sales\", \"marketing\", \"engineering\"])\n\n    defines a range with three simple factors that might represent different\n    units of a business.\n\n    For 2- and 3- level factors, each factor is a tuple of strings:\n\n    .. code-block:: python\n\n        FactorRange(factors=[\n            [\"2016\", \"sales'], [\"2016\", \"marketing'], [\"2016\", \"engineering\"],\n            [\"2017\", \"sales'], [\"2017\", \"marketing'], [\"2017\", \"engineering\"],\n        ])\n\n    defines a range with six 2-level factors that might represent the three\n    business units, grouped by year.\n\n    Note that factors and sub-factors *may only be strings*.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "range_padding",
        "type": "Float",
        "desc": "How much padding to add around the outside of computed range bounds.\n\n    When ``range_padding_units`` is set to ``\"percent\"``, the span of the\n    range span is expanded to make the range ``range_padding`` percent larger.\n\n    When ``range_padding_units`` is set to ``\"absolute\"``, the start and end\n    of the range span are extended by the amount ``range_padding``.",
        "default": 0
      },
      {
        "name": "min_interval",
        "type": "Float",
        "desc": "The level that the range is allowed to zoom in, expressed as the\n    minimum visible interval in synthetic coordinates. If set to ``None``\n    (default), the minimum interval is not bounded.\n\n    The default \"width\" of a category is 1.0 in synthetic coordinates.\n    However, the distance between factors is affected by the various\n    padding properties and whether or not factors are grouped.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "bounds",
        "type": "MinMaxBounds(Auto, Tuple(Float, Float), Tuple(TimeDelta, TimeDelta))",
        "desc": "The bounds (in synthetic coordinates) that the range is allowed to go to.\n    Typically used to prevent the user from panning/zooming/etc away from the\n    data.\n\n    .. note::\n        Synthetic coordinates are only computed in the browser, based on the\n        factors and various padding properties. Some experimentation may be\n        required to arrive at bounds suitable for specific situations.\n\n    By default, the bounds will be None, allowing your plot to pan/zoom as far\n    as you want. If bounds are 'auto' they will be computed to be the same as\n    the start and end of the ``FactorRange``.",
        "default": null
      },
      {
        "name": "max_interval",
        "type": "Float",
        "desc": "The level that the range is allowed to zoom out, expressed as the\n    maximum visible interval in synthetic coordinates.. Note that ``bounds``\n    can impose an implicit constraint on the maximum interval as well.\n\n    The default \"width\" of a category is 1.0 in synthetic coordinates.\n    However, the distance between factors is affected by the various\n    padding properties and whether or not factors are grouped.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "FileInput": {
    "name": "FileInput",
    "bases": [
      "bokeh.models.widgets.widget.Widget"
    ],
    "desc": "Present a file-chooser dialog to users and return the contents of the\n    selected files.",
    "proto": "{\"accept\": \"\", \"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"filename\": \"\", \"height\": null, \"height_policy\": \"auto\", \"id\": \"2971\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"mime_type\": \"\", \"min_height\": null, \"min_width\": null, \"multiple\": false, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"value\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "filename",
        "type": "Either(String, List(String))",
        "desc": "The name(s) of the file or files that were loaded.\n\n    If `mulitiple` is set to False (default), this value is a single string with the\n    name of the single file that was chosen.\n\n    If `multiple` is True, this value is a list of strings, each containing the\n    name of one of the multiple files that were chosen.\n\n    This list provides the sequence of files for the respective lists in value and mime-type\n\n    .. note::\n        The full file path is not included since browsers will not provide\n        access to that information for security reasons.",
        "default": ""
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "mime_type",
        "type": "Either(String, List(String))",
        "desc": "The mime-type of the file or files that were loaded.\n\n    If `mulitiple` is set to False (default), this value is a single string with the\n    mime-type of the single file that was chosen.\n\n    If `multiple` is True, this value is a list of strings, each containing the\n    mime-type of one of the multiple files that were chosen.\n\n    The sequence of files is given by the list of filename (see below)",
        "default": ""
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "accept",
        "type": "String",
        "desc": "Comma-separated list of standard HTML file input filters that restrict what\n    files the user can pick from. Values can be:\n\n    `<file extension>`:\n        Specific file extension(s) (e.g: .gif, .jpg, .png, .doc) are pickable\n\n    `audio/*`:\n        all sound files are pickable\n\n    `video/*`:\n        all video files are pickable\n\n    `image/*`:\n        all image files are pickable\n\n    `<media type>`:\n        A valid `IANA Media Type`_, with no parameters.\n\n    .. _IANA Media Type: https://www.iana.org/assignments/media-types/media-types.xhtml",
        "default": ""
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "multiple",
        "type": "Bool",
        "desc": "set multiple=False (default) for single file selection, set multiple=True if\n    selection of more than one file at a time should be possible.",
        "default": false
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "value",
        "type": "Either(String, List(String))",
        "desc": "The base64-enconded contents of the file or files that were loaded.\n\n    If `mulitiple` is set to False (default), this value is a single string with the contents\n    of the single file that was chosen.\n\n    If `multiple` is True, this value is a list of strings, each containing the contents of\n    one of the multiple files that were chosen.\n\n    The sequence of files is given by the list of filenames (see below)",
        "default": ""
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "FillGlyph": {
    "name": "FillGlyph",
    "bases": [
      "bokeh.models.glyph.Glyph"
    ],
    "desc": "Glyphs with fill properties\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"3000\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Filter": {
    "name": "Filter",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A Filter model represents a filtering operation that returns a row-wise subset of\n    data when applied to a ``ColumnDataSource``.",
    "proto": "{\"filter\": null, \"id\": \"3006\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "filter",
        "type": "Either(Seq(Int), Seq(Bool))",
        "desc": "A list that can be either integer indices or booleans representing a row-wise subset of data.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "FixedTicker": {
    "name": "FixedTicker",
    "bases": [
      "bokeh.models.tickers.ContinuousTicker"
    ],
    "desc": "Generate ticks at fixed, explicitly supplied locations.\n\n    .. note::\n        The ``desired_num_ticks`` property is ignored by this Ticker.",
    "proto": "{\"desired_num_ticks\": 6, \"id\": \"3013\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"minor_ticks\": [], \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": [], \"ticks\": []}",
    "props": [
      {
        "name": "ticks",
        "type": "Seq(Float)",
        "desc": "List of major tick locations.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "minor_ticks",
        "type": "Seq(Float)",
        "desc": "List of minor tick locations.",
        "default": []
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "FreehandDrawTool": {
    "name": "FreehandDrawTool",
    "bases": [
      "bokeh.models.tools.EditTool",
      "bokeh.models.tools.Drag",
      "bokeh.models.tools.Tap"
    ],
    "desc": "*toolbar icon*: |freehand_draw_icon|\n\n    Allows freehand drawing of ``Patches`` and ``MultiLine`` glyphs. The glyph\n    to draw may be defined via the ``renderers`` property.\n\n    The tool will modify the columns on the data source corresponding to the\n    ``xs`` and ``ys`` values of the glyph. Any additional columns in the data\n    source will be padded with the declared ``empty_value``, when adding a new\n    point.\n\n    The supported actions include:\n\n    * Draw vertices: Click and drag to draw a line\n\n    * Delete patch/multi-line: Tap a patch/multi-line to select it then press\n      <<backspace>> key while the mouse is within the plot area.\n\n    .. |freehand_draw_icon| image:: /_images/icons/FreehandDraw.png\n        :height: 24px",
    "proto": "{\"custom_icon\": null, \"custom_tooltip\": null, \"empty_value\": null, \"id\": \"3023\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_objects\": 0, \"renderers\": [], \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "custom_icon",
        "type": "Image",
        "desc": "An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.",
        "default": null
      },
      {
        "name": "empty_value",
        "type": "Either(Bool, Int, Float, Date, Datetime, Color, String)",
        "desc": "Defines the value to insert on non-coordinate columns when a new\n    glyph is inserted into the ``ColumnDataSource`` columns, e.g. when a\n    circle glyph defines 'x', 'y' and 'color' columns, adding a new\n    point will add the x and y-coordinates to 'x' and 'y' columns and\n    the color column will be filled with the defined empty value.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "custom_tooltip",
        "type": "String",
        "desc": "A custom tooltip label to override the default name.",
        "default": null
      },
      {
        "name": "num_objects",
        "type": "Int",
        "desc": "Defines a limit on the number of patches or multi-lines that can be drawn.\n    By default there is no limit on the number of objects, but if enabled the\n    oldest drawn patch or multi-line will be overwritten when the limit is\n    reached.",
        "default": 0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "An explicit list of renderers corresponding to scatter glyphs that may\n    be edited.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "FuncTickFormatter": {
    "name": "FuncTickFormatter",
    "bases": [
      "bokeh.models.formatters.TickFormatter"
    ],
    "desc": "Display tick values that are formatted by a user-defined function.\n\n    .. warning::\n        The explicit purpose of this Bokeh Model is to embed *raw JavaScript\n        code* for a browser to execute. If any part of the code is derived\n        from untrusted user inputs, then you must take appropriate care to\n        sanitize the user input prior to passing to Bokeh.",
    "proto": "{\"args\": {}, \"code\": \"\", \"id\": \"3034\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "code",
        "type": "String",
        "desc": "A snippet of JavaScript code that reformats a single tick to the desired\n    format. The variable ``tick`` will contain the unformatted tick value and\n    can be expected to be present in the code snippet namespace at render time.\n\n    Additionally available variables are:\n\n      * ``ticks``, an array of all axis ticks as positioned by the ticker,\n      * ``index``, the position of ``tick`` within ``ticks``, and\n      * the keys of ``args`` mapping, if any.\n\n    Finding yourself needing to cache an expensive ``ticks``-dependent\n    computation, you can store it on the ``this`` variable.\n\n    Example:\n\n        .. code-block:: javascript\n\n            code = '''\n            this.precision = this.precision || (ticks.length > 5 ? 1 : 2);\n            return Math.floor(tick) + \" + \" + (tick % 1).toFixed(this.precision);\n            '''",
        "default": ""
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "args",
        "type": "Dict(String, AnyRef)",
        "desc": "A mapping of names to Python objects. In particular those can be bokeh's models.\n    These objects are made available to the formatter's code snippet as the values of\n    named parameters to the callback.",
        "default": {}
      }
    ]
  },
  "GMapOptions": {
    "name": "GMapOptions",
    "bases": [
      "bokeh.models.map_plots.MapOptions"
    ],
    "desc": "Options for ``GMapPlot`` objects.",
    "proto": "{\"id\": \"3042\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"lat\": null, \"lng\": null, \"map_type\": \"roadmap\", \"name\": null, \"scale_control\": false, \"styles\": null, \"subscribed_events\": [], \"tags\": [], \"tilt\": 45, \"zoom\": 12}",
    "props": [
      {
        "name": "tilt",
        "type": "Int",
        "desc": "`Tilt`_ angle of the map. The only allowed values are 0 and 45.\n    Only has an effect on 'satellite' and 'hybrid' map types.\n    A value of 0 causes the map to always use a 0 degree overhead view.\n    A value of 45 causes the tilt angle to switch to 45 imagery if available.\n\n    .. _Tilt: https://developers.google.com/maps/documentation/javascript/reference/3/map#MapOptions.tilt",
        "default": 45
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "map_type",
        "type": "Enum('satellite', 'roadmap', 'terrain', 'hybrid')",
        "desc": "The `map type`_ to use for the ``GMapPlot``.\n\n    .. _map type: https://developers.google.com/maps/documentation/javascript/reference#MapTypeId",
        "default": "roadmap"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "lng",
        "type": "Float",
        "desc": "The longitude where the map should be centered.",
        "default": null
      },
      {
        "name": "styles",
        "type": "JSON",
        "desc": "A JSON array of `map styles`_ to use for the ``GMapPlot``. Many example styles can\n    `be found here`_.\n\n    .. _map styles: https://developers.google.com/maps/documentation/javascript/reference#MapTypeStyle\n    .. _be found here: https://snazzymaps.com",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "scale_control",
        "type": "Bool",
        "desc": "Whether the Google map should display its distance scale control.",
        "default": false
      },
      {
        "name": "lat",
        "type": "Float",
        "desc": "The latitude where the map should be centered.",
        "default": null
      },
      {
        "name": "zoom",
        "type": "Int",
        "desc": "The initial zoom level to use when displaying the map.",
        "default": 12
      }
    ]
  },
  "GMapPlot": {
    "name": "GMapPlot",
    "bases": [
      "bokeh.models.map_plots.MapPlot"
    ],
    "desc": "A Bokeh Plot with a `Google Map`_ displayed underneath.\n\n    Data placed on this plot should be specified in decimal lat/lon coordinates\n    e.g. ``(37.123, -122.404)``. It will be automatically converted into the\n    web mercator projection to display properly over google maps tiles.\n\n    The ``api_key`` property must be configured with a Google API Key in order\n    for ``GMapPlot`` to function. The key will be stored in the Bokeh Document\n    JSON.\n\n    Note that Google Maps exert explicit control over aspect ratios at all\n    times, which imposes some limitations on ``GMapPlot``:\n\n    * Only ``Range1d`` ranges are supported. Attempting to use other range\n      types will result in an error.\n\n    * Usage of ``BoxZoomTool`` is incompatible with ``GMapPlot``. Adding a\n      ``BoxZoomTool`` will have no effect.\n\n    .. _Google Map: https://www.google.com/maps/",
    "proto": "{\"above\": [], \"align\": \"start\", \"api_key\": null, \"aspect_ratio\": null, \"aspect_scale\": 1, \"background\": null, \"background_fill_alpha\": 1.0, \"background_fill_color\": \"#ffffff\", \"below\": [], \"border_fill_alpha\": 1.0, \"border_fill_color\": \"#ffffff\", \"center\": [], \"css_classes\": [], \"disabled\": false, \"extra_x_ranges\": {}, \"extra_y_ranges\": {}, \"frame_height\": null, \"frame_width\": null, \"height\": null, \"height_policy\": \"auto\", \"hidpi\": true, \"id\": \"3055\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"left\": [], \"lod_factor\": 10, \"lod_interval\": 300, \"lod_threshold\": 2000, \"lod_timeout\": 500, \"map_options\": null, \"margin\": [0, 0, 0, 0], \"match_aspect\": false, \"max_height\": null, \"max_width\": null, \"min_border\": 5, \"min_border_bottom\": null, \"min_border_left\": null, \"min_border_right\": null, \"min_border_top\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"outline_line_alpha\": 1.0, \"outline_line_cap\": \"butt\", \"outline_line_color\": \"#e5e5e5\", \"outline_line_dash\": [], \"outline_line_dash_offset\": 0, \"outline_line_join\": \"bevel\", \"outline_line_width\": 1, \"output_backend\": \"canvas\", \"plot_height\": 600, \"plot_width\": 600, \"renderers\": [], \"reset_policy\": \"standard\", \"right\": [], \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": {\"id\": \"3059\"}, \"title_location\": \"above\", \"toolbar\": {\"id\": \"3058\"}, \"toolbar_location\": \"right\", \"toolbar_sticky\": true, \"visible\": true, \"width\": null, \"width_policy\": \"auto\", \"x_range\": {\"id\": \"3056\"}, \"x_scale\": {\"id\": \"3057\"}, \"y_range\": {\"id\": \"3061\"}, \"y_scale\": {\"id\": \"3060\"}}",
    "props": [
      {
        "name": "outline_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap for the plot border outline.",
        "default": "butt"
      },
      {
        "name": "outline_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset for the plot border outline.",
        "default": 0
      },
      {
        "name": "min_border_right",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region to the right of\n    the central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "match_aspect",
        "type": "Bool",
        "desc": "Specify the aspect ratio behavior of the plot. Aspect ratio is defined as\n    the ratio of width over height. This property controls whether Bokeh should\n    attempt the match the (width/height) of *data space* to the (width/height)\n    in pixels of *screen space*.\n\n    Default is ``False`` which indicates that the *data* aspect ratio and the\n    *screen* aspect ratio vary independently. ``True`` indicates that the plot\n    aspect ratio of the axes will match the aspect ratio of the pixel extent\n    the axes. The end result is that a 1x1 area in data space is a square in\n    pixels, and conversely that a 1x1 pixel is a square in data units.\n\n    .. note::\n        This setting only takes effect when there are two dataranges. This\n        setting only sets the initial plot draw and subsequent resets. It is\n        possible for tools (single axis zoom, unconstrained box zoom) to\n        change the aspect ratio.\n\n    .. warning::\n        This setting is incompatible with linking dataranges across multiple\n        plots. Doing so may result in undefined behaviour.",
        "default": false
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "outline_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join for the plot border outline.",
        "default": "bevel"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "min_border",
        "type": "Int",
        "desc": "A convenience property to set all all the ``min_border_X`` properties\n    to the same value. If an individual border property is explicitly set,\n    it will override ``min_border``.",
        "default": 5
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "lod_factor",
        "type": "Int",
        "desc": "Decimation factor to use when applying level-of-detail decimation.",
        "default": 10
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "plot_width",
        "type": "Int",
        "desc": "The outer width of a plot, including any axes, titles, border padding, etc.\n\n    .. note::\n        This corresponds directly to the width of the HTML canvas.",
        "default": 600
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "outline_line_alpha",
        "type": "Percent",
        "desc": "The line alpha for the plot border outline.",
        "default": 1.0
      },
      {
        "name": "background_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha for the plot background style.",
        "default": 1.0
      },
      {
        "name": "title_location",
        "type": "Enum('above', 'below', 'left', 'right')",
        "desc": "Where the title will be located. Titles on the left or right side\n    will be rotated.",
        "default": "above"
      },
      {
        "name": "x_range",
        "type": "Instance(Range)",
        "desc": "The (default) data range of the horizontal dimension of the plot.",
        "default": "{\"id\": \"3083\"}"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "extra_y_ranges",
        "type": "Dict(String, Instance(Range))",
        "desc": "Additional named ranges to make available for mapping y-coordinates.\n\n    This is useful for adding additional axes.",
        "default": {}
      },
      {
        "name": "outline_line_width",
        "type": "Float",
        "desc": "The line width for the plot border outline.",
        "default": 1
      },
      {
        "name": "min_border_top",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region above the top of the\n    central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "outline_line_color",
        "type": "Color",
        "desc": "The line color for the plot border outline.",
        "default": "#e5e5e5"
      },
      {
        "name": "toolbar_location",
        "type": "Enum('above', 'below', 'left', 'right')",
        "desc": "Where the toolbar will be located. If set to None, no toolbar\n    will be attached to the plot.",
        "default": "right"
      },
      {
        "name": "above",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area above of the plot.",
        "default": []
      },
      {
        "name": "plot_height",
        "type": "Int",
        "desc": "The outer height of a plot, including any axes, titles, border padding, etc.\n\n    .. note::\n        This corresponds directly to the height of the HTML canvas.",
        "default": 600
      },
      {
        "name": "aspect_scale",
        "type": "Float",
        "desc": "A value to be given for increased aspect ratio control. This value is added\n    multiplicatively to the calculated value required for ``match_aspect``.\n    ``aspect_scale`` is defined as the ratio of width over height of the figure.\n\n    For example, a plot with ``aspect_scale`` value of 2 will result in a\n    square in *data units* to be drawn on the screen as a rectangle with a\n    pixel width twice as long as its pixel height.\n\n    .. note::\n        This setting only takes effect if ``match_aspect`` is set to ``True``.",
        "default": 1
      },
      {
        "name": "output_backend",
        "type": "Enum('canvas', 'svg', 'webgl')",
        "desc": "Specify the output backend for the plot area. Default is HTML5 Canvas.\n\n    .. note::\n        When set to ``webgl``, glyphs without a WebGL rendering implementation\n        will fall back to rendering onto 2D canvas.",
        "default": "canvas"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      },
      {
        "name": "map_options",
        "type": "Instance(GMapOptions)",
        "desc": "Options for displaying the plot.",
        "default": null
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "border_fill_color",
        "type": "Color",
        "desc": "The fill color for the plot border style.",
        "default": "#ffffff"
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "x_scale",
        "type": "Instance(Scale)",
        "desc": "What kind of scale to use to convert x-coordinates in data space\n    into x-coordinates in screen space.",
        "default": "{\"id\": \"3102\"}"
      },
      {
        "name": "outline_line_dash",
        "type": "DashPattern",
        "desc": "The line dash for the plot border outline.",
        "default": []
      },
      {
        "name": "reset_policy",
        "type": "Enum('standard', 'event_only')",
        "desc": "How a plot should respond to being reset. By deafult, the standard actions\n    are to clear any tool state history, return plot ranges to their original\n    values, undo all selections, and emit a ``Reset`` event. If customization\n    is desired, this property may be set to ``\"event_only\"``, which will\n    suppress all of the actions except the Reset event.",
        "default": "standard"
      },
      {
        "name": "outer_height",
        "type": "Int",
        "desc": "This is the exact height of the layout, i.e. the height of\n    the actual plot, with toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "api_key",
        "type": "Base64String",
        "desc": "Google Maps API requires an API key. See https://developers.google.com/maps/documentation/javascript/get-api-key\n    for more information on how to obtain your own.",
        "default": null
      },
      {
        "name": "border_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha for the plot border style.",
        "default": 1.0
      },
      {
        "name": "outer_width",
        "type": "Int",
        "desc": "This is the exact width of the layout, i.e. the height of\n    the actual plot, with toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "toolbar",
        "type": "Instance(Toolbar)",
        "desc": "The toolbar associated with this plot which holds all the tools. It is\n    automatically created with the plot if necessary.",
        "default": "{\"id\": \"3110\"}"
      },
      {
        "name": "toolbar_sticky",
        "type": "Bool",
        "desc": "Stick the toolbar to the edge of the plot. Default: True. If False,\n    the toolbar will be outside of the axes, titles etc.",
        "default": true
      },
      {
        "name": "min_border_bottom",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region below the bottom of\n    the central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "title",
        "type": "Instance(Title)",
        "desc": "A title for the plot. Can be a text string or a Title annotation.",
        "default": "{\"id\": \"3114\", \"text\": \"\"}"
      },
      {
        "name": "frame_height",
        "type": "Int",
        "desc": "The height of a plot frame or the inner height of a plot, excluding any\n    axes, titles, border padding, etc.",
        "default": null
      },
      {
        "name": "center",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the center area (frame) of the plot.",
        "default": []
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "lod_threshold",
        "type": "Int",
        "desc": "A number of data points, above which level-of-detail downsampling may\n    be performed by glyph renderers. Set to ``None`` to disable any\n    level-of-detail downsampling.",
        "default": 2000
      },
      {
        "name": "below",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area below of the plot.",
        "default": []
      },
      {
        "name": "lod_interval",
        "type": "Int",
        "desc": "Interval (in ms) during which an interactive tool event will enable\n    level-of-detail downsampling.",
        "default": 300
      },
      {
        "name": "lod_timeout",
        "type": "Int",
        "desc": "Timeout (in ms) for checking whether interactive tool events are still\n    occurring. Once level-of-detail mode is enabled, a check is made every\n    ``lod_timeout`` ms. If no interactive tool events have happened,\n    level-of-detail mode is disabled.",
        "default": 500
      },
      {
        "name": "left",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area to the left of the plot.",
        "default": []
      },
      {
        "name": "right",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area to the right of the plot.",
        "default": []
      },
      {
        "name": "min_border_left",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region to the left of\n    the central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "y_scale",
        "type": "Instance(Scale)",
        "desc": "What kind of scale to use to convert y-coordinates in data space\n    into y-coordinates in screen space.",
        "default": "{\"id\": \"3126\"}"
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "y_range",
        "type": "Instance(Range)",
        "desc": "The (default) data range of the vertical dimension of the plot.",
        "default": "{\"id\": \"3129\"}"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "inner_width",
        "type": "Int",
        "desc": "This is the exact width of the plotting canvas, i.e. the width of\n    the actual plot, without toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "inner_height",
        "type": "Int",
        "desc": "This is the exact height of the plotting canvas, i.e. the height of\n    the actual plot, without toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "extra_x_ranges",
        "type": "Dict(String, Instance(Range))",
        "desc": "Additional named ranges to make available for mapping x-coordinates.\n\n    This is useful for adding additional axes.",
        "default": {}
      },
      {
        "name": "background_fill_color",
        "type": "Color",
        "desc": "The fill color for the plot background style.",
        "default": "#ffffff"
      },
      {
        "name": "hidpi",
        "type": "Bool",
        "desc": "Whether to use HiDPI mode when available.",
        "default": true
      },
      {
        "name": "frame_width",
        "type": "Int",
        "desc": "The width of a plot frame or the inner width of a plot, excluding any\n    axes, titles, border padding, etc.",
        "default": null
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "A list of all renderers for this plot, including guides and annotations\n    in addition to glyphs and markers.\n\n    This property can be manipulated by hand, but the ``add_glyph`` and\n    ``add_layout`` methods are recommended to help make sure all necessary\n    setup is performed.",
        "default": []
      }
    ]
  },
  "GeoJSONDataSource": {
    "name": "GeoJSONDataSource",
    "bases": [
      "bokeh.models.sources.ColumnarDataSource"
    ],
    "desc": "",
    "proto": "{\"geojson\": null, \"id\": \"3141\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"selected\": {\"id\": \"3142\"}, \"selection_policy\": {\"id\": \"3143\"}, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "selected",
        "type": "Instance(Selection)",
        "desc": "An instance of a ``Selection`` that indicates selected indices on this ``DataSource``.\n    This is a read-only property. You may only change the attributes of this object\n    to change the selection (e.g., ``selected.indices``).",
        "default": "{\"id\": \"3147\"}"
      },
      {
        "name": "selection_policy",
        "type": "Instance(SelectionPolicy)",
        "desc": "An instance of a ``SelectionPolicy`` that determines how selections are set.",
        "default": "{\"id\": \"3149\"}"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "geojson",
        "type": "JSON",
        "desc": "GeoJSON that contains features for plotting. Currently\n    ``GeoJSONDataSource`` can only process a ``FeatureCollection`` or\n    ``GeometryCollection``.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Gesture": {
    "name": "Gesture",
    "bases": [
      "bokeh.models.tools.Tool"
    ],
    "desc": "A base class for tools that respond to drag events.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"3154\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Glyph": {
    "name": "Glyph",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Base class for all glyph models.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"3160\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "GlyphRenderer": {
    "name": "GlyphRenderer",
    "bases": [
      "bokeh.models.renderers.DataRenderer"
    ],
    "desc": "",
    "proto": "{\"data_source\": null, \"glyph\": null, \"hover_glyph\": null, \"id\": \"3166\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"glyph\", \"muted\": false, \"muted_glyph\": null, \"name\": null, \"nonselection_glyph\": \"auto\", \"selection_glyph\": \"auto\", \"subscribed_events\": [], \"tags\": [], \"view\": {\"id\": \"3167\"}, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "view",
        "type": "Instance(CDSView)",
        "desc": "A view into the data source to use when rendering glyphs. A default view\n    of the entire data source is created when a view is not passed in during\n    initialization.\n\n    .. note:\n        Only the default (filterless) CDSView is compatible with glyphs that\n        have connected topology, such as Line and Patch. Setting filters on\n        views for these glyphs will result in a warning and undefined behavior.",
        "default": null
      },
      {
        "name": "muted_glyph",
        "type": "Instance(Glyph)",
        "desc": "",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "nonselection_glyph",
        "type": "Either(Auto, Instance(Glyph))",
        "desc": "An optional glyph used for explicitly non-selected points\n    (i.e., non-selected when there are other points that are selected,\n    but not when no points at all are selected.)\n\n    If set to \"auto\" then a glyph with a low alpha value (0.1) will\n    be used for non-selected points.",
        "default": "auto"
      },
      {
        "name": "hover_glyph",
        "type": "Instance(Glyph)",
        "desc": "An optional glyph used for inspected points, e.g., those that are\n    being hovered over by a ``HoverTool``.",
        "default": null
      },
      {
        "name": "glyph",
        "type": "Instance(Glyph)",
        "desc": "The glyph to render, in conjunction with the supplied data source\n    and ranges.",
        "default": null
      },
      {
        "name": "data_source",
        "type": "Instance(DataSource)",
        "desc": "Local data source to use when rendering glyphs on the plot.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering glyphs on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "selection_glyph",
        "type": "Either(Auto, Instance(Glyph))",
        "desc": "An optional glyph used for selected points.\n\n    If set to \"auto\" then the standard glyph will be used for selected\n    points.",
        "default": "auto"
      },
      {
        "name": "muted",
        "type": "Bool",
        "desc": "",
        "default": false
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "glyph"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering glyphs on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "GraphHitTestPolicy": {
    "name": "GraphHitTestPolicy",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": ".. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"3202\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "GraphRenderer": {
    "name": "GraphRenderer",
    "bases": [
      "bokeh.models.renderers.DataRenderer"
    ],
    "desc": "",
    "proto": "{\"edge_renderer\": {\"id\": \"3215\"}, \"id\": \"3208\", \"inspection_policy\": {\"id\": \"3218\"}, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"layout_provider\": null, \"level\": \"glyph\", \"name\": null, \"node_renderer\": {\"id\": \"3211\"}, \"selection_policy\": {\"id\": \"3217\"}, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "layout_provider",
        "type": "Instance(LayoutProvider)",
        "desc": "An instance of a ``LayoutProvider`` that supplies the layout of the network\n    graph in cartesian space.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "node_renderer",
        "type": "Instance(GlyphRenderer)",
        "desc": "Instance of a ``GlyphRenderer`` containing an ``XYGlyph`` that will be rendered\n    as the graph nodes.",
        "default": "{\"data_source\": {\"id\": \"3224\"}, \"glyph\": {\"id\": \"3223\"}, \"id\": \"3225\", \"view\": {\"id\": \"3226\"}}"
      },
      {
        "name": "edge_renderer",
        "type": "Instance(GlyphRenderer)",
        "desc": "Instance of a ``GlyphRenderer`` containing an ``MultiLine`` Glyph that will be\n    rendered as the graph edges.",
        "default": "{\"data_source\": {\"id\": \"3229\"}, \"glyph\": {\"id\": \"3228\"}, \"id\": \"3230\", \"view\": {\"id\": \"3231\"}}"
      },
      {
        "name": "selection_policy",
        "type": "Instance(GraphHitTestPolicy)",
        "desc": "An instance of a ``GraphHitTestPolicy`` that provides the logic for selection\n    of graph components.",
        "default": "{\"id\": \"3233\"}"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering glyphs on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "inspection_policy",
        "type": "Instance(GraphHitTestPolicy)",
        "desc": "An instance of a ``GraphHitTestPolicy`` that provides the logic for inspection\n    of graph components.",
        "default": "{\"id\": \"3237\"}"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "glyph"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering glyphs on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Grid": {
    "name": "Grid",
    "bases": [
      "bokeh.models.renderers.GuideRenderer"
    ],
    "desc": "Display horizontal or vertical grid lines at locations\n    given by a supplied ``Ticker``.",
    "proto": "{\"axis\": null, \"band_fill_alpha\": 0, \"band_fill_color\": null, \"band_hatch_alpha\": 1.0, \"band_hatch_color\": \"black\", \"band_hatch_extra\": {}, \"band_hatch_pattern\": null, \"band_hatch_scale\": 12.0, \"band_hatch_weight\": 1.0, \"bounds\": \"auto\", \"dimension\": 0, \"grid_line_alpha\": 1.0, \"grid_line_cap\": \"butt\", \"grid_line_color\": \"#e5e5e5\", \"grid_line_dash\": [], \"grid_line_dash_offset\": 0, \"grid_line_join\": \"bevel\", \"grid_line_width\": 1, \"id\": \"3243\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"underlay\", \"minor_grid_line_alpha\": 1.0, \"minor_grid_line_cap\": \"butt\", \"minor_grid_line_color\": null, \"minor_grid_line_dash\": [], \"minor_grid_line_dash_offset\": 0, \"minor_grid_line_join\": \"bevel\", \"minor_grid_line_width\": 1, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"ticker\": null, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "grid_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the Grid lines.",
        "default": []
      },
      {
        "name": "band_hatch_extra",
        "type": "Dict(String, Instance(Texture))",
        "desc": "The hatch extra of alternating bands between Grid lines.",
        "default": {}
      },
      {
        "name": "band_hatch_alpha",
        "type": "Percent",
        "desc": "The hatch alpha of alternating bands between Grid lines.",
        "default": 1.0
      },
      {
        "name": "band_hatch_scale",
        "type": "Size",
        "desc": "The hatch scale of alternating bands between Grid lines.",
        "default": 12.0
      },
      {
        "name": "grid_line_width",
        "type": "Float",
        "desc": "The line width of the Grid lines.",
        "default": 1
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering a grid on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "band_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha of alternating bands between Grid lines.",
        "default": 0
      },
      {
        "name": "band_fill_color",
        "type": "Color",
        "desc": "The fill color of alternating bands between Grid lines.",
        "default": null
      },
      {
        "name": "band_hatch_color",
        "type": "Color",
        "desc": "The hatch color of alternating bands between Grid lines.",
        "default": "black"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "minor_grid_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the minor Grid lines.",
        "default": "bevel"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "minor_grid_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the minor Grid lines.",
        "default": []
      },
      {
        "name": "minor_grid_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the minor Grid lines.",
        "default": 1.0
      },
      {
        "name": "dimension",
        "type": "Int",
        "desc": "Which dimension the Axis Grid lines will intersect. The\n    x-axis is dimension 0 (vertical Grid lines) and the y-axis\n    is dimension 1 (horizontal Grid lines).",
        "default": 0
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering a grid on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "axis",
        "type": "Instance(Axis)",
        "desc": "An Axis to delegate ticking to. If the ticker property is None, then the\n    Grid will use the ticker on the specified axis for computing where to draw\n    grid lines. Otherwise, it ticker is not None, it will take precedence over\n    any Axis.",
        "default": null
      },
      {
        "name": "ticker",
        "type": "Instance(Ticker)",
        "desc": "A Ticker to use for computing locations for the Grid lines.",
        "default": null
      },
      {
        "name": "grid_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the Grid lines.",
        "default": 1.0
      },
      {
        "name": "grid_line_color",
        "type": "Color",
        "desc": "The line color of the Grid lines.",
        "default": "#e5e5e5"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "grid_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the Grid lines.",
        "default": "butt"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "minor_grid_line_width",
        "type": "Float",
        "desc": "The line width of the minor Grid lines.",
        "default": 1
      },
      {
        "name": "band_hatch_weight",
        "type": "Size",
        "desc": "The hatch weight of alternating bands between Grid lines.",
        "default": 1.0
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "underlay"
      },
      {
        "name": "minor_grid_line_color",
        "type": "Color",
        "desc": "The line color of the minor Grid lines.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "band_hatch_pattern",
        "type": "String",
        "desc": "The hatch pattern of alternating bands between Grid lines.",
        "default": null
      },
      {
        "name": "bounds",
        "type": "Either(Auto, Tuple(Float, Float))",
        "desc": "Bounds for the rendered grid lines. By default, a grid will look for a\n    corresponding axis to ask for bounds. If one cannot be found, the grid\n    will span the entire visible range.",
        "default": "auto"
      },
      {
        "name": "minor_grid_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the minor Grid lines.",
        "default": 0
      },
      {
        "name": "grid_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the Grid lines.",
        "default": "bevel"
      },
      {
        "name": "minor_grid_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the minor Grid lines.",
        "default": "butt"
      },
      {
        "name": "grid_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the Grid lines.",
        "default": 0
      }
    ]
  },
  "GridBox": {
    "name": "GridBox",
    "bases": [
      "bokeh.models.layouts.LayoutDOM"
    ],
    "desc": "",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"children\": [], \"cols\": \"auto\", \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"3279\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"rows\": \"auto\", \"sizing_mode\": null, \"spacing\": 0, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "children",
        "type": "List(Either(Tuple(Instance(LayoutDOM), Int, Int), Tuple(Instance(LayoutDOM), Int, Int, Int, Int)))",
        "desc": "A list of children with their associated position in the grid (row, column).",
        "default": []
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "rows",
        "type": "Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Dict(Either(Int, String), Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Struct(policy=Enum('auto', 'min'), align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fixed'), height=Int, align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fit', 'max'), flex=Float, align=Either(Auto, Enum('start', 'center', 'end'))))))",
        "desc": "Describes how the grid should maintain its rows' heights.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion.",
        "default": "auto"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "cols",
        "type": "Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Dict(Either(Int, String), Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Struct(policy=Enum('auto', 'min'), align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fixed'), width=Int, align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fit', 'max'), flex=Float, align=Either(Auto, Enum('start', 'center', 'end'))))))",
        "desc": "Describes how the grid should maintain its columns' widths.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion.",
        "default": "auto"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "spacing",
        "type": "Either(Int, Tuple(Int, Int))",
        "desc": "The gap between children (in pixels).\n\n    Either a number, if spacing is the same for both dimensions, or a pair\n    of numbers indicating spacing in the vertical and horizontal dimensions\n    respectively.",
        "default": 0
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "Group": {
    "name": "Group",
    "bases": [
      "bokeh.models.widgets.groups.AbstractGroup"
    ],
    "desc": "Abstract base class for groups with items rendered as check/radio\n    boxes.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"3305\", \"inline\": false, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"labels\": [], \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "labels",
        "type": "List(String)",
        "desc": "List of text labels contained in this group.",
        "default": []
      },
      {
        "name": "inline",
        "type": "Bool",
        "desc": "Should items be arrange vertically (``False``) or horizontally\n    in-line (``True``).",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "GroupFilter": {
    "name": "GroupFilter",
    "bases": [
      "bokeh.models.filters.Filter"
    ],
    "desc": "A ``GroupFilter`` represents the rows of a ``ColumnDataSource`` where the values of the categorical\n    column column_name match the group variable.",
    "proto": "{\"column_name\": null, \"filter\": null, \"group\": null, \"id\": \"3331\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "column_name",
        "type": "String",
        "desc": "The name of the column to perform the group filtering operation on.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "group",
        "type": "String",
        "desc": "The value of the column indicating the rows of data to keep.",
        "default": null
      },
      {
        "name": "filter",
        "type": "Either(Seq(Int), Seq(Bool))",
        "desc": "A list that can be either integer indices or booleans representing a row-wise subset of data.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "GroupingInfo": {
    "name": "GroupingInfo",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Describes how to calculate totals and sub-totals",
    "proto": "{\"aggregators\": [], \"collapsed\": false, \"getter\": \"\", \"id\": \"3340\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "getter",
        "type": "String",
        "desc": "References the column which generates the unique keys of this sub-total (groupby).",
        "default": ""
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "aggregators",
        "type": "List(Instance(RowAggregator))",
        "desc": "Describes how to aggregate the columns which will populate this sub-total.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "collapsed",
        "type": "Bool",
        "desc": "Whether the corresponding sub-total is expanded or collapsed by default.",
        "default": false
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "GuideRenderer": {
    "name": "GuideRenderer",
    "bases": [
      "bokeh.models.renderers.Renderer"
    ],
    "desc": "A base class for all guide renderer types. ``GuideRenderer`` is\n    not generally useful to instantiate on its own.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"3349\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"guide\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "guide"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "HArea": {
    "name": "HArea",
    "bases": [
      "bokeh.models.glyph.FillGlyph",
      "bokeh.models.glyph.HatchGlyph",
      "bokeh.models.glyph.LineGlyph"
    ],
    "desc": "Render a horizontally directed area between two equal length sequences\n    of x-coordinates with the same y-coordinates.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/HArea.py\n        :source-position: below",
    "proto": "{\"fill_alpha\": 1.0, \"fill_color\": \"gray\", \"hatch_alpha\": {\"value\": 1.0}, \"hatch_color\": {\"value\": \"black\"}, \"hatch_extra\": {}, \"hatch_pattern\": null, \"hatch_scale\": {\"value\": 12.0}, \"hatch_weight\": {\"value\": 1.0}, \"id\": \"3357\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x1\": null, \"x2\": null, \"y\": null}",
    "props": [
      {
        "name": "fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the horizontal directed area.",
        "default": 1.0
      },
      {
        "name": "x1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates for the points of one side of the area.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "hatch_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The hatch color values for the horizontal bars.",
        "default": "black"
      },
      {
        "name": "hatch_pattern",
        "type": "HatchPatternSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), HatchPatternType)), HatchPatternType)",
        "desc": "The hatch pattern values for the horizontal bars.",
        "default": null
      },
      {
        "name": "x2",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates for the points of the other side of the area.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "hatch_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch alpha values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "fill_color",
        "type": "Color",
        "desc": "The fill color values for the horizontal directed area.",
        "default": "gray"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "hatch_weight",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch weight values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "hatch_extra",
        "type": "Dict(String, Instance(Texture))",
        "desc": "The hatch extra values for the horizontal bars.",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "hatch_scale",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch scale values for the horizontal bars.",
        "default": 12.0
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates for the points of the area.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "HBar": {
    "name": "HBar",
    "bases": [
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph",
      "bokeh.models.glyph.HatchGlyph"
    ],
    "desc": "Render horizontal bars, given a center coordinate, ``height`` and\n    (``left``, ``right``) coordinates.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/HBar.py\n        :source-position: below",
    "proto": "{\"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"hatch_alpha\": {\"value\": 1.0}, \"hatch_color\": {\"value\": \"black\"}, \"hatch_extra\": {}, \"hatch_pattern\": null, \"hatch_scale\": {\"value\": 12.0}, \"hatch_weight\": {\"value\": 1.0}, \"height\": null, \"id\": \"3374\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"left\": {\"value\": 0}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"right\": null, \"subscribed_events\": [], \"tags\": [], \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the horizontal bars.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the horizontal bars.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the horizontal bars.",
        "default": "black"
      },
      {
        "name": "hatch_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch alpha values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the horizontal bars.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the horizontal bars.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "hatch_weight",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch weight values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "hatch_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The hatch color values for the horizontal bars.",
        "default": "black"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the centers of the horizontal bars.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "height",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The heights of the vertical bars.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the horizontal bars.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "left",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the left edges.",
        "default": 0
      },
      {
        "name": "right",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the right edges.",
        "default": null
      },
      {
        "name": "hatch_pattern",
        "type": "HatchPatternSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), HatchPatternType)), HatchPatternType)",
        "desc": "The hatch pattern values for the horizontal bars.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "hatch_extra",
        "type": "Dict(String, Instance(Texture))",
        "desc": "The hatch extra values for the horizontal bars.",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the horizontal bars.",
        "default": "bevel"
      },
      {
        "name": "hatch_scale",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch scale values for the horizontal bars.",
        "default": 12.0
      }
    ]
  },
  "HTMLBox": {
    "name": "HTMLBox",
    "bases": [
      "bokeh.models.layouts.LayoutDOM"
    ],
    "desc": "A component which size is determined by its HTML content.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"3399\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "HTMLTemplateFormatter": {
    "name": "HTMLTemplateFormatter",
    "bases": [
      "bokeh.models.widgets.tables.CellFormatter"
    ],
    "desc": "HTML formatter using a template.\n    This uses Underscore's `template` method and syntax.  http://underscorejs.org/#template\n    The formatter has access other items in the row via the `dataContext` object passed to the formatter.\n    So, for example, if another column in the datasource was named `url`, the template could access it as:\n\n    .. code-block:: jinja\n\n        <a href=\"<%= url %>\"><%= value %></a>\n\n    To use a different set of template delimiters, pass the appropriate values for `evaluate`, `interpolate',\n    or `escape`.  See the Underscore `template` documentation for more information.  http://underscorejs.org/#template\n\n    Example: Simple HTML template to format the column value as code.\n\n    .. code-block:: python\n\n        HTMLTemplateFormatter(template='<code><%= value %></code>')\n\n    Example: Use values from other columns (`manufacturer` and `model`) to build a hyperlink.\n\n    .. code-block:: python\n\n        HTMLTemplateFormatter(template=\n            '<a href=\"https:/www.google.com/search?q=<%= manufacturer %>+<%= model %>\" target=\"_blank\"><%= value %></a>'\n        )",
    "proto": "{\"id\": \"3421\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"template\": \"<%= value %>\"}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "template",
        "type": "String",
        "desc": "Template string to be used by Underscore's template method.",
        "default": "<%= value %>"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "HatchGlyph": {
    "name": "HatchGlyph",
    "bases": [
      "bokeh.models.glyph.Glyph"
    ],
    "desc": "Glyphs with Hatch properties\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"3428\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "HelpTool": {
    "name": "HelpTool",
    "bases": [
      "bokeh.models.tools.Action"
    ],
    "desc": "A button tool to provide a \"help\" link to users.\n\n    The hover text can be customized through the ``help_tooltip`` attribute\n    and the redirect site overridden as well.",
    "proto": "{\"help_tooltip\": \"Click the question mark to learn more about Bokeh plot tools.\", \"id\": \"3434\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"redirect\": \"https://docs.bokeh.org/en/latest/docs/user_guide/tools.html\", \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "help_tooltip",
        "type": "String",
        "desc": "Tooltip displayed when hovering over the help icon.",
        "default": "Click the question mark to learn more about Bokeh plot tools."
      },
      {
        "name": "redirect",
        "type": "String",
        "desc": "Site to be redirected through upon click.",
        "default": "https://docs.bokeh.org/en/latest/docs/user_guide/tools.html"
      }
    ]
  },
  "Hex": {
    "name": "Hex",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render hexagon markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Hex.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"3442\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "HexDot": {
    "name": "HexDot",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render hexagon markers with center dots. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/HexDot.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"3462\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "HexTile": {
    "name": "HexTile",
    "bases": [
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph"
    ],
    "desc": "Render horizontal tiles on a regular hexagonal grid.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/HexTile.py\n        :source-position: below",
    "proto": "{\"aspect_scale\": 1.0, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"3482\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": null}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"orientation\": \"pointytop\", \"q\": null, \"r\": null, \"scale\": {\"value\": 1.0}, \"size\": 1.0, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "scale",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "A scale factor for individual tiles.",
        "default": 1.0
      },
      {
        "name": "orientation",
        "type": "String",
        "desc": "",
        "default": "pointytop"
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the horizontal bars.",
        "default": []
      },
      {
        "name": "size",
        "type": "Float",
        "desc": "The radius (in data space units) of the hex tiling.\n\n    The radius is always measured along the cartesian y-axis for \"pointy_top\"\n    orientation, and along the cartesian x-axis for \"flat_top\" orientation. If\n    the aspect ratio of the underlying cartesian system is not 1-1, then the\n    tiles may be \"squished\" in one direction. To ensure that the tiles are\n    always regular hexagons, consider setting the ``match_aspect`` property of\n    the plot to True.",
        "default": 1.0
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the horizontal bars.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the horizontal bars.",
        "default": null
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the horizontal bars.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the horizontal bars.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the horizontal bars.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the horizontal bars.",
        "default": "bevel"
      },
      {
        "name": "q",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The \"column\" axial coordinates of the tile centers.",
        "default": null
      },
      {
        "name": "r",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The \"row\" axial coordinates of the tile centers.",
        "default": null
      },
      {
        "name": "aspect_scale",
        "type": "Float",
        "desc": "",
        "default": 1.0
      }
    ]
  },
  "HoverTool": {
    "name": "HoverTool",
    "bases": [
      "bokeh.models.tools.Inspection"
    ],
    "desc": "*toolbar icon*: |hover_icon|\n\n    The hover tool is a passive inspector tool. It is generally on at all\n    times, but can be configured in the inspector's menu associated with the\n    *toolbar icon* shown above.\n\n    By default, the hover tool displays informational tooltips whenever the\n    cursor is directly over a glyph. The data to show comes from the glyph's\n    data source, and what to display is configurable with the ``tooltips``\n    property that maps display names to columns in the data source, or to\n    special known variables.\n\n    Here is an example of how to configure and use the hover tool::\n\n        # Add tooltip (name, field) pairs to the tool. See below for a\n        # description of possible field values.\n        hover.tooltips = [\n            (\"index\", \"$index\"),\n            (\"(x,y)\", \"($x, $y)\"),\n            (\"radius\", \"@radius\"),\n            (\"fill color\", \"$color[hex, swatch]:fill_color\"),\n            (\"foo\", \"@foo\"),\n            (\"bar\", \"@bar\"),\n            (\"baz\", \"@baz{safe}\"),\n            (\"total\", \"@total{$0,0.00}\"\n        ]\n\n    You can also supply a ``Callback`` to the ``HoverTool``, to build custom\n    interactions on hover. In this case you may want to turn the tooltips\n    off by setting ``tooltips=None``.\n\n    .. warning::\n        When supplying a callback or custom template, the explicit intent\n        of this Bokeh Model is to embed *raw HTML and  JavaScript code* for\n        a browser to execute. If any part of the code is derived from untrusted\n        user inputs, then you must take appropriate care to sanitize the user\n        input prior to passing to Bokeh.\n\n    Hover tool does not currently work with the following glyphs:\n\n        .. hlist::\n            :columns: 3\n\n            * annulus\n            * arc\n            * bezier\n            * image\n            * image_rgba\n            * image_url\n            * oval\n            * patch\n            * quadratic\n            * ray\n            * step\n            * text\n\n    .. |hover_icon| image:: /_images/icons/Hover.png\n        :height: 24px",
    "proto": "{\"anchor\": \"center\", \"attachment\": \"horizontal\", \"callback\": null, \"formatters\": {}, \"id\": \"3503\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_policy\": \"nearest\", \"mode\": \"mouse\", \"muted_policy\": \"show\", \"name\": null, \"names\": [], \"point_policy\": \"snap_to_data\", \"renderers\": \"auto\", \"show_arrow\": true, \"subscribed_events\": [], \"tags\": [], \"toggleable\": true, \"tooltips\": [[\"index\", \"$index\"], [\"data (x, y)\", \"($x, $y)\"], [\"screen (x, y)\", \"($sx, $sy)\"]]}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('mouse', 'hline', 'vline')",
        "desc": "Whether to consider hover pointer as a point (x/y values), or a\n    span on h or v directions.",
        "default": "mouse"
      },
      {
        "name": "line_policy",
        "type": "Enum('prev', 'next', 'nearest', 'interp', 'none')",
        "desc": "When showing tooltips for lines, designates whether the tooltip position\n    should be the \"previous\" or \"next\" points on the line, the \"nearest\" point\n    to the current mouse position, or \"interpolate\" along the line to the\n    current mouse position.",
        "default": "nearest"
      },
      {
        "name": "tooltips",
        "type": "Either(String, List(Tuple(String, String)))",
        "desc": "The (name, field) pairs describing what the hover tool should\n    display when there is a hit.\n\n    Field names starting with \"@\" are interpreted as columns on the\n    data source. For instance, \"@temp\" would look up values to display\n    from the \"temp\" column of the data source.\n\n    Field names starting with \"$\" are special, known fields:\n\n    :$index: index of hovered point in the data source\n    :$name: value of the ``name`` property of the hovered glyph renderer\n    :$x: x-coordinate under the cursor in data space\n    :$y: y-coordinate under the cursor in data space\n    :$sx: x-coordinate under the cursor in screen (canvas) space\n    :$sy: y-coordinate under the cursor in screen (canvas) space\n    :$color: color data from data source, with the syntax:\n        ``$color[options]:field_name``. The available options\n        are: 'hex' (to display the color as a hex value), and\n        'swatch' to also display a small color swatch.\n\n    Field names that begin with ``@`` are associated with columns in a\n    ``ColumnDataSource``. For instance the field name ``\"@price\"`` will\n    display values from the ``\"price\"`` column whenever a hover is triggered.\n    If the hover is for the 17th glyph, then the hover tooltip will\n    correspondingly display the 17th price value.\n\n    Note that if a column name contains spaces, the it must be supplied by\n    surrounding it in curly braces, e.g. ``@{adjusted close}`` will display\n    values from a column named ``\"adjusted close\"``.\n\n    Sometimes (especially with stacked charts) it is desirable to allow the\n    name of the column be specified indirectly. The field name ``@$name`` is\n    distinguished in that it will look up the ``name`` field on the hovered\n    glyph renderer, and use that value as the column name. For instance, if\n    a user hovers with the name ``\"US East\"``, then ``@$name`` is equivalent to\n    ``@{US East}``.\n\n    By default, values for fields (e.g. ``@foo``) are displayed in a basic\n    numeric format. However it is possible to control the formatting of values\n    more precisely. Fields can be modified by appending a format specified to\n    the end in curly braces. Some examples are below.\n\n    .. code-block:: python\n\n        \"@foo{0,0.000}\"    # formats 10000.1234 as: 10,000.123\n\n        \"@foo{(.00)}\"      # formats -10000.1234 as: (10000.123)\n\n        \"@foo{($ 0.00 a)}\" # formats 1230974 as: $ 1.23 m\n\n    Specifying a format ``{safe}`` after a field name will override automatic\n    escaping of the tooltip data source. Any HTML tags in the data tags will\n    be rendered as HTML in the resulting HoverTool output. See\n    :ref:`custom_hover_tooltip` for a more detailed example.\n\n    ``None`` is also a valid value for tooltips. This turns off the\n    rendering of tooltips. This is mostly useful when supplying other\n    actions on hover via the callback property.\n\n    .. note::\n        The tooltips attribute can also be configured with a mapping type,\n        e.g. ``dict`` or ``OrderedDict``. However, if a ``dict`` is used,\n        the visual presentation order is unspecified.",
        "default": [
          [
            "index",
            "$index"
          ],
          [
            "data (x, y)",
            "($x, $y)"
          ],
          [
            "screen (x, y)",
            "($sx, $sy)"
          ]
        ]
      },
      {
        "name": "attachment",
        "type": "Enum('horizontal', 'vertical', 'left', 'right', 'above', 'below')",
        "desc": "Whether the tooltip should be displayed to the left or right of the cursor\n    position or above or below it, or if it should be automatically placed\n    in the horizontal or vertical dimension.",
        "default": "horizontal"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "formatters",
        "type": "Dict(String, Either(Enum('numeral', 'datetime', 'printf'), Instance(CustomJSHover)))",
        "desc": "Specify the formatting scheme for data source columns, e.g.\n\n    .. code-block:: python\n\n        tool.formatters = {\"@date\": \"datetime\"}\n\n    will cause format specifications for the \"date\" column to be interpreted\n    according to the \"datetime\" formatting scheme. The following schemes are\n    available:\n\n    :``\"numeral\"``:\n        Provides a wide variety of formats for numbers, currency, bytes, times,\n        and percentages. The full set of formats can be found in the\n        |NumeralTickFormatter| reference documentation.\n\n    :``\"datetime\"``:\n        Provides formats for date and time values. The full set of formats is\n        listed in the |DatetimeTickFormatter| reference documentation.\n\n    :``\"printf\"``:\n        Provides formats similar to C-style \"printf\" type specifiers. See the\n        |PrintfTickFormatter| reference documentation for complete details.\n\n    If no formatter is specified for a column name, the default ``\"numeral\"``\n    formatter is assumed.\n\n    .. |NumeralTickFormatter| replace:: :class:`~bokeh.models.formatters.NumeralTickFormatter`\n    .. |DatetimeTickFormatter| replace:: :class:`~bokeh.models.formatters.DatetimeTickFormatter`\n    .. |PrintfTickFormatter| replace:: :class:`~bokeh.models.formatters.PrintfTickFormatter`",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "names",
        "type": "List(String)",
        "desc": "A list of names to query for. If set, only renderers that have a matching\n    value for their ``name`` attribute will be used.",
        "default": []
      },
      {
        "name": "point_policy",
        "type": "Enum('snap_to_data', 'follow_mouse', 'none')",
        "desc": "Whether the tooltip position should snap to the \"center\" (or other anchor)\n    position of the associated glyph, or always follow the current mouse cursor\n    position.",
        "default": "snap_to_data"
      },
      {
        "name": "anchor",
        "type": "Enum('top_left', 'top_center', 'top_right', 'center_left', 'center', 'center_right', 'bottom_left', 'bottom_center', 'bottom_right')",
        "desc": "If point policy is set to `\"snap_to_data\"`, `anchor` defines the attachment\n    point of a tooltip. The default is to attach to the center of a glyph.",
        "default": "center"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "callback",
        "type": "Instance(Callback)",
        "desc": "A callback to run in the browser whenever the input's value changes. The\n    ``cb_data`` parameter that is available to the Callback code will contain two\n    ``HoverTool`` specific fields:\n\n    :index: object containing the indices of the hovered points in the data source\n    :geometry: object containing the coordinates of the hover cursor",
        "default": null
      },
      {
        "name": "muted_policy",
        "type": "Enum('show', 'ignore')",
        "desc": "Whether to avoid showing tooltips on muted glyphs.",
        "default": "show"
      },
      {
        "name": "show_arrow",
        "type": "Bool",
        "desc": "Whether tooltip's arrow should be shown.",
        "default": true
      },
      {
        "name": "toggleable",
        "type": "Bool",
        "desc": "Whether an on/off toggle button should appear in the toolbar for this\n    inspection tool. If ``False``, the viewers of a plot will not be able to\n    toggle the inspector on or off using the toolbar.",
        "default": true
      },
      {
        "name": "renderers",
        "type": "Either(Auto, List(Instance(Renderer)))",
        "desc": "An explicit list of renderers to hit test against. If unset, defaults to\n    all renderers on a plot.",
        "default": "auto"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Image": {
    "name": "Image",
    "bases": [
      "bokeh.models.glyph.XYGlyph"
    ],
    "desc": "Render images given as scalar data together with a color mapper.\n\n    In addition to the defined model properties, ``Image`` also can accept\n    a keyword argument ``palette`` in place of an explicit ``color_mapper``.\n    The value should be a list of colors, or the name of one of the built-in\n    palettes in ``bokeh.palettes``. This palette will be used to automatically\n    construct a ``ColorMapper`` model for the ``color_mapper`` property.\n\n    If both ``palette`` and ``color_mapper`` are passed, a ``ValueError``\n    exception will be raised. If neither is passed, then the ``Greys9``\n    palette will be used as a default.",
    "proto": "{\"color_mapper\": {\"id\": \"3523\"}, \"dh\": null, \"dilate\": false, \"dw\": null, \"global_alpha\": 1.0, \"id\": \"3522\", \"image\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "dw",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The widths of the plot regions that the images will occupy.\n\n    .. note::\n        This is not the number of pixels that an image is wide.\n        That number is fixed by the image itself.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "dh_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "dw_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "global_alpha",
        "type": "Float",
        "desc": "An overall opacity that each image is rendered with (in addition\n    to any alpha values applied explicitly in a color mapper).",
        "default": 1.0
      },
      {
        "name": "color_mapper",
        "type": "Instance(ColorMapper)",
        "desc": "A ``ColorMapper`` to use to map the scalar data from ``image``\n    into RGBA values for display.\n\n    .. note::\n        The color mapping step happens on the client.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "dh",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The height of the plot region that the image will occupy.\n\n    .. note::\n        This is not the number of pixels that an image is tall.\n        That number is fixed by the image itself.",
        "default": null
      },
      {
        "name": "image",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The arrays of scalar data for the images to be colormapped.",
        "default": null
      },
      {
        "name": "dilate",
        "type": "Bool",
        "desc": "Whether to always round fractional pixel locations in such a way\n    as to make the images bigger.\n\n    This setting may be useful if pixel rounding errors are causing\n    images to have a gap between them, when they should appear flush.",
        "default": false
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates to locate the image anchors.",
        "default": null
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates to locate the image anchors.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ImageRGBA": {
    "name": "ImageRGBA",
    "bases": [
      "bokeh.models.glyph.XYGlyph"
    ],
    "desc": "Render images given as RGBA data.",
    "proto": "{\"dh\": null, \"dilate\": false, \"dw\": null, \"global_alpha\": 1.0, \"id\": \"3554\", \"image\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "dw",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The widths of the plot regions that the images will occupy.\n\n    .. note::\n        This is not the number of pixels that an image is wide.\n        That number is fixed by the image itself.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "dh_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "dw_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "global_alpha",
        "type": "Float",
        "desc": "An overall opacity that each image is rendered with (in addition\n    to any inherent alpha values in the image itself).",
        "default": 1.0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "dh",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The height of the plot region that the image will occupy.\n\n    .. note::\n        This is not the number of pixels that an image is tall.\n        That number is fixed by the image itself.",
        "default": null
      },
      {
        "name": "image",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The arrays of RGBA data for the images.",
        "default": null
      },
      {
        "name": "dilate",
        "type": "Bool",
        "desc": "Whether to always round fractional pixel locations in such a way\n    as to make the images bigger.\n\n    This setting may be useful if pixel rounding errors are causing\n    images to have a gap between them, when they should appear flush.",
        "default": false
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates to locate the image anchors.",
        "default": null
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates to locate the image anchors.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ImageURL": {
    "name": "ImageURL",
    "bases": [
      "bokeh.models.glyph.XYGlyph"
    ],
    "desc": "Render images loaded from given URLs.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/ImageURL.py\n        :source-position: below",
    "proto": "{\"anchor\": \"top_left\", \"angle\": {\"units\": \"rad\", \"value\": 0}, \"dilate\": false, \"global_alpha\": 1.0, \"h\": null, \"id\": \"3569\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"retry_attempts\": 0, \"retry_timeout\": 0, \"subscribed_events\": [], \"tags\": [], \"url\": null, \"w\": null, \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "retry_attempts",
        "type": "Int",
        "desc": "Number of attempts to retry loading the images from the specified URL.\n    Default is zero.",
        "default": 0
      },
      {
        "name": "h",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The height of the plot region that the image will occupy in data space.\n\n    The default value is ``None``, in which case the image will be displayed\n    at its actual image size (regardless of the units specified here).",
        "default": null
      },
      {
        "name": "h_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "anchor",
        "type": "Enum('top_left', 'top_center', 'top_right', 'center_left', 'center', 'center_right', 'bottom_left', 'bottom_center', 'bottom_right')",
        "desc": "What position of the image should be anchored at the `x`, `y`\n    coordinates.",
        "default": "top_left"
      },
      {
        "name": "w_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates to locate the image anchors.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "url",
        "type": "StringSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), List(String))), List(String))",
        "desc": "The URLs to retrieve images from.\n\n    .. note::\n        The actual retrieving and loading of the images happens on\n        the client.",
        "default": null
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the images, as measured from the horizontal.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "global_alpha",
        "type": "Float",
        "desc": "An overall opacity that each image is rendered with (in addition\n    to any inherent alpha values in the image itself).",
        "default": 1.0
      },
      {
        "name": "retry_timeout",
        "type": "Int",
        "desc": "Timeout (in ms) between retry attempts to load the image from the\n    specified URL. Default is zero ms.",
        "default": 0
      },
      {
        "name": "w",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The width of the plot region that the image will occupy in data space.\n\n    The default value is ``None``, in which case the image will be displayed\n    at its actual image size (regardless of the units specified here).",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "dilate",
        "type": "Bool",
        "desc": "Whether to always round fractional pixel locations in such a way\n    as to make the images bigger.\n\n    This setting may be useful if pixel rounding errors are causing\n    images to have a gap between them, when they should appear flush.",
        "default": false
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates to locate the image anchors.",
        "default": null
      }
    ]
  },
  "ImageURLTexture": {
    "name": "ImageURLTexture",
    "bases": [
      "bokeh.models.textures.Texture"
    ],
    "desc": "",
    "proto": "{\"id\": \"3589\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"repetition\": \"repeat\", \"subscribed_events\": [], \"tags\": [], \"url\": null}",
    "props": [
      {
        "name": "url",
        "type": "String",
        "desc": "",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "repetition",
        "type": "Enum('repeat', 'repeat_x', 'repeat_y', 'no_repeat')",
        "desc": "",
        "default": "repeat"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "IndexFilter": {
    "name": "IndexFilter",
    "bases": [
      "bokeh.models.filters.Filter"
    ],
    "desc": "An ``IndexFilter`` filters data by returning the subset of data at a given set of indices.",
    "proto": "{\"filter\": null, \"id\": \"3597\", \"indices\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "indices",
        "type": "Seq(Int)",
        "desc": "A list of integer indices representing the subset of data to select.",
        "default": null
      },
      {
        "name": "filter",
        "type": "Either(Seq(Int), Seq(Bool))",
        "desc": "A list that can be either integer indices or booleans representing a row-wise subset of data.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "InputWidget": {
    "name": "InputWidget",
    "bases": [
      "bokeh.models.widgets.widget.Widget"
    ],
    "desc": "Abstract base class for input widgets.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"3605\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Inspection": {
    "name": "Inspection",
    "bases": [
      "bokeh.models.tools.Gesture"
    ],
    "desc": "A base class for tools that perform \"inspections\", e.g. ``HoverTool``.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"3630\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"toggleable\": true}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "toggleable",
        "type": "Bool",
        "desc": "Whether an on/off toggle button should appear in the toolbar for this\n    inspection tool. If ``False``, the viewers of a plot will not be able to\n    toggle the inspector on or off using the toolbar.",
        "default": true
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "IntEditor": {
    "name": "IntEditor",
    "bases": [
      "bokeh.models.widgets.tables.CellEditor"
    ],
    "desc": "Spinner-based integer cell editor.",
    "proto": "{\"id\": \"3637\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"step\": 1, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "step",
        "type": "Int",
        "desc": "The major step value.",
        "default": 1
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Interpolator": {
    "name": "Interpolator",
    "bases": [
      "bokeh.models.transforms.Transform"
    ],
    "desc": "Base class for interpolator transforms.\n\n    Interpolators return the value of a function which has been evaluated\n    between specified (x, y) pairs of data.  As an example, if two control\n    point pairs were provided to the interpolator, a linear interpolaction\n    at a specific value of 'x' would result in the value of 'y' which existed\n    on the line connecting the two control points.\n\n    The control point pairs for the interpolators can be specified through either\n\n    * A literal sequence of values:\n\n    .. code-block:: python\n\n        interp = Interpolator(x=[1, 2, 3, 4, 5], y=[2, 5, 10, 12, 16])\n\n    * or a pair of columns defined in a ``ColumnDataSource`` object:\n\n    .. code-block:: python\n\n        interp = Interpolator(x=\"year\", y=\"earnings\", data=jewlery_prices))\n\n\n    This is the base class and is not intended to end use.  Please see the\n    documentation for the final derived classes (``Jitter``, ``LineraInterpolator``,\n    ``StepInterpolator``) for more information on their specific methods of\n    interpolation.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"clip\": true, \"data\": null, \"id\": \"3644\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "clip",
        "type": "Bool",
        "desc": "Determine if the interpolation should clip the result to include only values inside its predefined range.\n    If this is set to False, it will return the most value of the closest point.",
        "default": true
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "data",
        "type": "Instance(ColumnarDataSource)",
        "desc": "Data which defines the source for the named columns if a string is passed to either the ``x`` or ``y`` parameters.",
        "default": null
      },
      {
        "name": "y",
        "type": "Either(String, Seq(Float))",
        "desc": "Dependant coordinate denoting the value of a point at a location.",
        "default": null
      },
      {
        "name": "x",
        "type": "Either(String, Seq(Float))",
        "desc": "Independent coordinate denoting the location of a point.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "IntersectRenderers": {
    "name": "IntersectRenderers",
    "bases": [
      "bokeh.models.selections.SelectionPolicy"
    ],
    "desc": "When a data source is shared between multiple renderers, a row in the data\n    source will only be selected if that point for each renderer is selected. The\n    selection is made from the intersection of hit test results from all renderers.",
    "proto": "{\"id\": \"3654\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "InvertedTriangle": {
    "name": "InvertedTriangle",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render upside-down triangle markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/InvertedTriangle.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"3660\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "Jitter": {
    "name": "Jitter",
    "bases": [
      "bokeh.models.transforms.Transform"
    ],
    "desc": "Apply either a uniform or normally sampled random jitter to data.",
    "proto": "{\"distribution\": \"uniform\", \"id\": \"3680\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mean\": 0, \"name\": null, \"range\": null, \"subscribed_events\": [], \"tags\": [], \"width\": 1}",
    "props": [
      {
        "name": "mean",
        "type": "Float",
        "desc": "The central value for the random sample",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "range",
        "type": "Instance(Range)",
        "desc": "When applying Jitter to Categorical data values, the corresponding\n    ``FactorRange`` must be supplied as the ``range`` property.",
        "default": null
      },
      {
        "name": "distribution",
        "type": "Enum('uniform', 'normal')",
        "desc": "The random distribution upon which to pull the random scatter",
        "default": "uniform"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width",
        "type": "Float",
        "desc": "The width (absolute for uniform distribution and sigma for the normal\n    distribution) of the random sample.",
        "default": 1
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Label": {
    "name": "Label",
    "bases": [
      "bokeh.models.annotations.TextAnnotation"
    ],
    "desc": "Render a single text label as an annotation.\n\n    ``Label`` will render a single text label at given ``x`` and ``y``\n    coordinates, which can be in either screen (pixel) space, or data (axis\n    range) space.\n\n    The label can also be configured with a screen space offset from ``x`` and\n    ``y``, by using the ``x_offset`` and ``y_offset`` properties.\n\n    Additionally, the label can be rotated with the ``angle`` property.\n\n    There are also standard text, fill, and line properties to control the\n    appearance of the text, its background, as well as the rectangular bounding\n    box border.\n\n    See :ref:`userguide_plotting_labels` for information on plotting labels.",
    "proto": "{\"angle\": 0, \"angle_units\": \"rad\", \"background_fill_alpha\": 1.0, \"background_fill_color\": null, \"border_line_alpha\": 1.0, \"border_line_cap\": \"butt\", \"border_line_color\": null, \"border_line_dash\": [], \"border_line_dash_offset\": 0, \"border_line_join\": \"bevel\", \"border_line_width\": 1, \"id\": \"3690\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"name\": null, \"render_mode\": \"canvas\", \"subscribed_events\": [], \"tags\": [], \"text\": null, \"text_align\": \"left\", \"text_alpha\": 1.0, \"text_baseline\": \"bottom\", \"text_color\": \"#444444\", \"text_font\": \"helvetica\", \"text_font_size\": \"16px\", \"text_font_style\": \"normal\", \"text_line_height\": 1.2, \"visible\": true, \"x\": null, \"x_offset\": 0, \"x_range_name\": \"default\", \"x_units\": \"data\", \"y\": null, \"y_offset\": 0, \"y_range_name\": \"default\", \"y_units\": \"data\"}",
    "props": [
      {
        "name": "border_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the text bounding box.",
        "default": "butt"
      },
      {
        "name": "text_line_height",
        "type": "Float",
        "desc": "The text line height values for the text.",
        "default": 1.2
      },
      {
        "name": "y_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the y attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align values for the text.",
        "default": "left"
      },
      {
        "name": "text_font_size",
        "type": "FontSize",
        "desc": "The text font size values for the text.",
        "default": "16px"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen location when\n    rendering an annotation on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "border_line_width",
        "type": "Float",
        "desc": "The line width values for the text bounding box.",
        "default": 1
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline values for the text.",
        "default": "bottom"
      },
      {
        "name": "text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style values for the text.",
        "default": "normal"
      },
      {
        "name": "text_alpha",
        "type": "Percent",
        "desc": "The text alpha values for the text.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "Acceptable values for units are ``\"rad\"`` and ``\"deg\"``",
        "default": "rad"
      },
      {
        "name": "border_line_color",
        "type": "Color",
        "desc": "The line color values for the text bounding box.",
        "default": null
      },
      {
        "name": "y",
        "type": "Float",
        "desc": "The y-coordinate in screen coordinates to locate the text anchors.\n\n    Datetime values are also accepted, but note that they are immediately\n    converted to milliseconds-since-epoch.",
        "default": null
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen location when\n    rendering an annotation on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "y_offset",
        "type": "Float",
        "desc": "Offset value to apply to the y-coordinate.\n\n    This is useful, for instance, if it is desired to \"float\" text a fixed\n    distance in screen units from a given data position.",
        "default": 0
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "angle",
        "type": "Angle",
        "desc": "The angle to rotate the text, as measured from the horizontal.\n\n    .. warning::\n        The center of rotation for canvas and css render_modes is different.\n        For `render_mode=\"canvas\"` the label is rotated from the top-left\n        corner of the annotation, while for `render_mode=\"css\"` the annotation\n        is rotated around it's center.",
        "default": 0
      },
      {
        "name": "x_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the x attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "background_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the text bounding box.",
        "default": 1.0
      },
      {
        "name": "border_line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the text bounding box.",
        "default": []
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "border_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the text bounding box.",
        "default": 0
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "border_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the text bounding box.",
        "default": "bevel"
      },
      {
        "name": "text",
        "type": "String",
        "desc": "The text value to render.",
        "default": null
      },
      {
        "name": "text_font",
        "type": "String",
        "desc": "The text font values for the text.",
        "default": "helvetica"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "text_color",
        "type": "Color",
        "desc": "The text color values for the text.",
        "default": "#444444"
      },
      {
        "name": "render_mode",
        "type": "Enum('canvas', 'css')",
        "desc": "Specifies whether the text is rendered as a canvas element or as a\n    CSS element overlaid on the canvas. The default mode is \"canvas\".\n\n    .. note::\n        The CSS labels won't be present in the output using the \"save\" tool.\n\n    .. warning::\n        Not all visual styling properties are supported if the render_mode is\n        set to \"css\". The border_line_dash property isn't fully supported and\n        border_line_dash_offset isn't supported at all. Setting text_alpha will\n        modify the opacity of the entire background box and border in addition\n        to the text. Finally, clipping Label annotations inside of the plot\n        area isn't supported in \"css\" mode.",
        "default": "canvas"
      },
      {
        "name": "x_offset",
        "type": "Float",
        "desc": "Offset value to apply to the x-coordinate.\n\n    This is useful, for instance, if it is desired to \"float\" text a fixed\n    distance in screen units from a given data position.",
        "default": 0
      },
      {
        "name": "background_fill_color",
        "type": "Color",
        "desc": "The fill color values for the text bounding box.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "border_line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the text bounding box.",
        "default": 1.0
      },
      {
        "name": "x",
        "type": "Float",
        "desc": "The x-coordinate in screen coordinates to locate the text anchors.\n\n    Datetime values are also accepted, but note that they are immediately\n    converted to milliseconds-since-epoch.",
        "default": null
      }
    ]
  },
  "LabelSet": {
    "name": "LabelSet",
    "bases": [
      "bokeh.models.annotations.TextAnnotation"
    ],
    "desc": "Render multiple text labels as annotations.\n\n    ``LabelSet`` will render multiple text labels at given ``x`` and ``y``\n    coordinates, which can be in either screen (pixel) space, or data (axis\n    range) space. In this case (as opposed to the single ``Label`` model),\n    ``x`` and ``y`` can also be the name of a column from a\n    :class:`~bokeh.models.sources.ColumnDataSource`, in which case the labels\n    will be \"vectorized\" using coordinate values from the specified columns.\n\n    The label can also be configured with a screen space offset from ``x`` and\n    ``y``, by using the ``x_offset`` and ``y_offset`` properties. These offsets\n    may be vectorized by giving the name of a data source column.\n\n    Additionally, the label can be rotated with the ``angle`` property (which\n    may also be a column name.)\n\n    There are also standard text, fill, and line properties to control the\n    appearance of the text, its background, as well as the rectangular bounding\n    box border.\n\n    The data source is provided by setting the ``source`` property.",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0}, \"background_fill_alpha\": {\"value\": 1.0}, \"background_fill_color\": {\"value\": null}, \"border_line_alpha\": {\"value\": 1.0}, \"border_line_cap\": \"butt\", \"border_line_color\": {\"value\": null}, \"border_line_dash\": [], \"border_line_dash_offset\": 0, \"border_line_join\": \"bevel\", \"border_line_width\": {\"value\": 1}, \"id\": \"3727\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"name\": null, \"render_mode\": \"canvas\", \"source\": {\"id\": \"3728\"}, \"subscribed_events\": [], \"tags\": [], \"text\": {\"field\": \"text\"}, \"text_align\": \"left\", \"text_alpha\": {\"value\": 1.0}, \"text_baseline\": \"bottom\", \"text_color\": {\"value\": \"#444444\"}, \"text_font\": \"helvetica\", \"text_font_size\": {\"value\": \"16px\"}, \"text_font_style\": \"normal\", \"text_line_height\": 1.2, \"visible\": true, \"x\": null, \"x_offset\": {\"value\": 0}, \"x_range_name\": \"default\", \"x_units\": \"data\", \"y\": null, \"y_offset\": {\"value\": 0}, \"y_range_name\": \"default\", \"y_units\": \"data\"}",
    "props": [
      {
        "name": "border_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the text bounding box.",
        "default": "butt"
      },
      {
        "name": "text_line_height",
        "type": "Float",
        "desc": "The text line height values for the text.",
        "default": 1.2
      },
      {
        "name": "y_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the ``ys`` attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align values for the text.",
        "default": "left"
      },
      {
        "name": "text_font_size",
        "type": "FontSizeSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), FontSize)), FontSize)",
        "desc": "The text font size values for the text.",
        "default": {
          "value": "16px"
        }
      },
      {
        "name": "source",
        "type": "Instance(DataSource)",
        "desc": "Local data source to use when rendering annotations on the plot.",
        "default": "{\"data\": {}, \"id\": \"3735\"}"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "border_line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the text bounding box.",
        "default": 1
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline values for the text.",
        "default": "bottom"
      },
      {
        "name": "text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style values for the text.",
        "default": "normal"
      },
      {
        "name": "text_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The text alpha values for the text.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "border_line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the text bounding box.",
        "default": null
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates to locate the text anchors.",
        "default": null
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "y_offset",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "Offset values to apply to the y-coordinates.\n\n    This is useful, for instance, if it is desired to \"float\" text a fixed\n    distance in screen units from a given data position.",
        "default": 0
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the text, as measured from the horizontal.\n\n    .. warning::\n        The center of rotation for canvas and css render_modes is different.\n        For `render_mode=\"canvas\"` the label is rotated from the top-left\n        corner of the annotation, while for `render_mode=\"css\"` the annotation\n        is rotated around it's center.",
        "default": 0
      },
      {
        "name": "x_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the ``xs`` attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "background_fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the text bounding box.",
        "default": 1.0
      },
      {
        "name": "border_line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the text bounding box.",
        "default": []
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "border_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the text bounding box.",
        "default": 0
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "border_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the text bounding box.",
        "default": "bevel"
      },
      {
        "name": "text",
        "type": "StringSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), List(String))), List(String))",
        "desc": "The text values to render.",
        "default": "text"
      },
      {
        "name": "text_font",
        "type": "String",
        "desc": "The text font values for the text.",
        "default": "helvetica"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "text_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The text color values for the text.",
        "default": "#444444"
      },
      {
        "name": "render_mode",
        "type": "Enum('canvas', 'css')",
        "desc": "Specifies whether the text is rendered as a canvas element or as a\n    CSS element overlaid on the canvas. The default mode is \"canvas\".\n\n    .. note::\n        The CSS labels won't be present in the output using the \"save\" tool.\n\n    .. warning::\n        Not all visual styling properties are supported if the render_mode is\n        set to \"css\". The border_line_dash property isn't fully supported and\n        border_line_dash_offset isn't supported at all. Setting text_alpha will\n        modify the opacity of the entire background box and border in addition\n        to the text. Finally, clipping Label annotations inside of the plot\n        area isn't supported in \"css\" mode.",
        "default": "canvas"
      },
      {
        "name": "x_offset",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "Offset values to apply to the x-coordinates.\n\n    This is useful, for instance, if it is desired to \"float\" text a fixed\n    distance in screen units from a given data position.",
        "default": 0
      },
      {
        "name": "background_fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the text bounding box.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "border_line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the text bounding box.",
        "default": 1.0
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates to locate the text anchors.",
        "default": null
      }
    ]
  },
  "LassoSelectTool": {
    "name": "LassoSelectTool",
    "bases": [
      "bokeh.models.tools.Drag",
      "bokeh.models.tools.SelectTool"
    ],
    "desc": "*toolbar icon*: |lasso_select_icon|\n\n    The lasso selection tool allows users to make selections on a Plot by\n    indicating a free-drawn \"lasso\" region by dragging the mouse or a finger\n    over the plot region. The end of the drag event indicates the selection\n    region is ready.\n\n    See :ref:`userguide_styling_selected_unselected_glyphs` for information\n    on styling selected and unselected glyphs.\n\n    .. note::\n        Selections can be comprised of multiple regions, even those made by\n        different selection tools. Hold down the <<shift>> key while making a\n        selection to append the new selection to any previous selection that\n        might exist.\n\n    .. |lasso_select_icon| image:: /_images/icons/LassoSelect.png\n        :height: 24px",
    "proto": "{\"id\": \"3767\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mode\": \"replace\", \"name\": null, \"names\": [], \"overlay\": {\"id\": \"3768\"}, \"renderers\": \"auto\", \"select_every_mousemove\": true, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('replace', 'append', 'intersect', 'subtract')",
        "desc": "Defines what should happen when a new selection is made. The default\n    is to replace the existing selection. Other options are to append to\n    the selection, intersect with it or subtract from it.",
        "default": "replace"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "select_every_mousemove",
        "type": "Bool",
        "desc": "Whether a selection computation should happen on every mouse event, or only\n    once, when the selection region is completed.",
        "default": true
      },
      {
        "name": "names",
        "type": "List(String)",
        "desc": "A list of names to query for. If set, only renderers that have a matching\n    value for their ``name`` attribute will be used.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "overlay",
        "type": "Instance(PolyAnnotation)",
        "desc": "A shaded annotation drawn to indicate the selection region.",
        "default": "{\"fill_alpha\": 0.5, \"fill_color\": \"lightgrey\", \"id\": \"3776\", \"level\": \"overlay\", \"line_alpha\": 1.0, \"line_color\": \"black\", \"line_dash\": [4, 4], \"line_width\": 2, \"xs_units\": \"screen\", \"ys_units\": \"screen\"}"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "renderers",
        "type": "Either(Auto, List(Instance(Renderer)))",
        "desc": "An explicit list of renderers to hit test against. If unset, defaults to\n    all renderers on a plot.",
        "default": "auto"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LayoutDOM": {
    "name": "LayoutDOM",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "The base class for layoutable components.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"3780\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "LayoutProvider": {
    "name": "LayoutProvider",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": ".. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"3802\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Legend": {
    "name": "Legend",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render informational legends for a plot.\n\n    See :ref:`userguide_plotting_legends` for information on plotting legends.",
    "proto": "{\"background_fill_alpha\": 0.95, \"background_fill_color\": \"#ffffff\", \"border_line_alpha\": 0.5, \"border_line_cap\": \"butt\", \"border_line_color\": \"#e5e5e5\", \"border_line_dash\": [], \"border_line_dash_offset\": 0, \"border_line_join\": \"bevel\", \"border_line_width\": 1, \"click_policy\": \"none\", \"glyph_height\": 20, \"glyph_width\": 20, \"id\": \"3808\", \"inactive_fill_alpha\": 0.7, \"inactive_fill_color\": \"white\", \"items\": [], \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"label_height\": 20, \"label_standoff\": 5, \"label_text_align\": \"left\", \"label_text_alpha\": 1.0, \"label_text_baseline\": \"middle\", \"label_text_color\": \"#444444\", \"label_text_font\": \"helvetica\", \"label_text_font_size\": \"13px\", \"label_text_font_style\": \"normal\", \"label_text_line_height\": 1.2, \"label_width\": 20, \"level\": \"annotation\", \"location\": \"top_right\", \"margin\": 10, \"name\": null, \"orientation\": \"vertical\", \"padding\": 10, \"spacing\": 3, \"subscribed_events\": [], \"tags\": [], \"title\": null, \"title_standoff\": 5, \"title_text_align\": \"left\", \"title_text_alpha\": 1.0, \"title_text_baseline\": \"bottom\", \"title_text_color\": \"#444444\", \"title_text_font\": \"helvetica\", \"title_text_font_size\": \"13px\", \"title_text_font_style\": \"italic\", \"title_text_line_height\": 1.2, \"visible\": true}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Whether the legend entries should be placed vertically or horizontally\n    when they are drawn.",
        "default": "vertical"
      },
      {
        "name": "title_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style values for the title text.",
        "default": "italic"
      },
      {
        "name": "items",
        "type": "List(Instance(LegendItem))",
        "desc": "A list of :class:`~bokeh.model.annotations.LegendItem` instances to be\n    rendered in the legend.\n\n    This can be specified explicitly, for instance:\n\n    .. code-block:: python\n\n        legend = Legend(items=[\n            LegendItem(label=\"sin(x)\"   , renderers=[r0, r1]),\n            LegendItem(label=\"2*sin(x)\" , renderers=[r2]),\n            LegendItem(label=\"3*sin(x)\" , renderers=[r3, r4])\n        ])\n\n    But as a convenience, can also be given more compactly as a list of tuples:\n\n    .. code-block:: python\n\n        legend = Legend(items=[\n            (\"sin(x)\"   , [r0, r1]),\n            (\"2*sin(x)\" , [r2]),\n            (\"3*sin(x)\" , [r3, r4])\n        ])\n\n    where each tuple is of the form: *(label, renderers)*.",
        "default": []
      },
      {
        "name": "glyph_width",
        "type": "Int",
        "desc": "The width (in pixels) that the rendered legend glyph should occupy.",
        "default": 20
      },
      {
        "name": "title_text_color",
        "type": "Color",
        "desc": "The text color values for the title text.",
        "default": "#444444"
      },
      {
        "name": "label_height",
        "type": "Int",
        "desc": "The minimum height (in pixels) of the area that legend labels should occupy.",
        "default": 20
      },
      {
        "name": "title_text_font_size",
        "type": "FontSize",
        "desc": "The text font size values for the title text.",
        "default": "13px"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size for the legend labels.",
        "default": "13px"
      },
      {
        "name": "border_line_width",
        "type": "Float",
        "desc": "The line width for the legend border outline.",
        "default": 1
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "glyph_height",
        "type": "Int",
        "desc": "The height (in pixels) that the rendered legend glyph should occupy.",
        "default": 20
      },
      {
        "name": "title_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline values for the title text.",
        "default": "bottom"
      },
      {
        "name": "border_line_color",
        "type": "Color",
        "desc": "The line color for the legend border outline.",
        "default": "#e5e5e5"
      },
      {
        "name": "title_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align values for the title text.",
        "default": "left"
      },
      {
        "name": "label_text_line_height",
        "type": "Float",
        "desc": "The text line height for the legend labels.",
        "default": 1.2
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "label_width",
        "type": "Int",
        "desc": "The minimum width (in pixels) of the area that legend labels should occupy.",
        "default": 20
      },
      {
        "name": "click_policy",
        "type": "Enum('none', 'hide', 'mute')",
        "desc": "Defines what happens when a lengend's item is clicked.",
        "default": "none"
      },
      {
        "name": "background_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha for the legend background style.",
        "default": 0.95
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "title_standoff",
        "type": "Int",
        "desc": "The distance (in pixels) to separate the title from the legend.",
        "default": 5
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "spacing",
        "type": "Int",
        "desc": "Amount of spacing (in pixels) between legend entries.",
        "default": 3
      },
      {
        "name": "border_line_alpha",
        "type": "Percent",
        "desc": "The line alpha for the legend border outline.",
        "default": 0.5
      },
      {
        "name": "padding",
        "type": "Int",
        "desc": "Amount of padding around the contents of the legend. Only applicable when\n    when border is visible, otherwise collapses to 0.",
        "default": 10
      },
      {
        "name": "margin",
        "type": "Int",
        "desc": "Amount of margin around the legend.",
        "default": 10
      },
      {
        "name": "border_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap for the legend border outline.",
        "default": "butt"
      },
      {
        "name": "title_text_font",
        "type": "String",
        "desc": "The text font values for the title text.",
        "default": "helvetica"
      },
      {
        "name": "label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha for the legend labels.",
        "default": 1.0
      },
      {
        "name": "label_text_color",
        "type": "Color",
        "desc": "The text color for the legend labels.",
        "default": "#444444"
      },
      {
        "name": "title_text_alpha",
        "type": "Percent",
        "desc": "The text alpha values for the title text.",
        "default": 1.0
      },
      {
        "name": "label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style for the legend labels.",
        "default": "normal"
      },
      {
        "name": "label_standoff",
        "type": "Int",
        "desc": "The distance (in pixels) to separate the label from its associated glyph.",
        "default": 5
      },
      {
        "name": "title",
        "type": "String",
        "desc": "The title text to render.",
        "default": null
      },
      {
        "name": "label_text_font",
        "type": "String",
        "desc": "The text font for the legend labels.",
        "default": "helvetica"
      },
      {
        "name": "location",
        "type": "Either(Enum('top_left', 'top_center', 'top_right', 'center_left', 'center', 'center_right', 'bottom_left', 'bottom_center', 'bottom_right'), Tuple(Float, Float))",
        "desc": "The location where the legend should draw itself. It's either one of\n    ``bokeh.core.enums.LegendLocation``'s enumerated values, or a ``(x, y)``\n    tuple indicating an absolute location absolute location in screen\n    coordinates (pixels from the bottom-left corner).",
        "default": "top_right"
      },
      {
        "name": "title_text_line_height",
        "type": "Float",
        "desc": "The text line height values for the title text.",
        "default": 1.2
      },
      {
        "name": "border_line_dash",
        "type": "DashPattern",
        "desc": "The line dash for the legend border outline.",
        "default": []
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "border_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset for the legend border outline.",
        "default": 0
      },
      {
        "name": "border_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join for the legend border outline.",
        "default": "bevel"
      },
      {
        "name": "inactive_fill_color",
        "type": "Color",
        "desc": "The fill color for the legend item style when inactive. These control an overlay\n    on the item that can be used to obscure it when the corresponding glyph\n    is inactive (e.g. by making it semi-transparent).",
        "default": "white"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline for the legend labels.",
        "default": "middle"
      },
      {
        "name": "inactive_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha for the legend item style when inactive. These control an overlay\n    on the item that can be used to obscure it when the corresponding glyph\n    is inactive (e.g. by making it semi-transparent).",
        "default": 0.7
      },
      {
        "name": "background_fill_color",
        "type": "Color",
        "desc": "The fill color for the legend background style.",
        "default": "#ffffff"
      },
      {
        "name": "label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align for the legend labels.",
        "default": "left"
      }
    ]
  },
  "LegendItem": {
    "name": "LegendItem",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "",
    "proto": "{\"id\": \"3857\", \"index\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"label\": null, \"name\": null, \"renderers\": [], \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "index",
        "type": "Int",
        "desc": "The column data index to use for drawing the representative items.\n\n    If None (the default), then Bokeh will automatically choose an index to\n    use. If the label does not refer to a data column name, this is typically\n    the first data point in the data source. Otherwise, if the label does\n    refer to a column name, the legend will have \"groupby\" behavior, and will\n    choose and display representative points from every \"group\" in the column.\n\n    If set to a number, Bokeh will use that number as the index in all cases.",
        "default": null
      },
      {
        "name": "label",
        "type": "StringSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), List(String))), List(String))",
        "desc": "A label for this legend. Can be a string, or a column of a\n    ColumnDataSource. If ``label`` is a field, then it must\n    be in the renderers' data_source.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "renderers",
        "type": "List(Instance(GlyphRenderer))",
        "desc": "A list of the glyph renderers to draw in the legend. If ``label`` is a field,\n    then all data_sources of renderers must be the same.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Line": {
    "name": "Line",
    "bases": [
      "bokeh.models.glyph.ConnectedXYGlyph",
      "bokeh.models.glyph.LineGlyph"
    ],
    "desc": "Render a single line.\n\n    The ``Line`` glyph is different from most other glyphs in that the vector\n    of values only produces one glyph on the Plot.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Line.py\n        :source-position: below",
    "proto": "{\"id\": \"3866\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": 1.0, \"line_cap\": \"butt\", \"line_color\": \"black\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the line.",
        "default": "butt"
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the line.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the line.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the line.",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the line.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the line.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the line.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates for the points of the line.",
        "default": null
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates for the points of the line.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LineEditTool": {
    "name": "LineEditTool",
    "bases": [
      "bokeh.models.tools.EditTool",
      "bokeh.models.tools.Drag",
      "bokeh.models.tools.Tap"
    ],
    "desc": "*toolbar icon*: |line_edit_icon|\n\n    The LineEditTool allows editing the intersection points of one or more ``Line`` glyphs.\n    Glyphs to be edited are defined via the ``renderers``\n    property and a renderer for the intersections is set via the ``intersection_renderer``\n    property (must render a point-like Glyph (a subclass of ``XYGlyph``).\n\n    The tool will modify the columns on the data source corresponding to the\n    ``x`` and ``y`` values of the glyph. Any additional columns in the data\n    source will be padded with the declared``empty_value``, when adding a new\n    point.\n\n    The supported actions include:\n\n    * Show intersections: Double tap an existing line\n\n    * Move point: Drag an existing point and let go of the mouse button to\n      release it.\n\n    .. |line_edit_icon| image:: /_images/icons/LineEdit.png\n        :height: 24px",
    "proto": "{\"custom_icon\": null, \"custom_tooltip\": null, \"dimensions\": \"both\", \"empty_value\": null, \"id\": \"3881\", \"intersection_renderer\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"renderers\": [], \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "custom_icon",
        "type": "Image",
        "desc": "An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.",
        "default": null
      },
      {
        "name": "empty_value",
        "type": "Either(Bool, Int, Float, Date, Datetime, Color, String)",
        "desc": "Defines the value to insert on non-coordinate columns when a new\n    glyph is inserted into the ``ColumnDataSource`` columns, e.g. when a\n    circle glyph defines 'x', 'y' and 'color' columns, adding a new\n    point will add the x and y-coordinates to 'x' and 'y' columns and\n    the color column will be filled with the defined empty value.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "custom_tooltip",
        "type": "String",
        "desc": "A custom tooltip label to override the default name.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "dimensions",
        "type": "Enum('width', 'height', 'both')",
        "desc": "Which dimensions this edit tool is constrained to act in. By default\n    the line edit tool allows moving points in any dimension, but can be\n    configured to only allow horizontal movement across the width of the\n    plot, or vertical across the height of the plot.",
        "default": "both"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "intersection_renderer",
        "type": "Instance(GlyphRenderer)",
        "desc": "The renderer used to render the intersections of a selected line",
        "default": null
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "An explicit list of renderers corresponding to scatter glyphs that may\n    be edited.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LineGlyph": {
    "name": "LineGlyph",
    "bases": [
      "bokeh.models.glyph.Glyph"
    ],
    "desc": "Glyphs with line properties\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"3893\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LinearAxis": {
    "name": "LinearAxis",
    "bases": [
      "bokeh.models.axes.ContinuousAxis"
    ],
    "desc": "An axis that picks nice numbers for tick locations on a\n    linear scale. Configured with a ``BasicTickFormatter`` by default.",
    "proto": "{\"axis_label\": \"\", \"axis_label_standoff\": 5, \"axis_label_text_align\": \"left\", \"axis_label_text_alpha\": 1.0, \"axis_label_text_baseline\": \"bottom\", \"axis_label_text_color\": \"#444444\", \"axis_label_text_font\": \"helvetica\", \"axis_label_text_font_size\": \"13px\", \"axis_label_text_font_style\": \"italic\", \"axis_label_text_line_height\": 1.2, \"axis_line_alpha\": 1.0, \"axis_line_cap\": \"butt\", \"axis_line_color\": \"black\", \"axis_line_dash\": [], \"axis_line_dash_offset\": 0, \"axis_line_join\": \"bevel\", \"axis_line_width\": 1, \"bounds\": \"auto\", \"fixed_location\": null, \"formatter\": {\"id\": \"3900\"}, \"id\": \"3899\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"guide\", \"major_label_orientation\": \"horizontal\", \"major_label_overrides\": {}, \"major_label_standoff\": 5, \"major_label_text_align\": \"center\", \"major_label_text_alpha\": 1.0, \"major_label_text_baseline\": \"alphabetic\", \"major_label_text_color\": \"#444444\", \"major_label_text_font\": \"helvetica\", \"major_label_text_font_size\": \"11px\", \"major_label_text_font_style\": \"normal\", \"major_label_text_line_height\": 1.2, \"major_tick_in\": 2, \"major_tick_line_alpha\": 1.0, \"major_tick_line_cap\": \"butt\", \"major_tick_line_color\": \"black\", \"major_tick_line_dash\": [], \"major_tick_line_dash_offset\": 0, \"major_tick_line_join\": \"bevel\", \"major_tick_line_width\": 1, \"major_tick_out\": 6, \"minor_tick_in\": 0, \"minor_tick_line_alpha\": 1.0, \"minor_tick_line_cap\": \"butt\", \"minor_tick_line_color\": \"black\", \"minor_tick_line_dash\": [], \"minor_tick_line_dash_offset\": 0, \"minor_tick_line_join\": \"bevel\", \"minor_tick_line_width\": 1, \"minor_tick_out\": 4, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"ticker\": {\"id\": \"3901\"}, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "axis_line_width",
        "type": "Float",
        "desc": "The line width of the axis line.",
        "default": 1
      },
      {
        "name": "major_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the major tick labels should be\n    offset from the associated ticks.",
        "default": 5
      },
      {
        "name": "axis_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the axis line.",
        "default": []
      },
      {
        "name": "major_tick_line_width",
        "type": "Float",
        "desc": "The line width of the major ticks.",
        "default": 1
      },
      {
        "name": "axis_line_color",
        "type": "Color",
        "desc": "The line color of the axis line.",
        "default": "black"
      },
      {
        "name": "axis_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the axis label.",
        "default": "italic"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default x-range.",
        "default": "default"
      },
      {
        "name": "axis_label",
        "type": "String",
        "desc": "A text label for the axis, displayed parallel to the axis rule.\n\n    .. note::\n        LaTeX notation is not currently supported; please see\n        :bokeh-issue:`647` to track progress or contribute.",
        "default": ""
      },
      {
        "name": "major_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the major ticks.",
        "default": 0
      },
      {
        "name": "minor_tick_line_width",
        "type": "Float",
        "desc": "The line width of the minor ticks.",
        "default": 1
      },
      {
        "name": "minor_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that minor ticks should extend into the\n    main plot area.",
        "default": 0
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "major_label_overrides",
        "type": "Dict(Either(Float, String), String)",
        "desc": "Provide explicit tick label values for specific tick locations that\n    override normal formatting.",
        "default": {}
      },
      {
        "name": "major_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the major tick labels.",
        "default": "center"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default y-range.",
        "default": "default"
      },
      {
        "name": "formatter",
        "type": "Instance(TickFormatter)",
        "desc": "A ``TickFormatter`` to use for formatting the visual appearance\n    of ticks.",
        "default": "{\"id\": \"3919\"}"
      },
      {
        "name": "major_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the major tick labels.",
        "default": "normal"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "ticker",
        "type": "Instance(Ticker)",
        "desc": "A Ticker to use for computing locations of axis components.\n\n    The property may also be passed a sequence of floating point numbers as\n    a shorthand for creating and configuring a ``FixedTicker``, e.g. the\n    following code\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n\n        p = figure()\n        p.xaxis.ticker = [10, 20, 37.4]\n\n    is equivalent to:\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n        from bokeh.models import FixedTicker\n\n        p = figure()\n        p.xaxis.ticker = FixedTicker(ticks=[10, 20, 37.4])",
        "default": "{\"id\": \"3923\"}"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "axis_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the axis labels should be offset\n    from the tick labels.",
        "default": 5
      },
      {
        "name": "major_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the major tick labels.",
        "default": "alphabetic"
      },
      {
        "name": "axis_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the axis label.",
        "default": 1.2
      },
      {
        "name": "axis_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the axis line.",
        "default": 0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "major_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the major ticks.",
        "default": 1.0
      },
      {
        "name": "major_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend into the\n    main plot area.",
        "default": 2
      },
      {
        "name": "minor_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the minor ticks.",
        "default": []
      },
      {
        "name": "major_label_text_font",
        "type": "String",
        "desc": "The text font of the major tick labels.",
        "default": "helvetica"
      },
      {
        "name": "minor_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the minor ticks.",
        "default": 1.0
      },
      {
        "name": "major_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the major tick labels.",
        "default": "11px"
      },
      {
        "name": "minor_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the minor ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the axis label.",
        "default": "left"
      },
      {
        "name": "major_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the major ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 4
      },
      {
        "name": "axis_label_text_color",
        "type": "Color",
        "desc": "The text color of the axis label.",
        "default": "#444444"
      },
      {
        "name": "fixed_location",
        "type": "Either(Float, String, Tuple(String, String), Tuple(String, String, String))",
        "desc": "Set to specify a fixed coordinate location to draw the axis. The direction\n    of ticks and major labels is determined by the side panel that the axis\n    belongs to.\n\n    .. note::\n        Axes labels are suppressed when axes are positioned at fixed locations\n        inside the central plot area.",
        "default": null
      },
      {
        "name": "major_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the major ticks.",
        "default": []
      },
      {
        "name": "major_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the major tick labels.",
        "default": 1.2
      },
      {
        "name": "minor_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the minor ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_line_color",
        "type": "Color",
        "desc": "The line color of the minor ticks.",
        "default": "black"
      },
      {
        "name": "axis_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the axis line.",
        "default": "bevel"
      },
      {
        "name": "major_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 6
      },
      {
        "name": "axis_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the axis label.",
        "default": "13px"
      },
      {
        "name": "axis_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the axis line.",
        "default": 1.0
      },
      {
        "name": "major_label_orientation",
        "type": "Either(Enum('horizontal', 'vertical'), Float)",
        "desc": "What direction the major label text should be oriented. If a\n    number is supplied, the angle of the text is measured from horizontal.",
        "default": "horizontal"
      },
      {
        "name": "minor_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the minor ticks.",
        "default": 0
      },
      {
        "name": "major_tick_line_color",
        "type": "Color",
        "desc": "The line color of the major ticks.",
        "default": "black"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "major_label_text_color",
        "type": "Color",
        "desc": "The text color of the major tick labels.",
        "default": "#444444"
      },
      {
        "name": "axis_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the axis line.",
        "default": "butt"
      },
      {
        "name": "major_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the major ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_font",
        "type": "String",
        "desc": "The text font of the axis label.",
        "default": "helvetica"
      },
      {
        "name": "axis_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the axis label.",
        "default": "bottom"
      },
      {
        "name": "axis_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the axis label.",
        "default": 1.0
      },
      {
        "name": "major_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the major tick labels.",
        "default": 1.0
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "guide"
      },
      {
        "name": "bounds",
        "type": "Either(Auto, Tuple(Float, Float), Tuple(Datetime, Datetime))",
        "desc": "Bounds for the rendered axis. If unset, the axis will span the\n    entire plot in the given dimension.",
        "default": "auto"
      }
    ]
  },
  "LinearColorMapper": {
    "name": "LinearColorMapper",
    "bases": [
      "bokeh.models.mappers.ContinuousColorMapper"
    ],
    "desc": "Map numbers in a range [*low*, *high*] linearly into a sequence of\n    colors (a palette).\n\n    For example, if the range is [0, 99] and the palette is\n    ``['red', 'green', 'blue']``, the values would be mapped as follows::\n\n             x < 0  : 'red'     # values < low are clamped\n        0 >= x < 33 : 'red'\n       33 >= x < 66 : 'green'\n       66 >= x < 99 : 'blue'\n       99 >= x      : 'blue'    # values > high are clamped",
    "proto": "{\"high\": null, \"high_color\": null, \"id\": \"3963\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"low\": null, \"low_color\": null, \"name\": null, \"nan_color\": \"gray\", \"palette\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "low",
        "type": "Float",
        "desc": "The minimum value of the range to map into the palette. Values below\n    this are clamped to ``low``.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "nan_color",
        "type": "Color",
        "desc": "Color to be used if data is NaN or otherwise not mappable. (Default: 'gray')",
        "default": "gray"
      },
      {
        "name": "palette",
        "type": "Seq(Color)",
        "desc": "A sequence of colors to use as the target palette for mapping.\n\n    This property can also be set as a ``String``, to the name of any of the\n    palettes shown in :ref:`bokeh.palettes`.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "high",
        "type": "Float",
        "desc": "The maximum value of the range to map into the palette. Values above\n    this are clamped to ``high``.",
        "default": null
      },
      {
        "name": "low_color",
        "type": "Color",
        "desc": "Color to be used if data is lower than ``low`` value. If None,\n    values lower than ``low`` are mapped to the first color in the palette.",
        "default": null
      },
      {
        "name": "high_color",
        "type": "Color",
        "desc": "Color to be used if data is higher than ``high`` value. If None,\n    values higher than ``high`` are mapped to the last color in the palette.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LinearInterpolator": {
    "name": "LinearInterpolator",
    "bases": [
      "bokeh.models.transforms.Interpolator"
    ],
    "desc": "Compute a linear interpolation between the control points provided through\n    the ``x``, ``y``, and ``data`` parameters.",
    "proto": "{\"clip\": true, \"data\": null, \"id\": \"3975\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "clip",
        "type": "Bool",
        "desc": "Determine if the interpolation should clip the result to include only values inside its predefined range.\n    If this is set to False, it will return the most value of the closest point.",
        "default": true
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "data",
        "type": "Instance(ColumnarDataSource)",
        "desc": "Data which defines the source for the named columns if a string is passed to either the ``x`` or ``y`` parameters.",
        "default": null
      },
      {
        "name": "y",
        "type": "Either(String, Seq(Float))",
        "desc": "Dependant coordinate denoting the value of a point at a location.",
        "default": null
      },
      {
        "name": "x",
        "type": "Either(String, Seq(Float))",
        "desc": "Independent coordinate denoting the location of a point.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LinearScale": {
    "name": "LinearScale",
    "bases": [
      "bokeh.models.scales.ContinuousScale"
    ],
    "desc": "Represent a linear scale transformation between continuous ranges.",
    "proto": "{\"id\": \"3985\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LogAxis": {
    "name": "LogAxis",
    "bases": [
      "bokeh.models.axes.ContinuousAxis"
    ],
    "desc": "An axis that picks nice numbers for tick locations on a\n    log scale. Configured with a ``LogTickFormatter`` by default.",
    "proto": "{\"axis_label\": \"\", \"axis_label_standoff\": 5, \"axis_label_text_align\": \"left\", \"axis_label_text_alpha\": 1.0, \"axis_label_text_baseline\": \"bottom\", \"axis_label_text_color\": \"#444444\", \"axis_label_text_font\": \"helvetica\", \"axis_label_text_font_size\": \"13px\", \"axis_label_text_font_style\": \"italic\", \"axis_label_text_line_height\": 1.2, \"axis_line_alpha\": 1.0, \"axis_line_cap\": \"butt\", \"axis_line_color\": \"black\", \"axis_line_dash\": [], \"axis_line_dash_offset\": 0, \"axis_line_join\": \"bevel\", \"axis_line_width\": 1, \"bounds\": \"auto\", \"fixed_location\": null, \"formatter\": {\"id\": \"3992\"}, \"id\": \"3991\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"guide\", \"major_label_orientation\": \"horizontal\", \"major_label_overrides\": {}, \"major_label_standoff\": 5, \"major_label_text_align\": \"center\", \"major_label_text_alpha\": 1.0, \"major_label_text_baseline\": \"alphabetic\", \"major_label_text_color\": \"#444444\", \"major_label_text_font\": \"helvetica\", \"major_label_text_font_size\": \"11px\", \"major_label_text_font_style\": \"normal\", \"major_label_text_line_height\": 1.2, \"major_tick_in\": 2, \"major_tick_line_alpha\": 1.0, \"major_tick_line_cap\": \"butt\", \"major_tick_line_color\": \"black\", \"major_tick_line_dash\": [], \"major_tick_line_dash_offset\": 0, \"major_tick_line_join\": \"bevel\", \"major_tick_line_width\": 1, \"major_tick_out\": 6, \"minor_tick_in\": 0, \"minor_tick_line_alpha\": 1.0, \"minor_tick_line_cap\": \"butt\", \"minor_tick_line_color\": \"black\", \"minor_tick_line_dash\": [], \"minor_tick_line_dash_offset\": 0, \"minor_tick_line_join\": \"bevel\", \"minor_tick_line_width\": 1, \"minor_tick_out\": 4, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"ticker\": {\"id\": \"3993\"}, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "axis_line_width",
        "type": "Float",
        "desc": "The line width of the axis line.",
        "default": 1
      },
      {
        "name": "major_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the major tick labels should be\n    offset from the associated ticks.",
        "default": 5
      },
      {
        "name": "axis_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the axis line.",
        "default": []
      },
      {
        "name": "major_tick_line_width",
        "type": "Float",
        "desc": "The line width of the major ticks.",
        "default": 1
      },
      {
        "name": "axis_line_color",
        "type": "Color",
        "desc": "The line color of the axis line.",
        "default": "black"
      },
      {
        "name": "axis_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the axis label.",
        "default": "italic"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default x-range.",
        "default": "default"
      },
      {
        "name": "axis_label",
        "type": "String",
        "desc": "A text label for the axis, displayed parallel to the axis rule.\n\n    .. note::\n        LaTeX notation is not currently supported; please see\n        :bokeh-issue:`647` to track progress or contribute.",
        "default": ""
      },
      {
        "name": "major_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the major ticks.",
        "default": 0
      },
      {
        "name": "minor_tick_line_width",
        "type": "Float",
        "desc": "The line width of the minor ticks.",
        "default": 1
      },
      {
        "name": "minor_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that minor ticks should extend into the\n    main plot area.",
        "default": 0
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "major_label_overrides",
        "type": "Dict(Either(Float, String), String)",
        "desc": "Provide explicit tick label values for specific tick locations that\n    override normal formatting.",
        "default": {}
      },
      {
        "name": "major_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the major tick labels.",
        "default": "center"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default y-range.",
        "default": "default"
      },
      {
        "name": "formatter",
        "type": "Instance(TickFormatter)",
        "desc": "A ``TickFormatter`` to use for formatting the visual appearance\n    of ticks.",
        "default": "{\"id\": \"4011\"}"
      },
      {
        "name": "major_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the major tick labels.",
        "default": "normal"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "ticker",
        "type": "Instance(Ticker)",
        "desc": "A Ticker to use for computing locations of axis components.\n\n    The property may also be passed a sequence of floating point numbers as\n    a shorthand for creating and configuring a ``FixedTicker``, e.g. the\n    following code\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n\n        p = figure()\n        p.xaxis.ticker = [10, 20, 37.4]\n\n    is equivalent to:\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n        from bokeh.models import FixedTicker\n\n        p = figure()\n        p.xaxis.ticker = FixedTicker(ticks=[10, 20, 37.4])",
        "default": "{\"id\": \"4015\"}"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "axis_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the axis labels should be offset\n    from the tick labels.",
        "default": 5
      },
      {
        "name": "major_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the major tick labels.",
        "default": "alphabetic"
      },
      {
        "name": "axis_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the axis label.",
        "default": 1.2
      },
      {
        "name": "axis_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the axis line.",
        "default": 0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "major_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the major ticks.",
        "default": 1.0
      },
      {
        "name": "major_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend into the\n    main plot area.",
        "default": 2
      },
      {
        "name": "minor_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the minor ticks.",
        "default": []
      },
      {
        "name": "major_label_text_font",
        "type": "String",
        "desc": "The text font of the major tick labels.",
        "default": "helvetica"
      },
      {
        "name": "minor_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the minor ticks.",
        "default": 1.0
      },
      {
        "name": "major_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the major tick labels.",
        "default": "11px"
      },
      {
        "name": "minor_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the minor ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the axis label.",
        "default": "left"
      },
      {
        "name": "major_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the major ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 4
      },
      {
        "name": "axis_label_text_color",
        "type": "Color",
        "desc": "The text color of the axis label.",
        "default": "#444444"
      },
      {
        "name": "fixed_location",
        "type": "Either(Float, String, Tuple(String, String), Tuple(String, String, String))",
        "desc": "Set to specify a fixed coordinate location to draw the axis. The direction\n    of ticks and major labels is determined by the side panel that the axis\n    belongs to.\n\n    .. note::\n        Axes labels are suppressed when axes are positioned at fixed locations\n        inside the central plot area.",
        "default": null
      },
      {
        "name": "major_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the major ticks.",
        "default": []
      },
      {
        "name": "major_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the major tick labels.",
        "default": 1.2
      },
      {
        "name": "minor_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the minor ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_line_color",
        "type": "Color",
        "desc": "The line color of the minor ticks.",
        "default": "black"
      },
      {
        "name": "axis_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the axis line.",
        "default": "bevel"
      },
      {
        "name": "major_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 6
      },
      {
        "name": "axis_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the axis label.",
        "default": "13px"
      },
      {
        "name": "axis_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the axis line.",
        "default": 1.0
      },
      {
        "name": "major_label_orientation",
        "type": "Either(Enum('horizontal', 'vertical'), Float)",
        "desc": "What direction the major label text should be oriented. If a\n    number is supplied, the angle of the text is measured from horizontal.",
        "default": "horizontal"
      },
      {
        "name": "minor_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the minor ticks.",
        "default": 0
      },
      {
        "name": "major_tick_line_color",
        "type": "Color",
        "desc": "The line color of the major ticks.",
        "default": "black"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "major_label_text_color",
        "type": "Color",
        "desc": "The text color of the major tick labels.",
        "default": "#444444"
      },
      {
        "name": "axis_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the axis line.",
        "default": "butt"
      },
      {
        "name": "major_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the major ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_font",
        "type": "String",
        "desc": "The text font of the axis label.",
        "default": "helvetica"
      },
      {
        "name": "axis_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the axis label.",
        "default": "bottom"
      },
      {
        "name": "axis_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the axis label.",
        "default": 1.0
      },
      {
        "name": "major_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the major tick labels.",
        "default": 1.0
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "guide"
      },
      {
        "name": "bounds",
        "type": "Either(Auto, Tuple(Float, Float), Tuple(Datetime, Datetime))",
        "desc": "Bounds for the rendered axis. If unset, the axis will span the\n    entire plot in the given dimension.",
        "default": "auto"
      }
    ]
  },
  "LogColorMapper": {
    "name": "LogColorMapper",
    "bases": [
      "bokeh.models.mappers.ContinuousColorMapper"
    ],
    "desc": "Map numbers in a range [*low*, *high*] into a sequence of colors\n    (a palette) on a natural logarithm scale.\n\n    For example, if the range is [0, 25] and the palette is\n    ``['red', 'green', 'blue']``, the values would be mapped as follows::\n\n                x < 0     : 'red'     # values < low are clamped\n       0     >= x < 2.72  : 'red'     # math.e ** 1\n       2.72  >= x < 7.39  : 'green'   # math.e ** 2\n       7.39  >= x < 20.09 : 'blue'    # math.e ** 3\n       20.09 >= x         : 'blue'    # values > high are clamped\n\n    .. warning::\n        The ``LogColorMapper`` only works for images with scalar values that are\n        non-negative.",
    "proto": "{\"high\": null, \"high_color\": null, \"id\": \"4055\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"low\": null, \"low_color\": null, \"name\": null, \"nan_color\": \"gray\", \"palette\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "low",
        "type": "Float",
        "desc": "The minimum value of the range to map into the palette. Values below\n    this are clamped to ``low``.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "nan_color",
        "type": "Color",
        "desc": "Color to be used if data is NaN or otherwise not mappable. (Default: 'gray')",
        "default": "gray"
      },
      {
        "name": "palette",
        "type": "Seq(Color)",
        "desc": "A sequence of colors to use as the target palette for mapping.\n\n    This property can also be set as a ``String``, to the name of any of the\n    palettes shown in :ref:`bokeh.palettes`.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "high",
        "type": "Float",
        "desc": "The maximum value of the range to map into the palette. Values above\n    this are clamped to ``high``.",
        "default": null
      },
      {
        "name": "low_color",
        "type": "Color",
        "desc": "Color to be used if data is lower than ``low`` value. If None,\n    values lower than ``low`` are mapped to the first color in the palette.",
        "default": null
      },
      {
        "name": "high_color",
        "type": "Color",
        "desc": "Color to be used if data is higher than ``high`` value. If None,\n    values higher than ``high`` are mapped to the last color in the palette.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LogScale": {
    "name": "LogScale",
    "bases": [
      "bokeh.models.scales.ContinuousScale"
    ],
    "desc": "Represent a log scale transformation between continuous ranges.",
    "proto": "{\"id\": \"4067\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LogTickFormatter": {
    "name": "LogTickFormatter",
    "bases": [
      "bokeh.models.formatters.TickFormatter"
    ],
    "desc": "Display tick values from continuous ranges as powers\n    of some base.\n\n    Most often useful in conjunction with a ``LogTicker``.",
    "proto": "{\"id\": \"4073\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"ticker\": null}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "ticker",
        "type": "Instance(Ticker)",
        "desc": "The corresponding ``LogTicker``, used to determine the correct\n    base to use. If unset, the formatter will use base 10 as a default.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "LogTicker": {
    "name": "LogTicker",
    "bases": [
      "bokeh.models.tickers.AdaptiveTicker"
    ],
    "desc": "Generate ticks on a log scale.",
    "proto": "{\"base\": 10.0, \"desired_num_ticks\": 6, \"id\": \"4080\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mantissas\": [1, 5], \"max_interval\": null, \"min_interval\": 0.0, \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mantissas",
        "type": "Seq(Float)",
        "desc": "The acceptable list numbers to generate multiples of.",
        "default": [
          1,
          5
        ]
      },
      {
        "name": "base",
        "type": "Float",
        "desc": "The multiplier to use for scaling mantissas.",
        "default": 10.0
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "min_interval",
        "type": "Float",
        "desc": "The smallest allowable interval between two adjacent ticks.",
        "default": 0.0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "max_interval",
        "type": "Float",
        "desc": "The largest allowable interval between two adjacent ticks.\n\n    .. note::\n        To specify an unbounded interval, set to ``None``.",
        "default": null
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "MapOptions": {
    "name": "MapOptions",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Abstract base class for map options' models.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"4092\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"lat\": null, \"lng\": null, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"zoom\": 12}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "lat",
        "type": "Float",
        "desc": "The latitude where the map should be centered.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "zoom",
        "type": "Int",
        "desc": "The initial zoom level to use when displaying the map.",
        "default": 12
      },
      {
        "name": "lng",
        "type": "Float",
        "desc": "The longitude where the map should be centered.",
        "default": null
      }
    ]
  },
  "MapPlot": {
    "name": "MapPlot",
    "bases": [
      "bokeh.models.plots.Plot"
    ],
    "desc": "Abstract base class for map plot models.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"above\": [], \"align\": \"start\", \"aspect_ratio\": null, \"aspect_scale\": 1, \"background\": null, \"background_fill_alpha\": 1.0, \"background_fill_color\": \"#ffffff\", \"below\": [], \"border_fill_alpha\": 1.0, \"border_fill_color\": \"#ffffff\", \"center\": [], \"css_classes\": [], \"disabled\": false, \"extra_x_ranges\": {}, \"extra_y_ranges\": {}, \"frame_height\": null, \"frame_width\": null, \"height\": null, \"height_policy\": \"auto\", \"hidpi\": true, \"id\": \"4101\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"left\": [], \"lod_factor\": 10, \"lod_interval\": 300, \"lod_threshold\": 2000, \"lod_timeout\": 500, \"margin\": [0, 0, 0, 0], \"match_aspect\": false, \"max_height\": null, \"max_width\": null, \"min_border\": 5, \"min_border_bottom\": null, \"min_border_left\": null, \"min_border_right\": null, \"min_border_top\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"outline_line_alpha\": 1.0, \"outline_line_cap\": \"butt\", \"outline_line_color\": \"#e5e5e5\", \"outline_line_dash\": [], \"outline_line_dash_offset\": 0, \"outline_line_join\": \"bevel\", \"outline_line_width\": 1, \"output_backend\": \"canvas\", \"plot_height\": 600, \"plot_width\": 600, \"renderers\": [], \"reset_policy\": \"standard\", \"right\": [], \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": {\"id\": \"4105\"}, \"title_location\": \"above\", \"toolbar\": {\"id\": \"4104\"}, \"toolbar_location\": \"right\", \"toolbar_sticky\": true, \"visible\": true, \"width\": null, \"width_policy\": \"auto\", \"x_range\": {\"id\": \"4102\"}, \"x_scale\": {\"id\": \"4103\"}, \"y_range\": {\"id\": \"4106\"}, \"y_scale\": {\"id\": \"4107\"}}",
    "props": [
      {
        "name": "outline_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap for the plot border outline.",
        "default": "butt"
      },
      {
        "name": "outline_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset for the plot border outline.",
        "default": 0
      },
      {
        "name": "min_border_right",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region to the right of\n    the central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "match_aspect",
        "type": "Bool",
        "desc": "Specify the aspect ratio behavior of the plot. Aspect ratio is defined as\n    the ratio of width over height. This property controls whether Bokeh should\n    attempt the match the (width/height) of *data space* to the (width/height)\n    in pixels of *screen space*.\n\n    Default is ``False`` which indicates that the *data* aspect ratio and the\n    *screen* aspect ratio vary independently. ``True`` indicates that the plot\n    aspect ratio of the axes will match the aspect ratio of the pixel extent\n    the axes. The end result is that a 1x1 area in data space is a square in\n    pixels, and conversely that a 1x1 pixel is a square in data units.\n\n    .. note::\n        This setting only takes effect when there are two dataranges. This\n        setting only sets the initial plot draw and subsequent resets. It is\n        possible for tools (single axis zoom, unconstrained box zoom) to\n        change the aspect ratio.\n\n    .. warning::\n        This setting is incompatible with linking dataranges across multiple\n        plots. Doing so may result in undefined behaviour.",
        "default": false
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "outline_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join for the plot border outline.",
        "default": "bevel"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "min_border",
        "type": "Int",
        "desc": "A convenience property to set all all the ``min_border_X`` properties\n    to the same value. If an individual border property is explicitly set,\n    it will override ``min_border``.",
        "default": 5
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "lod_factor",
        "type": "Int",
        "desc": "Decimation factor to use when applying level-of-detail decimation.",
        "default": 10
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "plot_width",
        "type": "Int",
        "desc": "The outer width of a plot, including any axes, titles, border padding, etc.\n\n    .. note::\n        This corresponds directly to the width of the HTML canvas.",
        "default": 600
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "outline_line_alpha",
        "type": "Percent",
        "desc": "The line alpha for the plot border outline.",
        "default": 1.0
      },
      {
        "name": "background_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha for the plot background style.",
        "default": 1.0
      },
      {
        "name": "title_location",
        "type": "Enum('above', 'below', 'left', 'right')",
        "desc": "Where the title will be located. Titles on the left or right side\n    will be rotated.",
        "default": "above"
      },
      {
        "name": "x_range",
        "type": "Instance(Range)",
        "desc": "The (default) data range of the horizontal dimension of the plot.",
        "default": "{\"id\": \"4129\"}"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "extra_y_ranges",
        "type": "Dict(String, Instance(Range))",
        "desc": "Additional named ranges to make available for mapping y-coordinates.\n\n    This is useful for adding additional axes.",
        "default": {}
      },
      {
        "name": "outline_line_width",
        "type": "Float",
        "desc": "The line width for the plot border outline.",
        "default": 1
      },
      {
        "name": "min_border_top",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region above the top of the\n    central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "outline_line_color",
        "type": "Color",
        "desc": "The line color for the plot border outline.",
        "default": "#e5e5e5"
      },
      {
        "name": "toolbar_location",
        "type": "Enum('above', 'below', 'left', 'right')",
        "desc": "Where the toolbar will be located. If set to None, no toolbar\n    will be attached to the plot.",
        "default": "right"
      },
      {
        "name": "above",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area above of the plot.",
        "default": []
      },
      {
        "name": "plot_height",
        "type": "Int",
        "desc": "The outer height of a plot, including any axes, titles, border padding, etc.\n\n    .. note::\n        This corresponds directly to the height of the HTML canvas.",
        "default": 600
      },
      {
        "name": "aspect_scale",
        "type": "Float",
        "desc": "A value to be given for increased aspect ratio control. This value is added\n    multiplicatively to the calculated value required for ``match_aspect``.\n    ``aspect_scale`` is defined as the ratio of width over height of the figure.\n\n    For example, a plot with ``aspect_scale`` value of 2 will result in a\n    square in *data units* to be drawn on the screen as a rectangle with a\n    pixel width twice as long as its pixel height.\n\n    .. note::\n        This setting only takes effect if ``match_aspect`` is set to ``True``.",
        "default": 1
      },
      {
        "name": "output_backend",
        "type": "Enum('canvas', 'svg', 'webgl')",
        "desc": "Specify the output backend for the plot area. Default is HTML5 Canvas.\n\n    .. note::\n        When set to ``webgl``, glyphs without a WebGL rendering implementation\n        will fall back to rendering onto 2D canvas.",
        "default": "canvas"
      },
      {
        "name": "frame_width",
        "type": "Int",
        "desc": "The width of a plot frame or the inner width of a plot, excluding any\n    axes, titles, border padding, etc.",
        "default": null
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "border_fill_color",
        "type": "Color",
        "desc": "The fill color for the plot border style.",
        "default": "#ffffff"
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "x_scale",
        "type": "Instance(Scale)",
        "desc": "What kind of scale to use to convert x-coordinates in data space\n    into x-coordinates in screen space.",
        "default": "{\"id\": \"4148\"}"
      },
      {
        "name": "outline_line_dash",
        "type": "DashPattern",
        "desc": "The line dash for the plot border outline.",
        "default": []
      },
      {
        "name": "reset_policy",
        "type": "Enum('standard', 'event_only')",
        "desc": "How a plot should respond to being reset. By deafult, the standard actions\n    are to clear any tool state history, return plot ranges to their original\n    values, undo all selections, and emit a ``Reset`` event. If customization\n    is desired, this property may be set to ``\"event_only\"``, which will\n    suppress all of the actions except the Reset event.",
        "default": "standard"
      },
      {
        "name": "outer_height",
        "type": "Int",
        "desc": "This is the exact height of the layout, i.e. the height of\n    the actual plot, with toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "border_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha for the plot border style.",
        "default": 1.0
      },
      {
        "name": "outer_width",
        "type": "Int",
        "desc": "This is the exact width of the layout, i.e. the height of\n    the actual plot, with toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "toolbar",
        "type": "Instance(Toolbar)",
        "desc": "The toolbar associated with this plot which holds all the tools. It is\n    automatically created with the plot if necessary.",
        "default": "{\"id\": \"4155\"}"
      },
      {
        "name": "toolbar_sticky",
        "type": "Bool",
        "desc": "Stick the toolbar to the edge of the plot. Default: True. If False,\n    the toolbar will be outside of the axes, titles etc.",
        "default": true
      },
      {
        "name": "min_border_bottom",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region below the bottom of\n    the central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "title",
        "type": "Instance(Title)",
        "desc": "A title for the plot. Can be a text string or a Title annotation.",
        "default": "{\"id\": \"4159\", \"text\": \"\"}"
      },
      {
        "name": "frame_height",
        "type": "Int",
        "desc": "The height of a plot frame or the inner height of a plot, excluding any\n    axes, titles, border padding, etc.",
        "default": null
      },
      {
        "name": "center",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the center area (frame) of the plot.",
        "default": []
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "lod_threshold",
        "type": "Int",
        "desc": "A number of data points, above which level-of-detail downsampling may\n    be performed by glyph renderers. Set to ``None`` to disable any\n    level-of-detail downsampling.",
        "default": 2000
      },
      {
        "name": "below",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area below of the plot.",
        "default": []
      },
      {
        "name": "lod_interval",
        "type": "Int",
        "desc": "Interval (in ms) during which an interactive tool event will enable\n    level-of-detail downsampling.",
        "default": 300
      },
      {
        "name": "lod_timeout",
        "type": "Int",
        "desc": "Timeout (in ms) for checking whether interactive tool events are still\n    occurring. Once level-of-detail mode is enabled, a check is made every\n    ``lod_timeout`` ms. If no interactive tool events have happened,\n    level-of-detail mode is disabled.",
        "default": 500
      },
      {
        "name": "left",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area to the left of the plot.",
        "default": []
      },
      {
        "name": "right",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area to the right of the plot.",
        "default": []
      },
      {
        "name": "min_border_left",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region to the left of\n    the central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "y_range",
        "type": "Instance(Range)",
        "desc": "The (default) data range of the vertical dimension of the plot.",
        "default": "{\"id\": \"4173\"}"
      },
      {
        "name": "inner_width",
        "type": "Int",
        "desc": "This is the exact width of the plotting canvas, i.e. the width of\n    the actual plot, without toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "inner_height",
        "type": "Int",
        "desc": "This is the exact height of the plotting canvas, i.e. the height of\n    the actual plot, without toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "extra_x_ranges",
        "type": "Dict(String, Instance(Range))",
        "desc": "Additional named ranges to make available for mapping x-coordinates.\n\n    This is useful for adding additional axes.",
        "default": {}
      },
      {
        "name": "background_fill_color",
        "type": "Color",
        "desc": "The fill color for the plot background style.",
        "default": "#ffffff"
      },
      {
        "name": "hidpi",
        "type": "Bool",
        "desc": "Whether to use HiDPI mode when available.",
        "default": true
      },
      {
        "name": "y_scale",
        "type": "Instance(Scale)",
        "desc": "What kind of scale to use to convert y-coordinates in data space\n    into y-coordinates in screen space.",
        "default": "{\"id\": \"4183\"}"
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "A list of all renderers for this plot, including guides and annotations\n    in addition to glyphs and markers.\n\n    This property can be manipulated by hand, but the ``add_glyph`` and\n    ``add_layout`` methods are recommended to help make sure all necessary\n    setup is performed.",
        "default": []
      }
    ]
  },
  "Mapper": {
    "name": "Mapper",
    "bases": [
      "bokeh.models.transforms.Transform"
    ],
    "desc": "Base class for mappers.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"4185\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Marker": {
    "name": "Marker",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph"
    ],
    "desc": "Base class for glyphs that are simple markers with line and\n    fill properties, located at an (x, y) location with a specified\n    size.\n\n    .. note::\n        For simplicity, all markers have both line and fill properties\n        declared, however some markers (`Asterisk`, `Cross`, `X`) only\n        draw lines. For these markers, the fill values are simply\n        ignored.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"4191\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "Markup": {
    "name": "Markup",
    "bases": [
      "bokeh.models.widgets.widget.Widget"
    ],
    "desc": "Base class for Bokeh models that represent HTML markup elements.\n\n    Markups include e.g., ``<div>``, ``<p>``, and ``<pre>``.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"4211\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"style\": {}, \"subscribed_events\": [], \"tags\": [], \"text\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "style",
        "type": "Dict(String, Any)",
        "desc": "Raw CSS style declaration. Note this may be web browser dependent.",
        "default": {}
      },
      {
        "name": "text",
        "type": "String",
        "desc": "The text or HTML contents of the widget.\n\n    .. note::\n        If the HTML content contains elements which size depends on\n        on external, asynchronously loaded resources, the size of\n        the widget may be computed incorrectly. This is in particular\n        an issue with images (``<img>``). To remedy this problem, one\n        either has to set explicit dimensions using CSS properties,\n        HTML attributes or model's ``width`` and ``height`` properties,\n        or inline images' contents using data URIs.",
        "default": ""
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "MaxAggregator": {
    "name": "MaxAggregator",
    "bases": [
      "bokeh.models.widgets.tables.RowAggregator"
    ],
    "desc": "Largest value across multiple rows.",
    "proto": "{\"field_\": \"\", \"id\": \"4237\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "field_",
        "type": "String",
        "desc": "Refers to the table column being aggregated",
        "default": ""
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "MercatorAxis": {
    "name": "MercatorAxis",
    "bases": [
      "bokeh.models.axes.LinearAxis"
    ],
    "desc": "An axis that picks nice numbers for tick locations on a\n    Mercator scale. Configured with a ``MercatorTickFormatter`` by default.\n\n    Args:\n        dimension ('lat' or 'lon', optional) :\n            Whether this axis will display latitude or longitude values.\n            (default: 'lat')",
    "proto": "{\"axis_label\": \"\", \"axis_label_standoff\": 5, \"axis_label_text_align\": \"left\", \"axis_label_text_alpha\": 1.0, \"axis_label_text_baseline\": \"bottom\", \"axis_label_text_color\": \"#444444\", \"axis_label_text_font\": \"helvetica\", \"axis_label_text_font_size\": \"13px\", \"axis_label_text_font_style\": \"italic\", \"axis_label_text_line_height\": 1.2, \"axis_line_alpha\": 1.0, \"axis_line_cap\": \"butt\", \"axis_line_color\": \"black\", \"axis_line_dash\": [], \"axis_line_dash_offset\": 0, \"axis_line_join\": \"bevel\", \"axis_line_width\": 1, \"bounds\": \"auto\", \"fixed_location\": null, \"formatter\": {\"id\": \"4247\"}, \"id\": \"4244\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"guide\", \"major_label_orientation\": \"horizontal\", \"major_label_overrides\": {}, \"major_label_standoff\": 5, \"major_label_text_align\": \"center\", \"major_label_text_alpha\": 1.0, \"major_label_text_baseline\": \"alphabetic\", \"major_label_text_color\": \"#444444\", \"major_label_text_font\": \"helvetica\", \"major_label_text_font_size\": \"11px\", \"major_label_text_font_style\": \"normal\", \"major_label_text_line_height\": 1.2, \"major_tick_in\": 2, \"major_tick_line_alpha\": 1.0, \"major_tick_line_cap\": \"butt\", \"major_tick_line_color\": \"black\", \"major_tick_line_dash\": [], \"major_tick_line_dash_offset\": 0, \"major_tick_line_join\": \"bevel\", \"major_tick_line_width\": 1, \"major_tick_out\": 6, \"minor_tick_in\": 0, \"minor_tick_line_alpha\": 1.0, \"minor_tick_line_cap\": \"butt\", \"minor_tick_line_color\": \"black\", \"minor_tick_line_dash\": [], \"minor_tick_line_dash_offset\": 0, \"minor_tick_line_join\": \"bevel\", \"minor_tick_line_width\": 1, \"minor_tick_out\": 4, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"ticker\": {\"id\": \"4245\"}, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "axis_line_width",
        "type": "Float",
        "desc": "The line width of the axis line.",
        "default": 1
      },
      {
        "name": "major_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the major tick labels should be\n    offset from the associated ticks.",
        "default": 5
      },
      {
        "name": "axis_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the axis line.",
        "default": []
      },
      {
        "name": "major_tick_line_width",
        "type": "Float",
        "desc": "The line width of the major ticks.",
        "default": 1
      },
      {
        "name": "axis_line_color",
        "type": "Color",
        "desc": "The line color of the axis line.",
        "default": "black"
      },
      {
        "name": "axis_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the axis label.",
        "default": "italic"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default x-range.",
        "default": "default"
      },
      {
        "name": "axis_label",
        "type": "String",
        "desc": "A text label for the axis, displayed parallel to the axis rule.\n\n    .. note::\n        LaTeX notation is not currently supported; please see\n        :bokeh-issue:`647` to track progress or contribute.",
        "default": ""
      },
      {
        "name": "major_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the major ticks.",
        "default": 0
      },
      {
        "name": "minor_tick_line_width",
        "type": "Float",
        "desc": "The line width of the minor ticks.",
        "default": 1
      },
      {
        "name": "minor_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that minor ticks should extend into the\n    main plot area.",
        "default": 0
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "major_label_overrides",
        "type": "Dict(Either(Float, String), String)",
        "desc": "Provide explicit tick label values for specific tick locations that\n    override normal formatting.",
        "default": {}
      },
      {
        "name": "major_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the major tick labels.",
        "default": "center"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen\n    locations when rendering an axis on the plot. If unset, use the\n    default y-range.",
        "default": "default"
      },
      {
        "name": "formatter",
        "type": "Instance(TickFormatter)",
        "desc": "A ``TickFormatter`` to use for formatting the visual appearance\n    of ticks.",
        "default": "{\"id\": \"4336\"}"
      },
      {
        "name": "major_label_text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style of the major tick labels.",
        "default": "normal"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "ticker",
        "type": "Instance(Ticker)",
        "desc": "A Ticker to use for computing locations of axis components.\n\n    The property may also be passed a sequence of floating point numbers as\n    a shorthand for creating and configuring a ``FixedTicker``, e.g. the\n    following code\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n\n        p = figure()\n        p.xaxis.ticker = [10, 20, 37.4]\n\n    is equivalent to:\n\n    .. code-block:: python\n\n        from bokeh.plotting import figure\n        from bokeh.models import FixedTicker\n\n        p = figure()\n        p.xaxis.ticker = FixedTicker(ticks=[10, 20, 37.4])",
        "default": "{\"id\": \"4352\"}"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "axis_label_standoff",
        "type": "Int",
        "desc": "The distance in pixels that the axis labels should be offset\n    from the tick labels.",
        "default": 5
      },
      {
        "name": "major_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the major tick labels.",
        "default": "alphabetic"
      },
      {
        "name": "axis_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the axis label.",
        "default": 1.2
      },
      {
        "name": "axis_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the axis line.",
        "default": 0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "major_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the major ticks.",
        "default": 1.0
      },
      {
        "name": "major_tick_in",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend into the\n    main plot area.",
        "default": 2
      },
      {
        "name": "minor_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the minor ticks.",
        "default": []
      },
      {
        "name": "major_label_text_font",
        "type": "String",
        "desc": "The text font of the major tick labels.",
        "default": "helvetica"
      },
      {
        "name": "minor_tick_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the minor ticks.",
        "default": 1.0
      },
      {
        "name": "major_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the major tick labels.",
        "default": "11px"
      },
      {
        "name": "minor_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the minor ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align of the axis label.",
        "default": "left"
      },
      {
        "name": "major_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the major ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 4
      },
      {
        "name": "axis_label_text_color",
        "type": "Color",
        "desc": "The text color of the axis label.",
        "default": "#444444"
      },
      {
        "name": "fixed_location",
        "type": "Either(Float, String, Tuple(String, String), Tuple(String, String, String))",
        "desc": "Set to specify a fixed coordinate location to draw the axis. The direction\n    of ticks and major labels is determined by the side panel that the axis\n    belongs to.\n\n    .. note::\n        Axes labels are suppressed when axes are positioned at fixed locations\n        inside the central plot area.",
        "default": null
      },
      {
        "name": "major_tick_line_dash",
        "type": "DashPattern",
        "desc": "The line dash of the major ticks.",
        "default": []
      },
      {
        "name": "major_label_text_line_height",
        "type": "Float",
        "desc": "The text line height of the major tick labels.",
        "default": 1.2
      },
      {
        "name": "minor_tick_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the minor ticks.",
        "default": "butt"
      },
      {
        "name": "minor_tick_line_color",
        "type": "Color",
        "desc": "The line color of the minor ticks.",
        "default": "black"
      },
      {
        "name": "axis_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the axis line.",
        "default": "bevel"
      },
      {
        "name": "major_tick_out",
        "type": "Int",
        "desc": "The distance in pixels that major ticks should extend out of the\n    main plot area.",
        "default": 6
      },
      {
        "name": "axis_label_text_font_size",
        "type": "FontSize",
        "desc": "The text font size of the axis label.",
        "default": "13px"
      },
      {
        "name": "axis_line_alpha",
        "type": "Percent",
        "desc": "The line alpha of the axis line.",
        "default": 1.0
      },
      {
        "name": "major_label_orientation",
        "type": "Either(Enum('horizontal', 'vertical'), Float)",
        "desc": "What direction the major label text should be oriented. If a\n    number is supplied, the angle of the text is measured from horizontal.",
        "default": "horizontal"
      },
      {
        "name": "minor_tick_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset of the minor ticks.",
        "default": 0
      },
      {
        "name": "major_tick_line_color",
        "type": "Color",
        "desc": "The line color of the major ticks.",
        "default": "black"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "major_label_text_color",
        "type": "Color",
        "desc": "The text color of the major tick labels.",
        "default": "#444444"
      },
      {
        "name": "axis_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap of the axis line.",
        "default": "butt"
      },
      {
        "name": "major_tick_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join of the major ticks.",
        "default": "bevel"
      },
      {
        "name": "axis_label_text_font",
        "type": "String",
        "desc": "The text font of the axis label.",
        "default": "helvetica"
      },
      {
        "name": "axis_label_text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline of the axis label.",
        "default": "bottom"
      },
      {
        "name": "axis_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the axis label.",
        "default": 1.0
      },
      {
        "name": "major_label_text_alpha",
        "type": "Percent",
        "desc": "The text alpha of the major tick labels.",
        "default": 1.0
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "guide"
      },
      {
        "name": "bounds",
        "type": "Either(Auto, Tuple(Float, Float), Tuple(Datetime, Datetime))",
        "desc": "Bounds for the rendered axis. If unset, the axis will span the\n    entire plot in the given dimension.",
        "default": "auto"
      }
    ]
  },
  "MercatorTickFormatter": {
    "name": "MercatorTickFormatter",
    "bases": [
      "bokeh.models.formatters.BasicTickFormatter"
    ],
    "desc": "A ``TickFormatter`` for values in WebMercator units.\n\n    Some map plot types internally use WebMercator to describe coordinates,\n    plot bounds, etc. These units are not very human-friendly. This tick\n    formatter will convert WebMercator units into Latitude and Longitude\n    for display on axes.",
    "proto": "{\"dimension\": null, \"id\": \"4548\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"power_limit_high\": 5, \"power_limit_low\": -3, \"precision\": \"auto\", \"subscribed_events\": [], \"tags\": [], \"use_scientific\": true}",
    "props": [
      {
        "name": "precision",
        "type": "Either(Auto, Int)",
        "desc": "How many digits of precision to display in tick labels.",
        "default": "auto"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "dimension",
        "type": "Enum('lat', 'lon')",
        "desc": "Specify whether to format ticks for Latitude or Longitude.\n\n    Projected coordinates are not separable, computing Latitude and Longitude\n    tick labels from Web Mercator requires considering coordinates from both\n    dimensions together. Use this property to specify which result should be\n    used for display.\n\n    Typically, if the formatter is for an x-axis, then dimension should be\n    ``\"lon\"`` and if the formatter is for a y-axis, then the dimension\n    should be `\"lat\"``.\n\n    In order to prevent hard to debug errors, there is no default value for\n    dimension. Using an un-configured ``MercatorTickFormatter`` will result in\n    a validation error and a JavaScript console error.",
        "default": null
      },
      {
        "name": "power_limit_low",
        "type": "Int",
        "desc": "Limit the use of scientific notation to when::\n\n        log(x) <= power_limit_low",
        "default": -3
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "use_scientific",
        "type": "Bool",
        "desc": "Whether to ever display scientific notation. If ``True``, then\n    when to use scientific notation is controlled by ``power_limit_low``\n    and ``power_limit_high``.",
        "default": true
      },
      {
        "name": "power_limit_high",
        "type": "Int",
        "desc": "Limit the use of scientific notation to when::\n\n        log(x) >= power_limit_high",
        "default": 5
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "MercatorTicker": {
    "name": "MercatorTicker",
    "bases": [
      "bokeh.models.tickers.BasicTicker"
    ],
    "desc": "Generate nice lat/lon ticks form underlying WebMercator coordinates.",
    "proto": "{\"base\": 10.0, \"desired_num_ticks\": 6, \"dimension\": null, \"id\": \"4559\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mantissas\": [1, 2, 5], \"max_interval\": null, \"min_interval\": 0.0, \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mantissas",
        "type": "Seq(Float)",
        "desc": "The acceptable list numbers to generate multiples of.",
        "default": [
          1,
          2,
          5
        ]
      },
      {
        "name": "base",
        "type": "Float",
        "desc": "The multiplier to use for scaling mantissas.",
        "default": 10.0
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "dimension",
        "type": "Enum('lat', 'lon')",
        "desc": "Specify whether to generate ticks for Latitude or Longitude.\n\n    Projected coordinates are not separable, computing Latitude and Longitude\n    tick locations from Web Mercator requires considering coordinates from\n    both dimensions together. Use this property to specify which result should\n    be returned.\n\n    Typically, if the ticker is for an x-axis, then dimension should be\n    ``\"lon\"`` and if the ticker is for a y-axis, then the dimension\n    should be `\"lat\"``.\n\n    In order to prevent hard to debug errors, there is no default value for\n    dimension. Using an un-configured ``MercatorTicker`` will result in a\n    validation error and a JavaScript console error.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "min_interval",
        "type": "Float",
        "desc": "The smallest allowable interval between two adjacent ticks.",
        "default": 0.0
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "max_interval",
        "type": "Float",
        "desc": "The largest allowable interval between two adjacent ticks.\n\n    .. note::\n        To specify an unbounded interval, set to ``None``.",
        "default": null
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "MercatorTileSource": {
    "name": "MercatorTileSource",
    "bases": [
      "bokeh.models.tiles.TileSource"
    ],
    "desc": "A base class for Mercator tile services (e.g. ``WMTSTileSource``).",
    "proto": "{\"attribution\": \"\", \"extra_url_vars\": {}, \"id\": \"4572\", \"initial_resolution\": 156543.03392804097, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_zoom\": 30, \"min_zoom\": 0, \"name\": null, \"snap_to_zoom\": false, \"subscribed_events\": [], \"tags\": [], \"tile_size\": 256, \"url\": \"\", \"wrap_around\": true, \"x_origin_offset\": 20037508.34, \"y_origin_offset\": 20037508.34}",
    "props": [
      {
        "name": "url",
        "type": "String",
        "desc": "Tile service url e.g., http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png",
        "default": ""
      },
      {
        "name": "wrap_around",
        "type": "Bool",
        "desc": "Enables continuous horizontal panning by wrapping the x-axis based on\n    bounds of map.\n\n    ..note::\n        Axis coordinates are not wrapped. To toggle axis label visibility,\n        use ``plot.axis.visible = False``.",
        "default": true
      },
      {
        "name": "tile_size",
        "type": "Int",
        "desc": "Tile size in pixels (e.g. 256)",
        "default": 256
      },
      {
        "name": "extra_url_vars",
        "type": "Dict(String, Any)",
        "desc": "A dictionary that maps url variable template keys to values.\n\n    These variables are useful for parts of tile urls which do not change from\n    tile to tile (e.g. server host name, or layer name).",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "initial_resolution",
        "type": "Float",
        "desc": "Resolution (plot_units / pixels) of minimum zoom level of tileset\n    projection. None to auto-compute.",
        "default": 156543.03392804097
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "y_origin_offset",
        "type": "Float",
        "desc": "A y-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "x_origin_offset",
        "type": "Float",
        "desc": "An x-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "max_zoom",
        "type": "Int",
        "desc": "A maximum zoom level for the tile layer. This is the most zoomed-in level.",
        "default": 30
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "min_zoom",
        "type": "Int",
        "desc": "A minimum zoom level for the tile layer. This is the most zoomed-out level.",
        "default": 0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "snap_to_zoom",
        "type": "Bool",
        "desc": "Forces initial extents to snap to the closest larger zoom level.",
        "default": false
      },
      {
        "name": "attribution",
        "type": "String",
        "desc": "Data provider attribution content. This can include HTML content.",
        "default": ""
      }
    ]
  },
  "MinAggregator": {
    "name": "MinAggregator",
    "bases": [
      "bokeh.models.widgets.tables.RowAggregator"
    ],
    "desc": "Smallest value across multiple rows.",
    "proto": "{\"field_\": \"\", \"id\": \"4589\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "field_",
        "type": "String",
        "desc": "Refers to the table column being aggregated",
        "default": ""
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "MonthsTicker": {
    "name": "MonthsTicker",
    "bases": [
      "bokeh.models.tickers.SingleIntervalTicker"
    ],
    "desc": "Generate ticks spaced apart by specific, even multiples of months.",
    "proto": "{\"desired_num_ticks\": 6, \"id\": \"4596\", \"interval\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"months\": [], \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "months",
        "type": "Seq(Int)",
        "desc": "The intervals of months to use.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "interval",
        "type": "Float",
        "desc": "The interval between adjacent ticks.",
        "default": null
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "MultiChoice": {
    "name": "MultiChoice",
    "bases": [
      "bokeh.models.widgets.inputs.InputWidget"
    ],
    "desc": "MultiChoice widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"delete_button\": true, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"4606\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_items\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"option_limit\": null, \"options\": [], \"orientation\": \"horizontal\", \"placeholder\": null, \"sizing_mode\": null, \"solid\": true, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"value\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "solid",
        "type": "Bool",
        "desc": "Specify whether the choices should be solidly filled.",
        "default": true
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "max_items",
        "type": "Int",
        "desc": "The maximum number of items that can be selected.",
        "default": null
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "option_limit",
        "type": "Int",
        "desc": "The number of choices that will be rendered in the dropdown.",
        "default": null
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "delete_button",
        "type": "Bool",
        "desc": "Whether to add a button to remove a selected option.",
        "default": true
      },
      {
        "name": "placeholder",
        "type": "String",
        "desc": "A string that is displayed if not item is added.",
        "default": null
      },
      {
        "name": "value",
        "type": "List(String)",
        "desc": "Initial or selected values.",
        "default": []
      },
      {
        "name": "options",
        "type": "List(Either(String, Tuple(String, String)))",
        "desc": "Available selection options. Options may be provided either as a list of\n    possible string values, or as a list of tuples, each of the form\n    ``(value, label)``. In the latter case, the visible widget text for each\n    value will be corresponding given label.",
        "default": []
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "MultiLine": {
    "name": "MultiLine",
    "bases": [
      "bokeh.models.glyph.LineGlyph"
    ],
    "desc": "Render several lines.\n\n    The data for the ``MultiLine`` glyph is different in that the vector of\n    values is not a vector of scalars. Rather, it is a \"list of lists\".\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/MultiLine.py\n        :source-position: below",
    "proto": "{\"id\": \"4638\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"xs\": null, \"ys\": null}",
    "props": [
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the lines.",
        "default": "butt"
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the lines.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the lines.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the lines.",
        "default": "black"
      },
      {
        "name": "ys",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates for all the lines, given as a \"list of lists\".",
        "default": null
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the lines.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "xs",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates for all the lines, given as a \"list of lists\".",
        "default": null
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the lines.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the lines.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "MultiPolygons": {
    "name": "MultiPolygons",
    "bases": [
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph",
      "bokeh.models.glyph.HatchGlyph"
    ],
    "desc": "Render several MultiPolygon.\n\n    Modeled on geoJSON - the data for the ``MultiPolygons`` glyph is\n    different in that the vector of values is not a vector of scalars.\n    Rather, it is a \"list of lists of lists of lists\".\n\n    During box selection only multi-polygons entirely contained in the\n    selection box will be included.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/MultiPolygons.py\n        :source-position: below",
    "proto": "{\"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"hatch_alpha\": {\"value\": 1.0}, \"hatch_color\": {\"value\": \"black\"}, \"hatch_extra\": {}, \"hatch_pattern\": null, \"hatch_scale\": {\"value\": 12.0}, \"hatch_weight\": {\"value\": 1.0}, \"id\": \"4653\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"xs\": null, \"ys\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the multipolygons.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the multipolygons.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the multipolygons.",
        "default": "black"
      },
      {
        "name": "hatch_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch alpha values for the patches.",
        "default": 1.0
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the multipolygons.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the multipolygons.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "hatch_weight",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch weight values for the patches.",
        "default": 1.0
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the multipolygons.",
        "default": 1.0
      },
      {
        "name": "hatch_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The hatch color values for the patches.",
        "default": "black"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the multipolygons.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the multipolygons.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "hatch_pattern",
        "type": "HatchPatternSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), HatchPatternType)), HatchPatternType)",
        "desc": "The hatch pattern values for the patches.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "ys",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates for all the patches, given as a \"list of lists\".\n\n    .. note::\n        Each item in ``MultiPolygons`` represents one MultiPolygon and each\n        MultiPolygon is comprised of ``n`` Polygons. Each Polygon is made of\n        one exterior ring optionally followed by ``m`` interior rings (holes).",
        "default": null
      },
      {
        "name": "xs",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates for all the patches, given as a nested list.\n\n    .. note::\n        Each item in ``MultiPolygons`` represents one MultiPolygon and each\n        MultiPolygon is comprised of ``n`` Polygons. Each Polygon is made of\n        one exterior ring optionally followed by ``m`` interior rings (holes).",
        "default": null
      },
      {
        "name": "hatch_extra",
        "type": "Dict(String, Instance(Texture))",
        "desc": "The hatch extra values for the patches.",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the multipolygons.",
        "default": "bevel"
      },
      {
        "name": "hatch_scale",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch scale values for the patches.",
        "default": 12.0
      }
    ]
  },
  "MultiSelect": {
    "name": "MultiSelect",
    "bases": [
      "bokeh.models.widgets.inputs.InputWidget"
    ],
    "desc": "Multi-select widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"4676\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"options\": [], \"orientation\": \"horizontal\", \"size\": 4, \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"value\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "size",
        "type": "Int",
        "desc": "The number of visible options in the dropdown list. (This uses the\n    ``select`` HTML element's ``size`` attribute. Some browsers might not\n    show less than 3 options.)",
        "default": 4
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "value",
        "type": "List(String)",
        "desc": "Initial or selected values.",
        "default": []
      },
      {
        "name": "options",
        "type": "List(Either(String, Tuple(String, String)))",
        "desc": "Available selection options. Options may be provided either as a list of\n    possible string values, or as a list of tuples, each of the form\n    ``(value, label)``. In the latter case, the visible widget text for each\n    value will be corresponding given label.",
        "default": []
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "NodesAndLinkedEdges": {
    "name": "NodesAndLinkedEdges",
    "bases": [
      "bokeh.models.graphs.GraphHitTestPolicy"
    ],
    "desc": "With the ``NodesAndLinkedEdges`` policy, inspection or selection of graph\n    nodes will result in the inspection or selection of the node and of the\n    linked graph edges. There is no direct selection or inspection of graph\n    edges.",
    "proto": "{\"id\": \"4704\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "NodesOnly": {
    "name": "NodesOnly",
    "bases": [
      "bokeh.models.graphs.GraphHitTestPolicy"
    ],
    "desc": "With the ``NodesOnly`` policy, only graph nodes are able to be selected and\n    inspected. There is no selection or inspection of graph edges.",
    "proto": "{\"id\": \"4710\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "NormalHead": {
    "name": "NormalHead",
    "bases": [
      "bokeh.models.arrow_heads.ArrowHead"
    ],
    "desc": "Render a closed-body arrow head.",
    "proto": "{\"fill_alpha\": 1.0, \"fill_color\": \"black\", \"id\": \"4716\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"line_alpha\": 1.0, \"line_cap\": \"butt\", \"line_color\": \"black\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"name\": null, \"size\": 25, \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the arrow head outline.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the arrow head interior.",
        "default": 1.0
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the arrow head outline.",
        "default": []
      },
      {
        "name": "size",
        "type": "Float",
        "desc": "The size, in pixels, of the arrow head.",
        "default": 25
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the arrow head outline.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the arrow head outline.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "Color",
        "desc": "The fill color values for the arrow head interior.",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the arrow head outline.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the arrow head outline.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the arrow head outline.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "NumberEditor": {
    "name": "NumberEditor",
    "bases": [
      "bokeh.models.widgets.tables.CellEditor"
    ],
    "desc": "Spinner-based number cell editor.",
    "proto": "{\"id\": \"4734\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"step\": 0.01, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "step",
        "type": "Float",
        "desc": "The major step value.",
        "default": 0.01
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "NumberFormatter": {
    "name": "NumberFormatter",
    "bases": [
      "bokeh.models.widgets.tables.StringFormatter"
    ],
    "desc": "Number cell formatter.",
    "proto": "{\"font_style\": \"normal\", \"format\": \"0,0\", \"id\": \"4741\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"language\": \"en\", \"name\": null, \"rounding\": \"round\", \"subscribed_events\": [], \"tags\": [], \"text_align\": \"left\", \"text_color\": null}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "An optional text font style, e.g. bold, italic.",
        "default": "normal"
      },
      {
        "name": "text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "An optional text align, i.e. left, center or right.",
        "default": "left"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "text_color",
        "type": "Color",
        "desc": "An optional text color. See :class:`bokeh.core.properties.Color` for\n    details.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "format",
        "type": "String",
        "desc": "The number format, as defined in the following tables:\n\n    **NUMBERS**:\n\n    ============ ============== ===============\n    Number       Format         String\n    ============ ============== ===============\n    10000        '0,0.0000'     10,000.0000\n    10000.23     '0,0'          10,000\n    10000.23     '+0,0'         +10,000\n    -10000       '0,0.0'        -10,000.0\n    10000.1234   '0.000'        10000.123\n    10000.1234   '0[.]00000'    10000.12340\n    -10000       '(0,0.0000)'   (10,000.0000)\n    -0.23        '.00'          -.23\n    -0.23        '(.00)'        (.23)\n    0.23         '0.00000'      0.23000\n    0.23         '0.0[0000]'    0.23\n    1230974      '0.0a'         1.2m\n    1460         '0 a'          1 k\n    -104000      '0a'           -104k\n    1            '0o'           1st\n    52           '0o'           52nd\n    23           '0o'           23rd\n    100          '0o'           100th\n    ============ ============== ===============\n\n    **CURRENCY**:\n\n    =========== =============== =============\n    Number      Format          String\n    =========== =============== =============\n    1000.234    '$0,0.00'       $1,000.23\n    1000.2      '0,0[.]00 $'    1,000.20 $\n    1001        '$ 0,0[.]00'    $ 1,001\n    -1000.234   '($0,0)'        ($1,000)\n    -1000.234   '$0.00'         -$1000.23\n    1230974     '($ 0.00 a)'    $ 1.23 m\n    =========== =============== =============\n\n    **BYTES**:\n\n    =============== =========== ============\n    Number          Format      String\n    =============== =========== ============\n    100             '0b'        100B\n    2048            '0 b'       2 KB\n    7884486213      '0.0b'      7.3GB\n    3467479682787   '0.000 b'   3.154 TB\n    =============== =========== ============\n\n    **PERCENTAGES**:\n\n    ============= ============= ===========\n    Number        Format        String\n    ============= ============= ===========\n    1             '0%'          100%\n    0.974878234   '0.000%'      97.488%\n    -0.43         '0 %'         -43 %\n    0.43          '(0.000 %)'   43.000 %\n    ============= ============= ===========\n\n    **TIME**:\n\n    ============ ============== ============\n    Number       Format         String\n    ============ ============== ============\n    25           '00:00:00'     0:00:25\n    238          '00:00:00'     0:03:58\n    63846        '00:00:00'     17:44:06\n    ============ ============== ============\n\n    For the complete specification, see http://numbrojs.com/format.html",
        "default": "0,0"
      },
      {
        "name": "language",
        "type": "Enum('be-nl', 'chs', 'cs', 'da-dk', 'de-ch', 'de', 'en', 'en-gb', 'es-ES', 'es', 'et', 'fi', 'fr-CA', 'fr-ch', 'fr', 'hu', 'it', 'ja', 'nl-nl', 'pl', 'pt-br', 'pt-pt', 'ru', 'ru-UA', 'sk', 'th', 'tr', 'uk-UA')",
        "desc": "The language to use for formatting language-specific features (e.g. thousands separator).",
        "default": "en"
      },
      {
        "name": "rounding",
        "type": "Enum('round', 'nearest', 'floor', 'rounddown', 'ceil', 'roundup')",
        "desc": "Rounding functions (round, floor, ceil) and their synonyms (nearest, rounddown, roundup).",
        "default": "round"
      }
    ]
  },
  "NumeralTickFormatter": {
    "name": "NumeralTickFormatter",
    "bases": [
      "bokeh.models.formatters.TickFormatter"
    ],
    "desc": "Tick formatter based on a human-readable format string.",
    "proto": "{\"format\": \"0,0\", \"id\": \"4753\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"language\": \"en\", \"name\": null, \"rounding\": \"round\", \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "format",
        "type": "String",
        "desc": "The number format, as defined in the following tables:\n\n    **NUMBERS**:\n\n    ============ ============== ===============\n    Number       Format         String\n    ============ ============== ===============\n    10000        '0,0.0000'     10,000.0000\n    10000.23     '0,0'          10,000\n    10000.23     '+0,0'         +10,000\n    -10000       '0,0.0'        -10,000.0\n    10000.1234   '0.000'        10000.123\n    10000.1234   '0[.]00000'    10000.12340\n    -10000       '(0,0.0000)'   (10,000.0000)\n    -0.23        '.00'          -.23\n    -0.23        '(.00)'        (.23)\n    0.23         '0.00000'      0.23000\n    0.23         '0.0[0000]'    0.23\n    1230974      '0.0a'         1.2m\n    1460         '0 a'          1 k\n    -104000      '0a'           -104k\n    1            '0o'           1st\n    52           '0o'           52nd\n    23           '0o'           23rd\n    100          '0o'           100th\n    ============ ============== ===============\n\n    **CURRENCY**:\n\n    =========== =============== =============\n    Number      Format          String\n    =========== =============== =============\n    1000.234    '$0,0.00'       $1,000.23\n    1000.2      '0,0[.]00 $'    1,000.20 $\n    1001        '$ 0,0[.]00'    $ 1,001\n    -1000.234   '($0,0)'        ($1,000)\n    -1000.234   '$0.00'         -$1000.23\n    1230974     '($ 0.00 a)'    $ 1.23 m\n    =========== =============== =============\n\n    **BYTES**:\n\n    =============== =========== ============\n    Number          Format      String\n    =============== =========== ============\n    100             '0b'        100B\n    2048            '0 b'       2 KB\n    7884486213      '0.0b'      7.3GB\n    3467479682787   '0.000 b'   3.154 TB\n    =============== =========== ============\n\n    **PERCENTAGES**:\n\n    ============= ============= ===========\n    Number        Format        String\n    ============= ============= ===========\n    1             '0%'          100%\n    0.974878234   '0.000%'      97.488%\n    -0.43         '0 %'         -43 %\n    0.43          '(0.000 %)'   43.000 %\n    ============= ============= ===========\n\n    **TIME**:\n\n    ============ ============== ============\n    Number       Format         String\n    ============ ============== ============\n    25           '00:00:00'     0:00:25\n    238          '00:00:00'     0:03:58\n    63846        '00:00:00'     17:44:06\n    ============ ============== ============\n\n    For the complete specification, see http://numbrojs.com/format.html",
        "default": "0,0"
      },
      {
        "name": "language",
        "type": "Enum('be-nl', 'chs', 'cs', 'da-dk', 'de-ch', 'de', 'en', 'en-gb', 'es-ES', 'es', 'et', 'fi', 'fr-CA', 'fr-ch', 'fr', 'hu', 'it', 'ja', 'nl-nl', 'pl', 'pt-br', 'pt-pt', 'ru', 'ru-UA', 'sk', 'th', 'tr', 'uk-UA')",
        "desc": "The language to use for formatting language-specific features (e.g. thousands separator).",
        "default": "en"
      },
      {
        "name": "rounding",
        "type": "Enum('round', 'nearest', 'floor', 'rounddown', 'ceil', 'roundup')",
        "desc": "Rounding functions (round, floor, ceil) and their synonyms (nearest, rounddown, roundup).",
        "default": "round"
      }
    ]
  },
  "OpenHead": {
    "name": "OpenHead",
    "bases": [
      "bokeh.models.arrow_heads.ArrowHead"
    ],
    "desc": "Render an open-body arrow head.",
    "proto": "{\"id\": \"4762\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"line_alpha\": 1.0, \"line_cap\": \"butt\", \"line_color\": \"black\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"name\": null, \"size\": 25, \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the arrow head outline.",
        "default": "butt"
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the arrow head outline.",
        "default": []
      },
      {
        "name": "size",
        "type": "Float",
        "desc": "The size, in pixels, of the arrow head.",
        "default": 25
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the arrow head outline.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the arrow head outline.",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the arrow head outline.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the arrow head outline.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the arrow head outline.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "OpenURL": {
    "name": "OpenURL",
    "bases": [
      "bokeh.models.callbacks.Callback"
    ],
    "desc": "Open a URL in a new or current tab or window.",
    "proto": "{\"id\": \"4778\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"same_tab\": false, \"subscribed_events\": [], \"tags\": [], \"url\": \"http://\"}",
    "props": [
      {
        "name": "url",
        "type": "String",
        "desc": "The URL to direct the web browser to. This can be a template string,\n    which will be formatted with data from the data source.",
        "default": "http://"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "same_tab",
        "type": "Bool",
        "desc": "Open URL in a new (`False`, default) or current (`True`) tab or window.\n    For `same_tab=False`, whether tab or window will be opened is browser\n    dependent.",
        "default": false
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Oval": {
    "name": "Oval",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph"
    ],
    "desc": "Render ovals.\n\n    This glyph renders ovals using Bezier curves, which are similar,\n    but not identical to ellipses. In particular, widths equal to heights\n    will not render circles. Use the ``Ellipse`` glyph for that.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Oval.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"height\": null, \"id\": \"4786\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"width\": null, \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the ovals.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the ovals.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the ovals.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the ovals.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the ovals.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the ovals.",
        "default": 1.0
      },
      {
        "name": "width",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The overall widths of each oval.",
        "default": null
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the centers of the ovals.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "height",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The overall height of each oval.",
        "default": null
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angle the ovals are rotated from horizontal. [rad]",
        "default": 0.0
      },
      {
        "name": "height_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the ovals.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the ovals.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "width_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the ovals.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the centers of the ovals.",
        "default": null
      }
    ]
  },
  "PanTool": {
    "name": "PanTool",
    "bases": [
      "bokeh.models.tools.Drag"
    ],
    "desc": "*toolbar icon*: |pan_icon|\n\n    The pan tool allows the user to pan a Plot by left-dragging a mouse, or on\n    touch devices by dragging a finger or stylus, across the plot region.\n\n    The pan tool also activates the border regions of a Plot for \"single axis\"\n    panning. For instance, dragging in the vertical border or axis will effect\n    a pan in the vertical direction only, with horizontal dimension kept fixed.\n\n    .. |pan_icon| image:: /_images/icons/Pan.png\n        :height: 24px",
    "proto": "{\"dimensions\": \"both\", \"id\": \"4809\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "dimensions",
        "type": "Enum('width', 'height', 'both')",
        "desc": "Which dimensions the pan tool is constrained to act in. By default\n    the pan tool will pan in any dimension, but can be configured to only\n    pan horizontally across the width of the plot, or vertically across the\n    height of the plot.",
        "default": "both"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Panel": {
    "name": "Panel",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A single-widget container with title bar and controls.",
    "proto": "{\"child\": null, \"closable\": false, \"id\": \"4816\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\"}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "child",
        "type": "Instance(LayoutDOM)",
        "desc": "The child widget. If you need more children, use a layout widget, e.g. a ``Column``.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "title",
        "type": "String",
        "desc": "The text title of the panel.",
        "default": ""
      },
      {
        "name": "closable",
        "type": "Bool",
        "desc": "Whether this panel is closable or not. If True, an \"x\" button will appear.\n\n    Closing a panel is equivalent to removing it from its parent container (e.g. tabs).",
        "default": false
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Paragraph": {
    "name": "Paragraph",
    "bases": [
      "bokeh.models.widgets.markups.Markup"
    ],
    "desc": "A block (paragraph) of text.\n\n    This Bokeh model corresponds to an HTML ``<p>`` element.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../sphinx/source/docs/user_guide/examples/interaction_paragraph.py\n        :source-position: below",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"4825\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"style\": {}, \"subscribed_events\": [], \"tags\": [], \"text\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "style",
        "type": "Dict(String, Any)",
        "desc": "Raw CSS style declaration. Note this may be web browser dependent.",
        "default": {}
      },
      {
        "name": "text",
        "type": "String",
        "desc": "The text or HTML contents of the widget.\n\n    .. note::\n        If the HTML content contains elements which size depends on\n        on external, asynchronously loaded resources, the size of\n        the widget may be computed incorrectly. This is in particular\n        an issue with images (``<img>``). To remedy this problem, one\n        either has to set explicit dimensions using CSS properties,\n        HTML attributes or model's ``width`` and ``height`` properties,\n        or inline images' contents using data URIs.",
        "default": ""
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "PasswordInput": {
    "name": "PasswordInput",
    "bases": [
      "bokeh.models.widgets.inputs.TextInput"
    ],
    "desc": "Single-line password input widget.\n\n    This widget hides the input value so that it is not visible in the browser.\n\n    .. warning::\n        Secure transmission of the password to Bokeh server application code\n        requires configuring the server for SSL (i.e. HTTPS) termination.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"4851\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"placeholder\": \"\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"value\": \"\", \"value_input\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "placeholder",
        "type": "String",
        "desc": "Placeholder for empty input field.",
        "default": ""
      },
      {
        "name": "value",
        "type": "String",
        "desc": "Initial or entered text value.\n\n    Change events are triggered whenever <enter> is pressed.",
        "default": ""
      },
      {
        "name": "value_input",
        "type": "String",
        "desc": "Initial or current value.\n\n    Change events are triggered whenever any update happens, i.e. on every\n    keypress.",
        "default": ""
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Patch": {
    "name": "Patch",
    "bases": [
      "bokeh.models.glyph.ConnectedXYGlyph",
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph",
      "bokeh.models.glyph.HatchGlyph"
    ],
    "desc": "Render a single patch.\n\n    The ``Patch`` glyph is different from most other glyphs in that the vector\n    of values only produces one glyph on the Plot.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Patch.py\n        :source-position: below",
    "proto": "{\"fill_alpha\": 1.0, \"fill_color\": \"gray\", \"hatch_alpha\": 1.0, \"hatch_color\": \"black\", \"hatch_extra\": {}, \"hatch_pattern\": null, \"hatch_scale\": 12.0, \"hatch_weight\": 1.0, \"id\": \"4879\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": 1.0, \"line_cap\": \"butt\", \"line_color\": \"black\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the patch.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the patch.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the patch.",
        "default": "black"
      },
      {
        "name": "hatch_alpha",
        "type": "Percent",
        "desc": "The hatch alpha values for the patch.",
        "default": 1.0
      },
      {
        "name": "fill_color",
        "type": "Color",
        "desc": "The fill color values for the patch.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the patch.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "hatch_weight",
        "type": "Size",
        "desc": "The hatch weight values for the patch.",
        "default": 1.0
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the patch.",
        "default": 1.0
      },
      {
        "name": "hatch_color",
        "type": "Color",
        "desc": "The hatch color values for the patch.",
        "default": "black"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates for the points of the patch.\n\n    .. note::\n        A patch may comprise multiple polygons. In this case the\n        y-coordinates for each polygon should be separated by NaN\n        values in the sequence.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the patch.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the patch.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "hatch_pattern",
        "type": "String",
        "desc": "The hatch pattern values for the patch.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "hatch_extra",
        "type": "Dict(String, Instance(Texture))",
        "desc": "The hatch extra values for the patch.",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the patch.",
        "default": "bevel"
      },
      {
        "name": "hatch_scale",
        "type": "Size",
        "desc": "The hatch scale values for the patch.",
        "default": 12.0
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates for the points of the patch.\n\n    .. note::\n        A patch may comprise multiple polygons. In this case the\n        x-coordinates for each polygon should be separated by NaN\n        values in the sequence.",
        "default": null
      }
    ]
  },
  "Patches": {
    "name": "Patches",
    "bases": [
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph",
      "bokeh.models.glyph.HatchGlyph"
    ],
    "desc": "Render several patches.\n\n    The data for the ``Patches`` glyph is different in that the vector of\n    values is not a vector of scalars. Rather, it is a \"list of lists\".\n\n    During box selection only patches entirely contained in the\n    selection box will be included.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Patches.py\n        :source-position: below",
    "proto": "{\"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"hatch_alpha\": {\"value\": 1.0}, \"hatch_color\": {\"value\": \"black\"}, \"hatch_extra\": {}, \"hatch_pattern\": null, \"hatch_scale\": {\"value\": 12.0}, \"hatch_weight\": {\"value\": 1.0}, \"id\": \"4902\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"xs\": null, \"ys\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the patches.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the patches.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the patches.",
        "default": "black"
      },
      {
        "name": "hatch_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch alpha values for the patches.",
        "default": 1.0
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the patches.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the patches.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "hatch_weight",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch weight values for the patches.",
        "default": 1.0
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the patches.",
        "default": 1.0
      },
      {
        "name": "hatch_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The hatch color values for the patches.",
        "default": "black"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the patches.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the patches.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "hatch_pattern",
        "type": "HatchPatternSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), HatchPatternType)), HatchPatternType)",
        "desc": "The hatch pattern values for the patches.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "ys",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates for all the patches, given as a \"list of lists\".\n\n    .. note::\n        Individual patches may comprise multiple polygons. In this case\n        the y-coordinates for each polygon should be separated by NaN\n        values in the sublists.",
        "default": null
      },
      {
        "name": "xs",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates for all the patches, given as a \"list of lists\".\n\n    .. note::\n        Individual patches may comprise multiple polygons. In this case\n        the x-coordinates for each polygon should be separated by NaN\n        values in the sublists.",
        "default": null
      },
      {
        "name": "hatch_extra",
        "type": "Dict(String, Instance(Texture))",
        "desc": "The hatch extra values for the patches.",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the patches.",
        "default": "bevel"
      },
      {
        "name": "hatch_scale",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch scale values for the patches.",
        "default": 12.0
      }
    ]
  },
  "PercentEditor": {
    "name": "PercentEditor",
    "bases": [
      "bokeh.models.widgets.tables.CellEditor"
    ],
    "desc": "``IntEditor`` optimized for editing percentages.",
    "proto": "{\"id\": \"4925\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Plot": {
    "name": "Plot",
    "bases": [
      "bokeh.models.layouts.LayoutDOM"
    ],
    "desc": "Model representing a plot, containing glyphs, guides, annotations.",
    "proto": "{\"above\": [], \"align\": \"start\", \"aspect_ratio\": null, \"aspect_scale\": 1, \"background\": null, \"background_fill_alpha\": 1.0, \"background_fill_color\": \"#ffffff\", \"below\": [], \"border_fill_alpha\": 1.0, \"border_fill_color\": \"#ffffff\", \"center\": [], \"css_classes\": [], \"disabled\": false, \"extra_x_ranges\": {}, \"extra_y_ranges\": {}, \"frame_height\": null, \"frame_width\": null, \"height\": null, \"height_policy\": \"auto\", \"hidpi\": true, \"id\": \"4931\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"left\": [], \"lod_factor\": 10, \"lod_interval\": 300, \"lod_threshold\": 2000, \"lod_timeout\": 500, \"margin\": [0, 0, 0, 0], \"match_aspect\": false, \"max_height\": null, \"max_width\": null, \"min_border\": 5, \"min_border_bottom\": null, \"min_border_left\": null, \"min_border_right\": null, \"min_border_top\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"outline_line_alpha\": 1.0, \"outline_line_cap\": \"butt\", \"outline_line_color\": \"#e5e5e5\", \"outline_line_dash\": [], \"outline_line_dash_offset\": 0, \"outline_line_join\": \"bevel\", \"outline_line_width\": 1, \"output_backend\": \"canvas\", \"plot_height\": 600, \"plot_width\": 600, \"renderers\": [], \"reset_policy\": \"standard\", \"right\": [], \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": {\"id\": \"4935\"}, \"title_location\": \"above\", \"toolbar\": {\"id\": \"4934\"}, \"toolbar_location\": \"right\", \"toolbar_sticky\": true, \"visible\": true, \"width\": null, \"width_policy\": \"auto\", \"x_range\": {\"id\": \"4932\"}, \"x_scale\": {\"id\": \"4933\"}, \"y_range\": {\"id\": \"4936\"}, \"y_scale\": {\"id\": \"4937\"}}",
    "props": [
      {
        "name": "outline_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap for the plot border outline.",
        "default": "butt"
      },
      {
        "name": "outline_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset for the plot border outline.",
        "default": 0
      },
      {
        "name": "min_border_right",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region to the right of\n    the central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "match_aspect",
        "type": "Bool",
        "desc": "Specify the aspect ratio behavior of the plot. Aspect ratio is defined as\n    the ratio of width over height. This property controls whether Bokeh should\n    attempt the match the (width/height) of *data space* to the (width/height)\n    in pixels of *screen space*.\n\n    Default is ``False`` which indicates that the *data* aspect ratio and the\n    *screen* aspect ratio vary independently. ``True`` indicates that the plot\n    aspect ratio of the axes will match the aspect ratio of the pixel extent\n    the axes. The end result is that a 1x1 area in data space is a square in\n    pixels, and conversely that a 1x1 pixel is a square in data units.\n\n    .. note::\n        This setting only takes effect when there are two dataranges. This\n        setting only sets the initial plot draw and subsequent resets. It is\n        possible for tools (single axis zoom, unconstrained box zoom) to\n        change the aspect ratio.\n\n    .. warning::\n        This setting is incompatible with linking dataranges across multiple\n        plots. Doing so may result in undefined behaviour.",
        "default": false
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "outline_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join for the plot border outline.",
        "default": "bevel"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "min_border",
        "type": "Int",
        "desc": "A convenience property to set all all the ``min_border_X`` properties\n    to the same value. If an individual border property is explicitly set,\n    it will override ``min_border``.",
        "default": 5
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "lod_factor",
        "type": "Int",
        "desc": "Decimation factor to use when applying level-of-detail decimation.",
        "default": 10
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "plot_width",
        "type": "Int",
        "desc": "The outer width of a plot, including any axes, titles, border padding, etc.\n\n    .. note::\n        This corresponds directly to the width of the HTML canvas.",
        "default": 600
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "outline_line_alpha",
        "type": "Percent",
        "desc": "The line alpha for the plot border outline.",
        "default": 1.0
      },
      {
        "name": "background_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha for the plot background style.",
        "default": 1.0
      },
      {
        "name": "title_location",
        "type": "Enum('above', 'below', 'left', 'right')",
        "desc": "Where the title will be located. Titles on the left or right side\n    will be rotated.",
        "default": "above"
      },
      {
        "name": "x_range",
        "type": "Instance(Range)",
        "desc": "The (default) data range of the horizontal dimension of the plot.",
        "default": "{\"id\": \"4959\"}"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "extra_y_ranges",
        "type": "Dict(String, Instance(Range))",
        "desc": "Additional named ranges to make available for mapping y-coordinates.\n\n    This is useful for adding additional axes.",
        "default": {}
      },
      {
        "name": "outline_line_width",
        "type": "Float",
        "desc": "The line width for the plot border outline.",
        "default": 1
      },
      {
        "name": "min_border_top",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region above the top of the\n    central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "outline_line_color",
        "type": "Color",
        "desc": "The line color for the plot border outline.",
        "default": "#e5e5e5"
      },
      {
        "name": "toolbar_location",
        "type": "Enum('above', 'below', 'left', 'right')",
        "desc": "Where the toolbar will be located. If set to None, no toolbar\n    will be attached to the plot.",
        "default": "right"
      },
      {
        "name": "above",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area above of the plot.",
        "default": []
      },
      {
        "name": "plot_height",
        "type": "Int",
        "desc": "The outer height of a plot, including any axes, titles, border padding, etc.\n\n    .. note::\n        This corresponds directly to the height of the HTML canvas.",
        "default": 600
      },
      {
        "name": "aspect_scale",
        "type": "Float",
        "desc": "A value to be given for increased aspect ratio control. This value is added\n    multiplicatively to the calculated value required for ``match_aspect``.\n    ``aspect_scale`` is defined as the ratio of width over height of the figure.\n\n    For example, a plot with ``aspect_scale`` value of 2 will result in a\n    square in *data units* to be drawn on the screen as a rectangle with a\n    pixel width twice as long as its pixel height.\n\n    .. note::\n        This setting only takes effect if ``match_aspect`` is set to ``True``.",
        "default": 1
      },
      {
        "name": "output_backend",
        "type": "Enum('canvas', 'svg', 'webgl')",
        "desc": "Specify the output backend for the plot area. Default is HTML5 Canvas.\n\n    .. note::\n        When set to ``webgl``, glyphs without a WebGL rendering implementation\n        will fall back to rendering onto 2D canvas.",
        "default": "canvas"
      },
      {
        "name": "frame_width",
        "type": "Int",
        "desc": "The width of a plot frame or the inner width of a plot, excluding any\n    axes, titles, border padding, etc.",
        "default": null
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "border_fill_color",
        "type": "Color",
        "desc": "The fill color for the plot border style.",
        "default": "#ffffff"
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "x_scale",
        "type": "Instance(Scale)",
        "desc": "What kind of scale to use to convert x-coordinates in data space\n    into x-coordinates in screen space.",
        "default": "{\"id\": \"4978\"}"
      },
      {
        "name": "outline_line_dash",
        "type": "DashPattern",
        "desc": "The line dash for the plot border outline.",
        "default": []
      },
      {
        "name": "reset_policy",
        "type": "Enum('standard', 'event_only')",
        "desc": "How a plot should respond to being reset. By deafult, the standard actions\n    are to clear any tool state history, return plot ranges to their original\n    values, undo all selections, and emit a ``Reset`` event. If customization\n    is desired, this property may be set to ``\"event_only\"``, which will\n    suppress all of the actions except the Reset event.",
        "default": "standard"
      },
      {
        "name": "outer_height",
        "type": "Int",
        "desc": "This is the exact height of the layout, i.e. the height of\n    the actual plot, with toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "border_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha for the plot border style.",
        "default": 1.0
      },
      {
        "name": "outer_width",
        "type": "Int",
        "desc": "This is the exact width of the layout, i.e. the height of\n    the actual plot, with toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "toolbar",
        "type": "Instance(Toolbar)",
        "desc": "The toolbar associated with this plot which holds all the tools. It is\n    automatically created with the plot if necessary.",
        "default": "{\"id\": \"4985\"}"
      },
      {
        "name": "toolbar_sticky",
        "type": "Bool",
        "desc": "Stick the toolbar to the edge of the plot. Default: True. If False,\n    the toolbar will be outside of the axes, titles etc.",
        "default": true
      },
      {
        "name": "min_border_bottom",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region below the bottom of\n    the central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "title",
        "type": "Instance(Title)",
        "desc": "A title for the plot. Can be a text string or a Title annotation.",
        "default": "{\"id\": \"4989\", \"text\": \"\"}"
      },
      {
        "name": "frame_height",
        "type": "Int",
        "desc": "The height of a plot frame or the inner height of a plot, excluding any\n    axes, titles, border padding, etc.",
        "default": null
      },
      {
        "name": "center",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the center area (frame) of the plot.",
        "default": []
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "lod_threshold",
        "type": "Int",
        "desc": "A number of data points, above which level-of-detail downsampling may\n    be performed by glyph renderers. Set to ``None`` to disable any\n    level-of-detail downsampling.",
        "default": 2000
      },
      {
        "name": "below",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area below of the plot.",
        "default": []
      },
      {
        "name": "lod_interval",
        "type": "Int",
        "desc": "Interval (in ms) during which an interactive tool event will enable\n    level-of-detail downsampling.",
        "default": 300
      },
      {
        "name": "lod_timeout",
        "type": "Int",
        "desc": "Timeout (in ms) for checking whether interactive tool events are still\n    occurring. Once level-of-detail mode is enabled, a check is made every\n    ``lod_timeout`` ms. If no interactive tool events have happened,\n    level-of-detail mode is disabled.",
        "default": 500
      },
      {
        "name": "left",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area to the left of the plot.",
        "default": []
      },
      {
        "name": "right",
        "type": "List(Instance(Renderer))",
        "desc": "A list of renderers to occupy the area to the right of the plot.",
        "default": []
      },
      {
        "name": "min_border_left",
        "type": "Int",
        "desc": "Minimum size in pixels of the padding region to the left of\n    the central plot region.\n\n    .. note::\n        This is a *minimum*. The padding region may expand as needed to\n        accommodate titles or axes, etc.",
        "default": null
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "y_range",
        "type": "Instance(Range)",
        "desc": "The (default) data range of the vertical dimension of the plot.",
        "default": "{\"id\": \"5003\"}"
      },
      {
        "name": "inner_width",
        "type": "Int",
        "desc": "This is the exact width of the plotting canvas, i.e. the width of\n    the actual plot, without toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "inner_height",
        "type": "Int",
        "desc": "This is the exact height of the plotting canvas, i.e. the height of\n    the actual plot, without toolbars etc. Note this is computed in a\n    web browser, so this property will work only in backends capable of\n    bidirectional communication (server, notebook).\n\n    .. note::\n        This is an experimental feature and the API may change in near future.",
        "default": null
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "extra_x_ranges",
        "type": "Dict(String, Instance(Range))",
        "desc": "Additional named ranges to make available for mapping x-coordinates.\n\n    This is useful for adding additional axes.",
        "default": {}
      },
      {
        "name": "background_fill_color",
        "type": "Color",
        "desc": "The fill color for the plot background style.",
        "default": "#ffffff"
      },
      {
        "name": "hidpi",
        "type": "Bool",
        "desc": "Whether to use HiDPI mode when available.",
        "default": true
      },
      {
        "name": "y_scale",
        "type": "Instance(Scale)",
        "desc": "What kind of scale to use to convert y-coordinates in data space\n    into y-coordinates in screen space.",
        "default": "{\"id\": \"5013\"}"
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "A list of all renderers for this plot, including guides and annotations\n    in addition to glyphs and markers.\n\n    This property can be manipulated by hand, but the ``add_glyph`` and\n    ``add_layout`` methods are recommended to help make sure all necessary\n    setup is performed.",
        "default": []
      }
    ]
  },
  "Plus": {
    "name": "Plus",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render filled plus markers \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Plus.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"5015\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "PointDrawTool": {
    "name": "PointDrawTool",
    "bases": [
      "bokeh.models.tools.EditTool",
      "bokeh.models.tools.Drag",
      "bokeh.models.tools.Tap"
    ],
    "desc": "*toolbar icon*: |point_draw_icon|\n\n    The PointDrawTool allows adding, dragging and deleting point-like glyphs\n    (i.e subclasses of``XYGlyph``) on one or more renderers by editing the\n    underlying ``ColumnDataSource`` data. Like other drawing tools, the\n    renderers that are to be edited must be supplied explicitly as a list. Any\n    newly added points will be inserted on the ``ColumnDataSource`` of the\n    first supplied renderer.\n\n    The tool will modify the columns on the data source corresponding to the\n    ``x`` and ``y`` values of the glyph. Any additional columns in the data\n    source will be padded with the given ``empty_value`` when adding a new\n    point.\n\n    .. note::\n        The data source updates will trigger data change events continuously\n        throughout the edit operations on the BokehJS side. In Bokeh server\n        apps, the data source will only be synced once, when the edit operation\n        finishes.\n\n    The supported actions include:\n\n    * Add point: Tap anywhere on the plot\n\n    * Move point: Tap and drag an existing point, the point will be\n      dropped once you let go of the mouse button.\n\n    * Delete point: Tap a point to select it then press <<backspace>>\n      key while the mouse is within the plot area.\n\n    .. |point_draw_icon| image:: /_images/icons/PointDraw.png\n        :height: 24px",
    "proto": "{\"add\": true, \"custom_icon\": null, \"custom_tooltip\": null, \"drag\": true, \"empty_value\": null, \"id\": \"5035\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_objects\": 0, \"renderers\": [], \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "custom_icon",
        "type": "Image",
        "desc": "An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.",
        "default": null
      },
      {
        "name": "empty_value",
        "type": "Either(Bool, Int, Float, Date, Datetime, Color, String)",
        "desc": "Defines the value to insert on non-coordinate columns when a new\n    glyph is inserted into the ``ColumnDataSource`` columns, e.g. when a\n    circle glyph defines 'x', 'y' and 'color' columns, adding a new\n    point will add the x and y-coordinates to 'x' and 'y' columns and\n    the color column will be filled with the defined empty value.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "add",
        "type": "Bool",
        "desc": "Enables adding of new points on tap events.",
        "default": true
      },
      {
        "name": "custom_tooltip",
        "type": "String",
        "desc": "A custom tooltip label to override the default name.",
        "default": null
      },
      {
        "name": "num_objects",
        "type": "Int",
        "desc": "Defines a limit on the number of points that can be drawn. By default there\n    is no limit on the number of objects, but if enabled the oldest drawn point\n    will be dropped to make space for the new point.",
        "default": 0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "drag",
        "type": "Bool",
        "desc": "Enables dragging of existing points on pan events.",
        "default": true
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "An explicit list of renderers corresponding to scatter glyphs that may\n    be edited.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "PolyAnnotation": {
    "name": "PolyAnnotation",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render a shaded polygonal region as an annotation.",
    "proto": "{\"fill_alpha\": 0.4, \"fill_color\": \"#fff9ba\", \"id\": \"5048\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"line_alpha\": 0.3, \"line_cap\": \"butt\", \"line_color\": \"#cccccc\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"x_range_name\": \"default\", \"xs\": [], \"xs_units\": \"data\", \"y_range_name\": \"default\", \"ys\": [], \"ys_units\": \"data\"}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the polygon.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the polygon.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the polygon.",
        "default": "#cccccc"
      },
      {
        "name": "fill_color",
        "type": "Color",
        "desc": "The fill color values for the polygon.",
        "default": "#fff9ba"
      },
      {
        "name": "xs_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the ``xs`` attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the polygon.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering box annotations on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the polygon.",
        "default": 0.3
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering box annotations on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the polygon.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the polygon.",
        "default": 0.4
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "ys",
        "type": "Seq(Float)",
        "desc": "The y-coordinates of the region to draw.",
        "default": []
      },
      {
        "name": "xs",
        "type": "Seq(Float)",
        "desc": "The x-coordinates of the region to draw.",
        "default": []
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "ys_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the ``ys`` attribute. Interpreted as \"data space\" units\n    by default.",
        "default": "data"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the polygon.",
        "default": "bevel"
      }
    ]
  },
  "PolyDrawTool": {
    "name": "PolyDrawTool",
    "bases": [
      "bokeh.models.tools.EditTool",
      "bokeh.models.tools.Drag",
      "bokeh.models.tools.Tap"
    ],
    "desc": "*toolbar icon*: |poly_draw_icon|\n\n    The PolyDrawTool allows drawing, selecting and deleting ``Patches`` and\n    ``MultiLine`` glyphs on one or more renderers by editing the underlying\n    ``ColumnDataSource`` data. Like other drawing tools, the renderers that\n    are to be edited must be supplied explicitly.\n\n    The tool will modify the columns on the data source corresponding to the\n    ``xs`` and ``ys`` values of the glyph. Any additional columns in the data\n    source will be padded with the declared ``empty_value``, when adding a new\n    point.\n\n    If a ``vertex_renderer`` with an point-like glyph is supplied then the\n    ``PolyDrawTool`` will use it to display the vertices of the multi-lines or\n    patches on all supplied renderers. This also enables the ability to snap\n    to existing vertices while drawing.\n\n    The supported actions include:\n\n    * Add patch or multi-line: Double tap to add the first vertex, then use tap\n      to add each subsequent vertex, to finalize the draw action double tap to\n      insert the final vertex or press the <<esc> key.\n\n    * Move patch or ulti-line: Tap and drag an existing patch/multi-line, the\n      point will be dropped once you let go of the mouse button.\n\n    * Delete patch or multi-line: Tap a patch/multi-line to select it then\n      press <<backspace>> key while the mouse is within the plot area.\n\n    .. |poly_draw_icon| image:: /_images/icons/PolyDraw.png\n        :height: 24px",
    "proto": "{\"custom_icon\": null, \"custom_tooltip\": null, \"drag\": true, \"empty_value\": null, \"id\": \"5071\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_objects\": 0, \"renderers\": [], \"subscribed_events\": [], \"tags\": [], \"vertex_renderer\": null}",
    "props": [
      {
        "name": "custom_icon",
        "type": "Image",
        "desc": "An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.",
        "default": null
      },
      {
        "name": "empty_value",
        "type": "Either(Bool, Int, Float, Date, Datetime, Color, String)",
        "desc": "Defines the value to insert on non-coordinate columns when a new\n    glyph is inserted into the ``ColumnDataSource`` columns, e.g. when a\n    circle glyph defines 'x', 'y' and 'color' columns, adding a new\n    point will add the x and y-coordinates to 'x' and 'y' columns and\n    the color column will be filled with the defined empty value.",
        "default": null
      },
      {
        "name": "vertex_renderer",
        "type": "Instance(GlyphRenderer)",
        "desc": "The renderer used to render the vertices of a selected line or polygon.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "custom_tooltip",
        "type": "String",
        "desc": "A custom tooltip label to override the default name.",
        "default": null
      },
      {
        "name": "num_objects",
        "type": "Int",
        "desc": "Defines a limit on the number of patches or multi-lines that can be drawn.\n    By default there is no limit on the number of objects, but if enabled the\n    oldest drawn patch or multi-line will be dropped to make space for the new\n    patch or multi-line.",
        "default": 0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "drag",
        "type": "Bool",
        "desc": "Enables dragging of existing patches and multi-lines on pan events.",
        "default": true
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "An explicit list of renderers corresponding to scatter glyphs that may\n    be edited.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "PolyEditTool": {
    "name": "PolyEditTool",
    "bases": [
      "bokeh.models.tools.EditTool",
      "bokeh.models.tools.Drag",
      "bokeh.models.tools.Tap"
    ],
    "desc": "*toolbar icon*: |poly_edit_icon|\n\n    The PolyEditTool allows editing the vertices of one or more ``Patches`` or\n    ``MultiLine`` glyphs. Glyphs to be edited are defined via the ``renderers``\n    property and a renderer for the vertices is set via the ``vertex_renderer``\n    property (must render a point-like Glyph (a subclass of ``XYGlyph``).\n\n    The tool will modify the columns on the data source corresponding to the\n    ``xs`` and ``ys`` values of the glyph. Any additional columns in the data\n    source will be padded with the declared``empty_value``, when adding a new\n    point.\n\n    The supported actions include:\n\n    * Show vertices: Double tap an existing patch or multi-line\n\n    * Add vertex: Double tap an existing vertex to select it, the tool will\n      draw the next point, to add it tap in a new location. To finish editing\n      and add a point double tap otherwise press the <<esc> key to cancel.\n\n    * Move vertex: Drag an existing vertex and let go of the mouse button to\n      release it.\n\n    * Delete vertex: After selecting one or more vertices press <<backspace>>\n      while the mouse cursor is within the plot area.\n\n    .. |poly_edit_icon| image:: /_images/icons/PolyEdit.png\n        :height: 24px",
    "proto": "{\"custom_icon\": null, \"custom_tooltip\": null, \"empty_value\": null, \"id\": \"5084\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"renderers\": [], \"subscribed_events\": [], \"tags\": [], \"vertex_renderer\": null}",
    "props": [
      {
        "name": "custom_icon",
        "type": "Image",
        "desc": "An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.",
        "default": null
      },
      {
        "name": "empty_value",
        "type": "Either(Bool, Int, Float, Date, Datetime, Color, String)",
        "desc": "Defines the value to insert on non-coordinate columns when a new\n    glyph is inserted into the ``ColumnDataSource`` columns, e.g. when a\n    circle glyph defines 'x', 'y' and 'color' columns, adding a new\n    point will add the x and y-coordinates to 'x' and 'y' columns and\n    the color column will be filled with the defined empty value.",
        "default": null
      },
      {
        "name": "vertex_renderer",
        "type": "Instance(GlyphRenderer)",
        "desc": "The renderer used to render the vertices of a selected line or\n    polygon.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "custom_tooltip",
        "type": "String",
        "desc": "A custom tooltip label to override the default name.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "renderers",
        "type": "List(Instance(Renderer))",
        "desc": "An explicit list of renderers corresponding to scatter glyphs that may\n    be edited.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "PolySelectTool": {
    "name": "PolySelectTool",
    "bases": [
      "bokeh.models.tools.Tap",
      "bokeh.models.tools.SelectTool"
    ],
    "desc": "*toolbar icon*: |poly_select_icon|\n\n    The polygon selection tool allows users to make selections on a\n    Plot by indicating a polygonal region with mouse clicks. single\n    clicks (or taps) add successive points to the definition of the\n    polygon, and a double click (or tap) indicates the selection\n    region is ready.\n\n    See :ref:`userguide_styling_selected_unselected_glyphs` for information\n    on styling selected and unselected glyphs.\n\n    .. note::\n        Selections can be comprised of multiple regions, even those\n        made by different selection tools. Hold down the <<shift>> key\n        while making a selection to append the new selection to any\n        previous selection that might exist.\n\n    .. |poly_select_icon| image:: /_images/icons/PolygonSelect.png\n        :height: 24px",
    "proto": "{\"id\": \"5095\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mode\": \"replace\", \"name\": null, \"names\": [], \"overlay\": {\"id\": \"5096\"}, \"renderers\": \"auto\", \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('replace', 'append', 'intersect', 'subtract')",
        "desc": "Defines what should happen when a new selection is made. The default\n    is to replace the existing selection. Other options are to append to\n    the selection, intersect with it or subtract from it.",
        "default": "replace"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "names",
        "type": "List(String)",
        "desc": "A list of names to query for. If set, only renderers that  have a matching\n    value for their ``name`` attribute will be used.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "overlay",
        "type": "Instance(PolyAnnotation)",
        "desc": "A shaded annotation drawn to indicate the selection region.",
        "default": "{\"fill_alpha\": 0.5, \"fill_color\": \"lightgrey\", \"id\": \"5103\", \"level\": \"overlay\", \"line_alpha\": 1.0, \"line_color\": \"black\", \"line_dash\": [4, 4], \"line_width\": 2, \"xs_units\": \"screen\", \"ys_units\": \"screen\"}"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "renderers",
        "type": "Either(Auto, List(Instance(Renderer)))",
        "desc": "An explicit list of renderers to hit test against. If unset, defaults to\n    all renderers on a plot.",
        "default": "auto"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "PreText": {
    "name": "PreText",
    "bases": [
      "bokeh.models.widgets.markups.Paragraph"
    ],
    "desc": "A block (paragraph) of pre-formatted text.\n\n    This Bokeh model corresponds to an HTML ``<pre>`` element.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../sphinx/source/docs/user_guide/examples/interaction_pretext.py\n        :source-position: below",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"5107\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"style\": {}, \"subscribed_events\": [], \"tags\": [], \"text\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "style",
        "type": "Dict(String, Any)",
        "desc": "Raw CSS style declaration. Note this may be web browser dependent.",
        "default": {}
      },
      {
        "name": "text",
        "type": "String",
        "desc": "The text or HTML contents of the widget.\n\n    .. note::\n        If the HTML content contains elements which size depends on\n        on external, asynchronously loaded resources, the size of\n        the widget may be computed incorrectly. This is in particular\n        an issue with images (``<img>``). To remedy this problem, one\n        either has to set explicit dimensions using CSS properties,\n        HTML attributes or model's ``width`` and ``height`` properties,\n        or inline images' contents using data URIs.",
        "default": ""
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "PrintfTickFormatter": {
    "name": "PrintfTickFormatter",
    "bases": [
      "bokeh.models.formatters.TickFormatter"
    ],
    "desc": "Tick formatter based on a printf-style format string.",
    "proto": "{\"format\": \"%s\", \"id\": \"5133\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "format",
        "type": "String",
        "desc": "The number format, as defined as follows: the placeholder in the format\n    string is marked by % and is followed by one or more of these elements,\n    in this order:\n\n    * An optional ``+`` sign\n        Causes the result to be preceded with a plus or minus sign on numeric\n        values. By default, only the ``-`` sign is used on negative numbers.\n\n    * An optional padding specifier\n        Specifies what (if any) character to use for padding. Possible values\n        are 0 or any other character preceded by a ``'`` (single quote). The\n        default is to pad with spaces.\n\n    * An optional ``-`` sign\n        Causes sprintf to left-align the result of this placeholder. The default\n        is to right-align the result.\n\n    * An optional number\n        Specifies how many characters the result should have. If the value to be\n        returned is shorter than this number, the result will be padded.\n\n    * An optional precision modifier\n        Consists of a ``.`` (dot) followed by a number, specifies how many digits\n        should be displayed for floating point numbers. When used on a string, it\n        causes the result to be truncated.\n\n    * A type specifier\n        Can be any of:\n\n        - ``%`` --- yields a literal ``%`` character\n        - ``b`` --- yields an integer as a binary number\n        - ``c`` --- yields an integer as the character with that ASCII value\n        - ``d`` or ``i`` --- yields an integer as a signed decimal number\n        - ``e`` --- yields a float using scientific notation\n        - ``u`` --- yields an integer as an unsigned decimal number\n        - ``f`` --- yields a float as is\n        - ``o`` --- yields an integer as an octal number\n        - ``s`` --- yields a string as is\n        - ``x`` --- yields an integer as a hexadecimal number (lower-case)\n        - ``X`` --- yields an integer as a hexadecimal number (upper-case)",
        "default": "%s"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ProxyToolbar": {
    "name": "ProxyToolbar",
    "bases": [
      "bokeh.models.tools.ToolbarBase"
    ],
    "desc": "A toolbar that allow to merge and proxy tools of toolbars in multiple\n    plots.",
    "proto": "{\"autohide\": false, \"id\": \"5140\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"logo\": \"normal\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"toolbars\": [], \"tools\": []}",
    "props": [
      {
        "name": "logo",
        "type": "Enum('normal', 'grey')",
        "desc": "What version of the Bokeh logo to display on the toolbar. If\n    set to None, no logo will be displayed.",
        "default": "normal"
      },
      {
        "name": "autohide",
        "type": "Bool",
        "desc": "Whether the toolbar will be hidden by default. Default: False.\n    If True, hides toolbar when cursor is not in canvas.",
        "default": false
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "toolbars",
        "type": "List(Instance(Toolbar))",
        "desc": "",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tools",
        "type": "List(Instance(Tool))",
        "desc": "A list of tools to add to the plot.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "QUADKEYTileSource": {
    "name": "QUADKEYTileSource",
    "bases": [
      "bokeh.models.tiles.MercatorTileSource"
    ],
    "desc": "Has the same tile origin as the ``WMTSTileSource`` but requests tiles using\n    a `quadkey` argument instead of X, Y, Z e.g.\n    ``http://your.quadkey.tile.host/{Q}.png``",
    "proto": "{\"attribution\": \"\", \"extra_url_vars\": {}, \"id\": \"5150\", \"initial_resolution\": 156543.03392804097, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_zoom\": 30, \"min_zoom\": 0, \"name\": null, \"snap_to_zoom\": false, \"subscribed_events\": [], \"tags\": [], \"tile_size\": 256, \"url\": \"\", \"wrap_around\": true, \"x_origin_offset\": 20037508.34, \"y_origin_offset\": 20037508.34}",
    "props": [
      {
        "name": "url",
        "type": "String",
        "desc": "Tile service url e.g., http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png",
        "default": ""
      },
      {
        "name": "wrap_around",
        "type": "Bool",
        "desc": "Enables continuous horizontal panning by wrapping the x-axis based on\n    bounds of map.\n\n    ..note::\n        Axis coordinates are not wrapped. To toggle axis label visibility,\n        use ``plot.axis.visible = False``.",
        "default": true
      },
      {
        "name": "tile_size",
        "type": "Int",
        "desc": "Tile size in pixels (e.g. 256)",
        "default": 256
      },
      {
        "name": "extra_url_vars",
        "type": "Dict(String, Any)",
        "desc": "A dictionary that maps url variable template keys to values.\n\n    These variables are useful for parts of tile urls which do not change from\n    tile to tile (e.g. server host name, or layer name).",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "initial_resolution",
        "type": "Float",
        "desc": "Resolution (plot_units / pixels) of minimum zoom level of tileset\n    projection. None to auto-compute.",
        "default": 156543.03392804097
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "y_origin_offset",
        "type": "Float",
        "desc": "A y-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "x_origin_offset",
        "type": "Float",
        "desc": "An x-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "max_zoom",
        "type": "Int",
        "desc": "A maximum zoom level for the tile layer. This is the most zoomed-in level.",
        "default": 30
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "min_zoom",
        "type": "Int",
        "desc": "A minimum zoom level for the tile layer. This is the most zoomed-out level.",
        "default": 0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "snap_to_zoom",
        "type": "Bool",
        "desc": "Forces initial extents to snap to the closest larger zoom level.",
        "default": false
      },
      {
        "name": "attribution",
        "type": "String",
        "desc": "Data provider attribution content. This can include HTML content.",
        "default": ""
      }
    ]
  },
  "Quad": {
    "name": "Quad",
    "bases": [
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph",
      "bokeh.models.glyph.HatchGlyph"
    ],
    "desc": "Render axis-aligned quads.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Quad.py\n        :source-position: below",
    "proto": "{\"bottom\": null, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"hatch_alpha\": {\"value\": 1.0}, \"hatch_color\": {\"value\": \"black\"}, \"hatch_extra\": {}, \"hatch_pattern\": null, \"hatch_scale\": {\"value\": 12.0}, \"hatch_weight\": {\"value\": 1.0}, \"id\": \"5167\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"left\": null, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"right\": null, \"subscribed_events\": [], \"tags\": [], \"top\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the quads.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the quads.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the quads.",
        "default": "black"
      },
      {
        "name": "bottom",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the bottom edges.",
        "default": null
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the quads.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the quads.",
        "default": 1
      },
      {
        "name": "hatch_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch alpha values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "hatch_weight",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch weight values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "hatch_scale",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch scale values for the horizontal bars.",
        "default": 12.0
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the quads.",
        "default": 1.0
      },
      {
        "name": "hatch_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The hatch color values for the horizontal bars.",
        "default": "black"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the quads.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the quads.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "left",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the left edges.",
        "default": null
      },
      {
        "name": "right",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the right edges.",
        "default": null
      },
      {
        "name": "hatch_pattern",
        "type": "HatchPatternSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), HatchPatternType)), HatchPatternType)",
        "desc": "The hatch pattern values for the horizontal bars.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "hatch_extra",
        "type": "Dict(String, Instance(Texture))",
        "desc": "The hatch extra values for the horizontal bars.",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the quads.",
        "default": "bevel"
      },
      {
        "name": "top",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the top edges.",
        "default": null
      }
    ]
  },
  "Quadratic": {
    "name": "Quadratic",
    "bases": [
      "bokeh.models.glyph.LineGlyph"
    ],
    "desc": "Render parabolas.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Quadratic.py\n        :source-position: below",
    "proto": "{\"cx\": null, \"cy\": null, \"id\": \"5192\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x0\": null, \"x1\": null, \"y0\": null, \"y1\": null}",
    "props": [
      {
        "name": "cx",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the control points.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the parabolas.",
        "default": "butt"
      },
      {
        "name": "x1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the ending points.",
        "default": null
      },
      {
        "name": "y0",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the starting points.",
        "default": null
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the parabolas.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the parabolas.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the parabolas.",
        "default": "black"
      },
      {
        "name": "x0",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the starting points.",
        "default": null
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the parabolas.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "y1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the ending points.",
        "default": null
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the parabolas.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the parabolas.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "cy",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the control points.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "RadioButtonGroup": {
    "name": "RadioButtonGroup",
    "bases": [
      "bokeh.models.widgets.groups.ButtonGroup"
    ],
    "desc": "A group of radio boxes rendered as toggle buttons.",
    "proto": "{\"active\": null, \"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"button_type\": \"default\", \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"5211\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"labels\": [], \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "button_type",
        "type": "Enum('default', 'primary', 'success', 'warning', 'danger')",
        "desc": "A style for the button, signifying it's role.",
        "default": "default"
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "active",
        "type": "Int",
        "desc": "The index of the selected radio box, or ``None`` if nothing is\n    selected.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "labels",
        "type": "List(String)",
        "desc": "List of text labels contained in this group.",
        "default": []
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "RadioGroup": {
    "name": "RadioGroup",
    "bases": [
      "bokeh.models.widgets.groups.Group"
    ],
    "desc": "A group of radio boxes.",
    "proto": "{\"active\": null, \"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"5238\", \"inline\": false, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"labels\": [], \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "active",
        "type": "Int",
        "desc": "The index of the selected radio box, or ``None`` if nothing is\n    selected.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "labels",
        "type": "List(String)",
        "desc": "List of text labels contained in this group.",
        "default": []
      },
      {
        "name": "inline",
        "type": "Bool",
        "desc": "Should items be arrange vertically (``False``) or horizontally\n    in-line (``True``).",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Range": {
    "name": "Range",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A base class for all range types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"5265\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Range1d": {
    "name": "Range1d",
    "bases": [
      "bokeh.models.ranges.Range"
    ],
    "desc": "A fixed, closed range [start, end] in a continuous scalar\n    dimension.\n\n    In addition to supplying ``start`` and ``end`` keyword arguments\n    to the ``Range1d`` initializer, you can also instantiate with\n    the convenience syntax::\n\n        Range(0, 10) # equivalent to Range(start=0, end=10)",
    "proto": "{\"bounds\": null, \"end\": 1, \"id\": \"5271\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_interval\": null, \"min_interval\": null, \"name\": null, \"reset_end\": null, \"reset_start\": null, \"start\": 0, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "end",
        "type": "Either(Float, Datetime, TimeDelta)",
        "desc": "The end of the range.",
        "default": 1
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "start",
        "type": "Either(Float, Datetime, TimeDelta)",
        "desc": "The start of the range.",
        "default": 0
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "reset_end",
        "type": "Either(Float, Datetime, TimeDelta)",
        "desc": "The end of the range to apply when resetting. If set to ``None`` defaults\n    to the ``end`` value during initialization.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "min_interval",
        "type": "Either(Float, TimeDelta)",
        "desc": "The level that the range is allowed to zoom in, expressed as the\n    minimum visible interval. If set to ``None`` (default), the minimum\n    interval is not bound. Can be a ``TimeDelta``.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "reset_start",
        "type": "Either(Float, Datetime, TimeDelta)",
        "desc": "The start of the range to apply after reset. If set to ``None`` defaults\n    to the ``start`` value during initialization.",
        "default": null
      },
      {
        "name": "bounds",
        "type": "MinMaxBounds(Auto, Tuple(Float, Float), Tuple(TimeDelta, TimeDelta), Tuple(Datetime, Datetime))",
        "desc": "The bounds that the range is allowed to go to. Typically used to prevent\n    the user from panning/zooming/etc away from the data.\n\n    If set to ``'auto'``, the bounds will be computed to the start and end of the Range.\n\n    Bounds are provided as a tuple of ``(min, max)`` so regardless of whether your range is\n    increasing or decreasing, the first item should be the minimum value of the range and the\n    second item should be the maximum. Setting min > max will result in a ``ValueError``.\n\n    By default, bounds are ``None`` and your plot to pan/zoom as far as you want. If you only\n    want to constrain one end of the plot, you can set min or max to None.\n\n    Examples:\n\n    .. code-block:: python\n\n        Range1d(0, 1, bounds='auto')  # Auto-bounded to 0 and 1 (Default behavior)\n        Range1d(start=0, end=1, bounds=(0, None))  # Maximum is unbounded, minimum bounded to 0",
        "default": null
      },
      {
        "name": "max_interval",
        "type": "Either(Float, TimeDelta)",
        "desc": "The level that the range is allowed to zoom out, expressed as the\n    maximum visible interval. Can be a ``TimeDelta``. Note that ``bounds`` can\n    impose an implicit constraint on the maximum interval as well.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "RangeSlider": {
    "name": "RangeSlider",
    "bases": [
      "bokeh.models.widgets.sliders.AbstractSlider"
    ],
    "desc": "Range-slider based number range selection widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"bar_color\": \"#e6e6e6\", \"css_classes\": [], \"default_size\": 300, \"direction\": \"ltr\", \"disabled\": false, \"end\": null, \"format\": \"0[.]00\", \"height\": null, \"height_policy\": \"auto\", \"id\": \"5284\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"show_value\": true, \"sizing_mode\": null, \"start\": null, \"step\": 1, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"tooltips\": true, \"value\": null, \"value_throttled\": null, \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "end",
        "type": "Float",
        "desc": "The maximum allowable value.",
        "default": null
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "tooltips",
        "type": "Bool",
        "desc": "",
        "default": true
      },
      {
        "name": "start",
        "type": "Float",
        "desc": "The minimum allowable value.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Slider's label.",
        "default": ""
      },
      {
        "name": "step",
        "type": "Float",
        "desc": "The step between consecutive values.",
        "default": 1
      },
      {
        "name": "format",
        "type": "Either(String, Instance(TickFormatter))",
        "desc": "",
        "default": "0[.]00"
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "direction",
        "type": "Enum('ltr', 'rtl')",
        "desc": "",
        "default": "ltr"
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "bar_color",
        "type": "Color",
        "desc": "",
        "default": "#e6e6e6"
      },
      {
        "name": "value",
        "type": "Tuple(Float, Float)",
        "desc": "Initial or selected range.",
        "default": null
      },
      {
        "name": "show_value",
        "type": "Bool",
        "desc": "Whether or not show slider's value.",
        "default": true
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "value_throttled",
        "type": "Tuple(Float, Float)",
        "desc": "Initial or selected value, throttled according to report only on mouseup.",
        "default": null
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "RangeTool": {
    "name": "RangeTool",
    "bases": [
      "bokeh.models.tools.Drag"
    ],
    "desc": "*toolbar icon*: |range_icon|\n\n    The range tool allows the user to update range objects for either or both\n    of the x- or y-dimensions by dragging a corresponding shaded annotation to\n    move it or change its boundaries.\n\n    A common use case is to add this tool to a plot with a large fixed range,\n    but to configure the tool range from a different plot. When the user\n    manipulates the overlay, the range of the second plot will be updated\n    automatically.\n\n    .. |range_icon| image:: /_images/icons/Range.png\n        :height: 24px",
    "proto": "{\"id\": \"5319\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"overlay\": {\"id\": \"5320\"}, \"subscribed_events\": [], \"tags\": [], \"x_interaction\": true, \"x_range\": null, \"y_interaction\": true, \"y_range\": null}",
    "props": [
      {
        "name": "x_interaction",
        "type": "Bool",
        "desc": "Whether to respond to horizontal pan motions when an ``x_range`` is present.\n\n    By default, when an ``x_range`` is specified, it is possible to adjust the\n    horizontal position of the range box by panning horizontally inside the\n    box, or along the top or bottom edge of the box. To disable this, and fix\n    the  range box in place horizontally, set to False. (The box will still\n    update if the ``x_range`` is updated programmatically.)",
        "default": true
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "x_range",
        "type": "Instance(Range1d)",
        "desc": "A range synchronized to the x-dimension of the overlay. If None, the overlay\n    will span the entire x-dimension.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "y_range",
        "type": "Instance(Range1d)",
        "desc": "A range synchronized to the y-dimension of the overlay. If None, the overlay\n    will span the entire y-dimension.",
        "default": null
      },
      {
        "name": "y_interaction",
        "type": "Bool",
        "desc": "Whether to respond to vertical pan motions when a ``y_range`` is present.\n\n    By default, when a ``y_range`` is specified, it is possible to adjust the\n    vertical position of the range box by panning vertically inside the box, or\n    along the top or bottom edge of the box. To disable this, and fix the range\n    box in place vertically, set to False. (The box will still update if the\n    ``y_range`` is updated programmatically.)",
        "default": true
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "overlay",
        "type": "Instance(BoxAnnotation)",
        "desc": "A shaded annotation drawn to indicate the configured ranges.",
        "default": "{\"fill_alpha\": 0.5, \"fill_color\": \"lightgrey\", \"id\": \"5329\", \"level\": \"overlay\", \"line_alpha\": 1.0, \"line_color\": \"black\", \"line_dash\": [2, 2], \"line_width\": 0.5}"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Ray": {
    "name": "Ray",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph"
    ],
    "desc": "Render rays.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Ray.py\n        :source-position: below",
    "proto": "{\"angle\": null, \"id\": \"5332\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"length\": null, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the rays.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles in radians to extend the rays, as measured from the horizontal.",
        "default": null
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the rays.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the rays.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the rays.",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the rays.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "length_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the rays.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the rays.",
        "default": "bevel"
      },
      {
        "name": "length",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The length to extend the ray. Note that this ``length`` defaults\n    to data units (measured in the x-direction).",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates to start the rays.",
        "default": null
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates to start the rays.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Rect": {
    "name": "Rect",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph"
    ],
    "desc": "Render rectangles.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Rect.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"dilate\": false, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"height\": null, \"id\": \"5351\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"width\": null, \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the rectangles.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the rectangles.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the rectangles.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the rectangles.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the rectangles.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the rectangles.",
        "default": 1.0
      },
      {
        "name": "width",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The overall widths of the rectangles.",
        "default": null
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the centers of the rectangles.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "height",
        "type": "DistanceSpec(units_default='data')",
        "desc": "The overall heights of the rectangles.",
        "default": null
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the rectangles, as measured from the horizontal.",
        "default": 0.0
      },
      {
        "name": "height_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the rectangles.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the rectangles.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "width_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the rectangles.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "dilate",
        "type": "Bool",
        "desc": "Whether to always round fractional pixel locations in such a way\n    as to make the rectangles bigger.\n\n    This setting may be useful if pixel rounding errors are causing\n    rectangles to have a gap between them, when they should appear\n    flush.",
        "default": false
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the centers of the rectangles.",
        "default": null
      }
    ]
  },
  "RedoTool": {
    "name": "RedoTool",
    "bases": [
      "bokeh.models.tools.Action"
    ],
    "desc": "*toolbar icon*: |redo_icon|\n\n    Redo tool reverses the last action performed by undo tool.\n\n    .. |redo_icon| image:: /_images/icons/Redo.png\n        :height: 24px",
    "proto": "{\"id\": \"5375\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Renderer": {
    "name": "Renderer",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "An abstract base class for renderer types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"5381\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"image\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "image"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ResetTool": {
    "name": "ResetTool",
    "bases": [
      "bokeh.models.tools.Action"
    ],
    "desc": "*toolbar icon*: |reset_icon|\n\n    The reset tool is an action. When activated in the toolbar, the tool resets\n    the data bounds of the plot to their values when the plot was initially\n    created.\n\n    .. |reset_icon| image:: /_images/icons/Reset.png\n        :height: 24px",
    "proto": "{\"id\": \"5389\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Row": {
    "name": "Row",
    "bases": [
      "bokeh.models.layouts.Box"
    ],
    "desc": "Lay out child components in a single horizontal row.\n\n    Children can be specified as positional arguments, as a single argument\n    that is a sequence, or using the ``children`` keyword argument.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"children\": [], \"cols\": \"auto\", \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"5395\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"sizing_mode\": null, \"spacing\": 0, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "children",
        "type": "List(Instance(LayoutDOM))",
        "desc": "The list of children, which can be other components including plots, rows, columns, and widgets.",
        "default": []
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "cols",
        "type": "Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Dict(Either(Int, String), Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Struct(policy=Enum('auto', 'min'), align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fixed'), width=Int, align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fit', 'max'), flex=Float, align=Either(Auto, Enum('start', 'center', 'end'))))))",
        "desc": "Describes how the component should maintain its columns' widths.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion.",
        "default": "auto"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "spacing",
        "type": "Int",
        "desc": "The gap between children (in pixels).",
        "default": 0
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "RowAggregator": {
    "name": "RowAggregator",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Abstract base class for data cube's row formatters.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"field_\": \"\", \"id\": \"5420\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "field_",
        "type": "String",
        "desc": "Refers to the table column being aggregated",
        "default": ""
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "SaveTool": {
    "name": "SaveTool",
    "bases": [
      "bokeh.models.tools.Action"
    ],
    "desc": "*toolbar icon*: |save_icon|\n\n    The save tool is an action. When activated, the tool opens a download dialog\n    which allows to save an image reproduction of the plot in PNG format. If\n    automatic download is not support by a web browser, the tool falls back to\n    opening the generated image in a new tab or window. User then can manually\n    save it by right clicking on the image and choosing \"Save As\" (or similar)\n    menu item.\n\n    .. |save_icon| image:: /_images/icons/Save.png\n        :height: 24px",
    "proto": "{\"id\": \"5427\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Scale": {
    "name": "Scale",
    "bases": [
      "bokeh.models.transforms.Transform"
    ],
    "desc": "Base class for ``Scale`` models that represent an invertible\n    computation to be carried out on the client-side.\n\n    JavaScript implementations should implement the following methods:\n\n    .. code-block\n\n        compute(x: number): number {\n            # compute and return the transform of a single value\n        }\n\n        v_compute(xs: Arrayable<number>): Arrayable<number> {\n            # compute and return the transform of an array of values\n        }\n\n        invert(sx: number): number {\n            # compute and return the inverse transform of a single value\n        }\n\n        v_invert(sxs: Arrayable<number>): Arrayable<number> {\n            # compute and return the inverse transform of an array of values\n        }\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"5433\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Scatter": {
    "name": "Scatter",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render arbitrary markers according a specification.\n\n    The Scatter can draw any built-in marker type. It can be configured\n    to draw the same marker for all values by specifying the name of a\n    marker, e.g.\n\n    .. code-block:: python\n\n        glyph = Scatter(x=\"x\", y=\"y\", size=\"sizes\", marker=\"square\")\n        plot.add_glyph(source, glyph)\n\n    will render only Square markers for all points. Alternatively, the\n    Scatter marker can be configured to use marker types specified in a\n    data source column:\n\n    .. code-block:: python\n\n        # source.data['markers'] = [\"circle\", \"square\", \"circle\", ... ]\n\n        glyph = Scatter(x=\"x\", y=\"y\", size=\"sizes\", marker=\"markers\")\n        plot.add_glyph(source, glyph)\n\n    Note that circles drawn with `Scatter` conform to the standard Marker\n    interface, and can only vary by size (in screen units) and *not* by radius\n    (in data units). If you need to control circles by radius in data units,\n    you should use the Circle glyph directly.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Scatter.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"5439\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"marker\": {\"value\": \"circle\"}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "marker",
        "type": "MarkerSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), MarkerType('asterisk', 'circle', 'circle_cross', 'circle_dot', 'circle_x', 'circle_y', 'cross', 'dash', 'diamond', 'diamond_cross', 'diamond_dot', 'dot', 'hex', 'hex_dot', 'inverted_triangle', 'plus', 'square', 'square_cross', 'square_dot', 'square_pin', 'square_x', 'triangle', 'triangle_dot', 'triangle_pin', 'x', 'y'))), MarkerType('asterisk', 'circle', 'circle_cross', 'circle_dot', 'circle_x', 'circle_y', 'cross', 'dash', 'diamond', 'diamond_cross', 'diamond_dot', 'dot', 'hex', 'hex_dot', 'inverted_triangle', 'plus', 'square', 'square_cross', 'square_dot', 'square_pin', 'square_x', 'triangle', 'triangle_dot', 'triangle_pin', 'x', 'y'))",
        "desc": "Which marker to render. This can be the name of any built in marker,\n    e.g. \"circle\", or a reference to a data column containing such names.",
        "default": "circle"
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "ScientificFormatter": {
    "name": "ScientificFormatter",
    "bases": [
      "bokeh.models.widgets.tables.StringFormatter"
    ],
    "desc": "Display numeric values from continuous ranges as \"basic numbers\",\n    using scientific notation when appropriate by default.",
    "proto": "{\"font_style\": \"normal\", \"id\": \"5460\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"power_limit_high\": 5, \"power_limit_low\": -3, \"precision\": 10, \"subscribed_events\": [], \"tags\": [], \"text_align\": \"left\", \"text_color\": null}",
    "props": [
      {
        "name": "precision",
        "type": "Int",
        "desc": "How many digits of precision to display.",
        "default": 10
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "An optional text font style, e.g. bold, italic.",
        "default": "normal"
      },
      {
        "name": "text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "An optional text align, i.e. left, center or right.",
        "default": "left"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "power_limit_low",
        "type": "Int",
        "desc": "Limit the use of scientific notation to when::\n        log(x) <= power_limit_low",
        "default": -3
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "text_color",
        "type": "Color",
        "desc": "An optional text color. See :class:`bokeh.core.properties.Color` for\n    details.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "power_limit_high",
        "type": "Int",
        "desc": "Limit the use of scientific notation to when::\n        log(x) >= power_limit_high",
        "default": 5
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Scroll": {
    "name": "Scroll",
    "bases": [
      "bokeh.models.tools.Gesture"
    ],
    "desc": "A base class for tools that respond to scroll events.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"5472\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Segment": {
    "name": "Segment",
    "bases": [
      "bokeh.models.glyph.LineGlyph"
    ],
    "desc": "Render segments.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Segment.py\n        :source-position: below",
    "proto": "{\"id\": \"5478\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x0\": null, \"x1\": null, \"y0\": null, \"y1\": null}",
    "props": [
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the segments.",
        "default": "butt"
      },
      {
        "name": "x1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the ending points.",
        "default": null
      },
      {
        "name": "y0",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the starting points.",
        "default": null
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the segments.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the segments.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the segments.",
        "default": "black"
      },
      {
        "name": "x0",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the starting points.",
        "default": null
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the segments.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "y1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the ending points.",
        "default": null
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the segments.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the segments.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Select": {
    "name": "Select",
    "bases": [
      "bokeh.models.widgets.inputs.InputWidget"
    ],
    "desc": "Single-select widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"5495\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"options\": [], \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"value\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "value",
        "type": "String",
        "desc": "Initial or selected value.",
        "default": ""
      },
      {
        "name": "options",
        "type": "Either(List(Either(String, Tuple(Either(Int, String), String))), Dict(String, List(Either(String, Tuple(Either(Int, String), String)))))",
        "desc": "Available selection options. Options may be provided either as a list of\n    possible string values, or as a list of tuples, each of the form\n    ``(value, label)``. In the latter case, the visible widget text for each\n    value will be corresponding given label. Option groupings can be provided\n    by supplying a dictionary object whose values are in the aforementioned\n    list format",
        "default": []
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "SelectEditor": {
    "name": "SelectEditor",
    "bases": [
      "bokeh.models.widgets.tables.CellEditor"
    ],
    "desc": "Select cell editor.",
    "proto": "{\"id\": \"5522\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"options\": [], \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "options",
        "type": "List(String)",
        "desc": "The list of options to select from.",
        "default": []
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "SelectTool": {
    "name": "SelectTool",
    "bases": [
      "bokeh.models.tools.Gesture"
    ],
    "desc": "A base class for tools that perfrom \"selections\", e.g. ``BoxSelectTool``.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"5529\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mode\": \"replace\", \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('replace', 'append', 'intersect', 'subtract')",
        "desc": "Defines what should happen when a new selection is made. The default\n    is to replace the existing selection. Other options are to append to\n    the selection, intersect with it or subtract from it.",
        "default": "replace"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Selection": {
    "name": "Selection",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A Selection represents a portion of the data in a ``DataSource``, which\n    can be visually manipulated in a plot.\n\n    Selections are typically created by selecting points in a plot with\n    a ``SelectTool``, but can also be programmatically specified.\n\n    For most glyphs, the ``indices`` property is the relevant value to use.",
    "proto": "{\"id\": \"5536\", \"indices\": [], \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_indices\": [], \"multiline_indices\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "multiline_indices",
        "type": "Dict(String, Seq(Int))",
        "desc": "The detailed point indices included in a selection on a ``MultiLine``.\n\n    This value records which points, on which lines, are part of a seletion on\n    a ``MulitLine``. The keys are the top level indices (i.e., which line)\n    which map to lists of indices (i.e. which points on that line).\n\n    If you only need to know which lines are selected, without knowing what\n    individual points on those lines are selected, then you can look at the\n    keys of this dictionary (converted to ints).",
        "default": {}
      },
      {
        "name": "line_indices",
        "type": "Seq(Int)",
        "desc": "The point indices included in a selection on a ``Line`` glyph.\n\n    This value records the indices of the individual points on a ``Line`` that\n    were selected by a selection tool.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "indices",
        "type": "Seq(Int)",
        "desc": "The \"scatter\" level indices included in a selection. For example, for a\n    selection on a ``Circle`` glyph, this list records the indices of which\n    individual circles are selected.\n\n    For \"multi\" glyphs such as ``Patches``, ``MultiLine``, ``MultiPolygons``,\n    etc, this list records the indices of which entire sub-items are selected.\n    For example, which indidual polygons of a ``MultiPolygon`` are selected.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "SelectionPolicy": {
    "name": "SelectionPolicy",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": ".. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"5545\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ServerSentDataSource": {
    "name": "ServerSentDataSource",
    "bases": [
      "bokeh.models.sources.WebSource"
    ],
    "desc": "A data source that can populate columns by receiving server sent\n    events endpoints.",
    "proto": "{\"adapter\": null, \"data\": {}, \"data_url\": null, \"id\": \"5551\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_size\": null, \"mode\": \"replace\", \"name\": null, \"selected\": {\"id\": \"5552\"}, \"selection_policy\": {\"id\": \"5553\"}, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('replace', 'append')",
        "desc": "Whether to append new data to existing data (up to ``max_size``), or to\n    replace existing data entirely.",
        "default": "replace"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_size",
        "type": "Int",
        "desc": "Maximum size of the data columns. If a new fetch would result in columns\n    larger than ``max_size``, then earlier data is dropped to make room.",
        "default": null
      },
      {
        "name": "selected",
        "type": "Instance(Selection)",
        "desc": "An instance of a ``Selection`` that indicates selected indices on this ``DataSource``.\n    This is a read-only property. You may only change the attributes of this object\n    to change the selection (e.g., ``selected.indices``).",
        "default": "{\"id\": \"5559\"}"
      },
      {
        "name": "selection_policy",
        "type": "Instance(SelectionPolicy)",
        "desc": "An instance of a ``SelectionPolicy`` that determines how selections are set.",
        "default": "{\"id\": \"5561\"}"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "adapter",
        "type": "Instance(CustomJS)",
        "desc": "A JavaScript callback to adapt raw JSON responses to Bokeh ``ColumnDataSource``\n    format.\n\n    If provided, this callback is executes immediately after the JSON data is\n    received, but before appending or replacing data in the data source. The\n    ``CustomJS`` callback will receive the ``AjaxDataSource`` as ``cb_obj`` and\n    will receive the raw JSON response as ``cb_data.response``. The callback\n    code should return a ``data`` object suitable for a Bokeh ``ColumnDataSource``\n    (i.e.  a mapping of string column names to arrays of data).",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "data",
        "type": "ColumnData(String, Seq(Any))",
        "desc": "Mapping of column names to sequences of data. The columns can be, e.g,\n    Python lists or tuples, NumPy arrays, etc.\n\n    The .data attribute can also be set from Pandas DataFrames or GroupBy\n    objects. In these cases, the behaviour is identical to passing the objects\n    to the ``ColumnDataSource`` initializer.",
        "default": {}
      },
      {
        "name": "data_url",
        "type": "String",
        "desc": "A URL to to fetch data from.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "SingleIntervalTicker": {
    "name": "SingleIntervalTicker",
    "bases": [
      "bokeh.models.tickers.ContinuousTicker"
    ],
    "desc": "Generate evenly spaced ticks at a fixed interval regardless of\n    scale.",
    "proto": "{\"desired_num_ticks\": 6, \"id\": \"5568\", \"interval\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "interval",
        "type": "Float",
        "desc": "The interval between adjacent ticks.",
        "default": null
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "Slider": {
    "name": "Slider",
    "bases": [
      "bokeh.models.widgets.sliders.AbstractSlider"
    ],
    "desc": "Slider-based number selection widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"bar_color\": \"#e6e6e6\", \"css_classes\": [], \"default_size\": 300, \"direction\": \"ltr\", \"disabled\": false, \"end\": null, \"format\": \"0[.]00\", \"height\": null, \"height_policy\": \"auto\", \"id\": \"5577\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"show_value\": true, \"sizing_mode\": null, \"start\": null, \"step\": 1, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"tooltips\": true, \"value\": null, \"value_throttled\": null, \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "end",
        "type": "Float",
        "desc": "The maximum allowable value.",
        "default": null
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "tooltips",
        "type": "Bool",
        "desc": "",
        "default": true
      },
      {
        "name": "start",
        "type": "Float",
        "desc": "The minimum allowable value.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Slider's label.",
        "default": ""
      },
      {
        "name": "step",
        "type": "Float",
        "desc": "The step between consecutive values.",
        "default": 1
      },
      {
        "name": "format",
        "type": "Either(String, Instance(TickFormatter))",
        "desc": "",
        "default": "0[.]00"
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "direction",
        "type": "Enum('ltr', 'rtl')",
        "desc": "",
        "default": "ltr"
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "bar_color",
        "type": "Color",
        "desc": "",
        "default": "#e6e6e6"
      },
      {
        "name": "value",
        "type": "Float",
        "desc": "Initial or selected value.",
        "default": null
      },
      {
        "name": "show_value",
        "type": "Bool",
        "desc": "Whether or not show slider's value.",
        "default": true
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "value_throttled",
        "type": "Float",
        "desc": "Initial or selected value, throttled according to report only on mouseup.",
        "default": null
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Slope": {
    "name": "Slope",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render a sloped line as an annotation.\n\n    See :ref:`userguide_plotting_slope` for information on plotting slopes.",
    "proto": "{\"gradient\": null, \"id\": \"5612\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"line_alpha\": 1.0, \"line_cap\": \"butt\", \"line_color\": \"black\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"x_range_name\": \"default\", \"y_intercept\": null, \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the line.",
        "default": "butt"
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the line.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the line.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the line.",
        "default": "black"
      },
      {
        "name": "gradient",
        "type": "Float",
        "desc": "The gradient of the line, in data units",
        "default": null
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the line.",
        "default": 1
      },
      {
        "name": "y_intercept",
        "type": "Float",
        "desc": "The y intercept of the line, in data units",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the line.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the line.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Spacer": {
    "name": "Spacer",
    "bases": [
      "bokeh.models.layouts.LayoutDOM"
    ],
    "desc": "A container for space used to fill an empty spot in a row or column.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"5631\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "Span": {
    "name": "Span",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render a horizontal or vertical line span.\n\n    See :ref:`userguide_plotting_spans` for information on plotting spans.",
    "proto": "{\"dimension\": \"width\", \"id\": \"5653\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"line_alpha\": 1.0, \"line_cap\": \"butt\", \"line_color\": \"black\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"location\": null, \"location_units\": \"data\", \"name\": null, \"render_mode\": \"canvas\", \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the span.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the span.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the span.",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the span.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the span.",
        "default": 1.0
      },
      {
        "name": "location",
        "type": "Float",
        "desc": "The location of the span, along ``dimension``.\n\n    Datetime values are also accepted, but note that they are immediately\n    converted to milliseconds-since-epoch.",
        "default": null
      },
      {
        "name": "dimension",
        "type": "Enum('width', 'height')",
        "desc": "The direction of the span can be specified by setting this property\n    to \"height\" (``y`` direction) or \"width\" (``x`` direction).",
        "default": "width"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the span.",
        "default": "butt"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the span.",
        "default": "bevel"
      },
      {
        "name": "render_mode",
        "type": "Enum('canvas', 'css')",
        "desc": "Specifies whether the span is rendered as a canvas element or as a\n    CSS element overlaid on the canvas. The default mode is \"canvas\".\n\n    .. note:\n        This property is deprecated and will be removed in bokeh 3.0.\n\n    .. warning::\n        The line_dash and line_dash_offset attributes aren't supported if\n        the render_mode is set to \"css\"",
        "default": "canvas"
      },
      {
        "name": "location_units",
        "type": "Enum('screen', 'data')",
        "desc": "The unit type for the location attribute. Interpreted as \"data space\"\n    units by default.",
        "default": "data"
      }
    ]
  },
  "Spinner": {
    "name": "Spinner",
    "bases": [
      "bokeh.models.widgets.inputs.InputWidget"
    ],
    "desc": "Spinner widget for numerical inputs",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"high\": null, \"id\": \"5674\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"low\": null, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"step\": 1, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"value\": 0, \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "low",
        "type": "Float",
        "desc": "Optional lowest allowable value.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "step",
        "type": "Interval(Float, 1e-16, inf)",
        "desc": "The step added or subtracted to the current value",
        "default": 1
      },
      {
        "name": "high",
        "type": "Float",
        "desc": "Optional highest allowable value.",
        "default": null
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "value",
        "type": "Float",
        "desc": "The initial value of the spinner",
        "default": 0
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Square": {
    "name": "Square",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render square markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Square.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"5703\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "SquareCross": {
    "name": "SquareCross",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render square markers with a '+' cross through the center. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/SquareCross.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"5723\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "SquareDot": {
    "name": "SquareDot",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render square markers with center dots. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/SquareDot.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"5743\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "SquarePin": {
    "name": "SquarePin",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render pin-cushion square markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/SquarePin.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"5763\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "SquareX": {
    "name": "SquareX",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render square markers with an 'X' cross through the center. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/SquareX.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"5783\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "Stack": {
    "name": "Stack",
    "bases": [
      "bokeh.models.expressions.Expression"
    ],
    "desc": "An expression for generating arrays by summing different columns from\n    a ``ColumnDataSource``.\n\n    This expression is useful for implementing stacked bar charts at a low\n    level.",
    "proto": "{\"fields\": [], \"id\": \"5803\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "fields",
        "type": "Seq(String)",
        "desc": "A sequence of fields from a ``ColumnDataSource`` to sum (elementwise). For\n    example:\n\n    .. code-block:: python\n\n        Stack(fields=['sales', 'marketing'])\n\n    Will compute an array of values (in the browser) by adding the elements\n    of the ``'sales'`` and ``'marketing'`` columns of a data source.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "StaticLayoutProvider": {
    "name": "StaticLayoutProvider",
    "bases": [
      "bokeh.models.graphs.LayoutProvider"
    ],
    "desc": "",
    "proto": "{\"graph_layout\": {}, \"id\": \"5810\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "graph_layout",
        "type": "Dict(Either(String, Int), Seq(Any))",
        "desc": "The coordinates of the graph nodes in cartesian space. The dictionary\n    keys correspond to a node index and the values are a two element sequence\n    containing the x and y coordinates of the node.\n\n    .. code-block:: python\n\n        {\n            0 : [0.5, 0.5],\n            1 : [1.0, 0.86],\n            2 : [0.86, 1],\n        }",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Step": {
    "name": "Step",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph"
    ],
    "desc": "Render step lines.\n\n    Step levels can be draw before, after, or centered on each point, according\n    to the value of the ``mode`` property.\n\n    The x-coordinates are assumed to be (and must be) sorted in ascending order\n    for steps to be properly rendered.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Step.py\n        :source-position: below",
    "proto": "{\"id\": \"5817\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"mode\": \"before\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('before', 'after', 'center')",
        "desc": "Where the step \"level\" should be drawn in relation to the x and y\n    coordinates. The parameter can assume one of three values:\n\n    * ``before``: (default) Draw step levels before each x-coordinate (no step before the first point)\n    * ``after``:  Draw step levels after each x-coordinate (no step after the last point)\n    * ``center``: Draw step levels centered on each x-coordinate",
        "default": "before"
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the steps.",
        "default": "butt"
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the steps.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the steps.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the steps.",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the steps.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the steps.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the steps.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates for the steps.",
        "default": null
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates for the steps.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "StepInterpolator": {
    "name": "StepInterpolator",
    "bases": [
      "bokeh.models.transforms.Interpolator"
    ],
    "desc": "Compute a step-wise interpolation between the points provided through\n    the ``x``, ``y``, and ``data`` parameters.",
    "proto": "{\"clip\": true, \"data\": null, \"id\": \"5833\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mode\": \"after\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('before', 'after', 'center')",
        "desc": "Adjust the behavior of the returned value in relation to the control points.  The parameter can assume one of three values:\n\n    * ``after`` (default): Assume the y-value associated with the nearest x-value which is less than or equal to the point to transform.\n    * ``before``: Assume the y-value associated with the nearest x-value which is greater than the point to transform.\n    * ``center``: Assume the y-value associated with the nearest x-value to the point to transform.",
        "default": "after"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "data",
        "type": "Instance(ColumnarDataSource)",
        "desc": "Data which defines the source for the named columns if a string is passed to either the ``x`` or ``y`` parameters.",
        "default": null
      },
      {
        "name": "x",
        "type": "Either(String, Seq(Float))",
        "desc": "Independent coordinate denoting the location of a point.",
        "default": null
      },
      {
        "name": "y",
        "type": "Either(String, Seq(Float))",
        "desc": "Dependant coordinate denoting the value of a point at a location.",
        "default": null
      },
      {
        "name": "clip",
        "type": "Bool",
        "desc": "Determine if the interpolation should clip the result to include only values inside its predefined range.\n    If this is set to False, it will return the most value of the closest point.",
        "default": true
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "StringEditor": {
    "name": "StringEditor",
    "bases": [
      "bokeh.models.widgets.tables.CellEditor"
    ],
    "desc": "Basic string cell editor with auto-completion.",
    "proto": "{\"completions\": [], \"id\": \"5844\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "completions",
        "type": "List(String)",
        "desc": "An optional list of completion strings.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "StringFormatter": {
    "name": "StringFormatter",
    "bases": [
      "bokeh.models.widgets.tables.CellFormatter"
    ],
    "desc": "Basic string cell formatter.",
    "proto": "{\"font_style\": \"normal\", \"id\": \"5851\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"text_align\": \"left\", \"text_color\": null}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "An optional text font style, e.g. bold, italic.",
        "default": "normal"
      },
      {
        "name": "text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "An optional text align, i.e. left, center or right.",
        "default": "left"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "text_color",
        "type": "Color",
        "desc": "An optional text color. See :class:`bokeh.core.properties.Color` for\n    details.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "SumAggregator": {
    "name": "SumAggregator",
    "bases": [
      "bokeh.models.widgets.tables.RowAggregator"
    ],
    "desc": "Simple sum across multiple rows.",
    "proto": "{\"field_\": \"\", \"id\": \"5860\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "field_",
        "type": "String",
        "desc": "Refers to the table column being aggregated",
        "default": ""
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TMSTileSource": {
    "name": "TMSTileSource",
    "bases": [
      "bokeh.models.tiles.MercatorTileSource"
    ],
    "desc": "Contains tile config info and provides urls for tiles based on a\n    templated url e.g. ``http://your.tms.server.host/{Z}/{X}/{Y}.png``. The\n    defining feature of TMS is the tile-origin in located at the bottom-left.\n\n    ``TMSTileSource`` can also be helpful in implementing tile renderers for\n    custom tile sets, including non-spatial datasets.",
    "proto": "{\"attribution\": \"\", \"extra_url_vars\": {}, \"id\": \"5867\", \"initial_resolution\": 156543.03392804097, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_zoom\": 30, \"min_zoom\": 0, \"name\": null, \"snap_to_zoom\": false, \"subscribed_events\": [], \"tags\": [], \"tile_size\": 256, \"url\": \"\", \"wrap_around\": true, \"x_origin_offset\": 20037508.34, \"y_origin_offset\": 20037508.34}",
    "props": [
      {
        "name": "url",
        "type": "String",
        "desc": "Tile service url e.g., http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png",
        "default": ""
      },
      {
        "name": "wrap_around",
        "type": "Bool",
        "desc": "Enables continuous horizontal panning by wrapping the x-axis based on\n    bounds of map.\n\n    ..note::\n        Axis coordinates are not wrapped. To toggle axis label visibility,\n        use ``plot.axis.visible = False``.",
        "default": true
      },
      {
        "name": "tile_size",
        "type": "Int",
        "desc": "Tile size in pixels (e.g. 256)",
        "default": 256
      },
      {
        "name": "extra_url_vars",
        "type": "Dict(String, Any)",
        "desc": "A dictionary that maps url variable template keys to values.\n\n    These variables are useful for parts of tile urls which do not change from\n    tile to tile (e.g. server host name, or layer name).",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "initial_resolution",
        "type": "Float",
        "desc": "Resolution (plot_units / pixels) of minimum zoom level of tileset\n    projection. None to auto-compute.",
        "default": 156543.03392804097
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "y_origin_offset",
        "type": "Float",
        "desc": "A y-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "x_origin_offset",
        "type": "Float",
        "desc": "An x-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "max_zoom",
        "type": "Int",
        "desc": "A maximum zoom level for the tile layer. This is the most zoomed-in level.",
        "default": 30
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "min_zoom",
        "type": "Int",
        "desc": "A minimum zoom level for the tile layer. This is the most zoomed-out level.",
        "default": 0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "snap_to_zoom",
        "type": "Bool",
        "desc": "Forces initial extents to snap to the closest larger zoom level.",
        "default": false
      },
      {
        "name": "attribution",
        "type": "String",
        "desc": "Data provider attribution content. This can include HTML content.",
        "default": ""
      }
    ]
  },
  "TableColumn": {
    "name": "TableColumn",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Table column widget.",
    "proto": "{\"default_sort\": \"ascending\", \"editor\": {\"id\": \"5885\"}, \"field\": null, \"formatter\": {\"id\": \"5886\"}, \"id\": \"5884\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"sortable\": true, \"subscribed_events\": [], \"tags\": [], \"title\": null, \"width\": 300}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "default_sort",
        "type": "Enum('ascending', 'descending')",
        "desc": "The default sorting order. By default ``ascending`` order is used.",
        "default": "ascending"
      },
      {
        "name": "field",
        "type": "String",
        "desc": "The name of the field mapping to a column in the data source.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "editor",
        "type": "Instance(CellEditor)",
        "desc": "The cell editor for this column. By default, a simple string editor\n    is used.",
        "default": "{\"id\": \"5893\"}"
      },
      {
        "name": "sortable",
        "type": "Bool",
        "desc": "Whether this column is sortable or not. Note that data table has\n    to have sorting enabled to allow sorting in general.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "title",
        "type": "String",
        "desc": "The title of this column. If not set, column's data field is\n    used instead.",
        "default": null
      },
      {
        "name": "width",
        "type": "Int",
        "desc": "The width or maximum width (depending on data table's configuration)\n    in pixels of this column.",
        "default": 300
      },
      {
        "name": "formatter",
        "type": "Instance(CellFormatter)",
        "desc": "The cell formatter for this column. By default, a simple string\n    formatter is used.",
        "default": "{\"id\": \"5899\"}"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TableWidget": {
    "name": "TableWidget",
    "bases": [
      "bokeh.models.widgets.widget.Widget"
    ],
    "desc": "Abstract base class for data table (data grid) widgets.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"5901\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"source\": null, \"subscribed_events\": [], \"tags\": [], \"view\": {\"id\": \"5902\"}, \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "source",
        "type": "Instance(DataSource)",
        "desc": "The source of data for the widget.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "view",
        "type": "Instance(CDSView)",
        "desc": "A view into the data source to use when rendering table rows. A default view\n    of the entire data source is created if a view is not passed in during\n    initialization.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Tabs": {
    "name": "Tabs",
    "bases": [
      "bokeh.models.layouts.LayoutDOM"
    ],
    "desc": "A panel widget with navigation tabs.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../sphinx/source/docs/user_guide/examples/interaction_tab_panes.py\n        :source-position: below",
    "proto": "{\"active\": 0, \"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"5953\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"sizing_mode\": null, \"subscribed_events\": [], \"tabs\": [], \"tabs_location\": \"above\", \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "tabs",
        "type": "List(Instance(Panel))",
        "desc": "The list of child panel widgets.",
        "default": []
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "tabs_location",
        "type": "Enum('above', 'below', 'left', 'right')",
        "desc": "The location of the buttons that activate tabs.",
        "default": "above"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "active",
        "type": "Int",
        "desc": "The index of the active tab.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "Tap": {
    "name": "Tap",
    "bases": [
      "bokeh.models.tools.Gesture"
    ],
    "desc": "A base class for tools that respond to tap/click events.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"5978\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TapTool": {
    "name": "TapTool",
    "bases": [
      "bokeh.models.tools.Tap",
      "bokeh.models.tools.SelectTool"
    ],
    "desc": "*toolbar icon*: |tap_icon|\n\n    The tap selection tool allows the user to select at single points by\n    left-clicking a mouse, or tapping with a finger.\n\n    See :ref:`userguide_styling_selected_unselected_glyphs` for information\n    on styling selected and unselected glyphs.\n\n    .. |tap_icon| image:: /_images/icons/Tap.png\n        :height: 24px\n\n    .. note::\n        Selections can be comprised of multiple regions, even those\n        made by different selection tools. Hold down the <<shift>> key\n        while making a selection to append the new selection to any\n        previous selection that might exist.",
    "proto": "{\"behavior\": \"select\", \"callback\": null, \"id\": \"5984\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"mode\": \"replace\", \"name\": null, \"names\": [], \"renderers\": \"auto\", \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "behavior",
        "type": "Enum('select', 'inspect')",
        "desc": "This tool can be configured to either make selections or inspections\n    on associated data sources. The difference is that selection changes\n    propagate across bokeh and other components (e.g. selection glyph)\n    will be notified. Inspections don't act like this, so it's useful to\n    configure `callback` when setting `behavior='inspect'`.",
        "default": "select"
      },
      {
        "name": "mode",
        "type": "Enum('replace', 'append', 'intersect', 'subtract')",
        "desc": "Defines what should happen when a new selection is made. The default\n    is to replace the existing selection. Other options are to append to\n    the selection, intersect with it or subtract from it.",
        "default": "replace"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "names",
        "type": "List(String)",
        "desc": "A list of names to query for. If set, only renderers that\n    have a matching value for their ``name`` attribute will be used.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "callback",
        "type": "Instance(Callback)",
        "desc": "A callback to execute *whenever a glyph is \"hit\"* by a mouse click\n    or tap.\n\n    This is often useful with the  :class:`~bokeh.models.callbacks.OpenURL`\n    model to open URLs based on a user clicking or tapping a specific glyph.\n\n    However, it may also be a :class:`~bokeh.models.callbacks.CustomJS`\n    which can execute arbitrary JavaScript code in response to clicking or\n    tapping glyphs. The callback will be executed for each individual glyph\n    that is it hit by a click or tap, and will receive the ``TapTool`` model\n    as  ``cb_obj``. The optional ``cb_data`` will have the data source as\n    its ``.source`` attribute and the selection geometry as its\n    ``.geometries`` attribute.\n\n    The ``.geometries`` attribute has 5 members.\n    ``.type`` is the geometry type, which always a ``.point`` for a tap event.\n    ``.sx`` and ``.sy`` are the screen X and Y coordinates where the tap occurred.\n    ``.x`` and ``.y`` are the converted data coordinates for the item that has\n    been selected. The ``.x`` and ``.y`` values are based on the axis assigned\n    to that glyph.\n\n    .. note::\n        This callback does *not* execute on every tap, only when a glyph is\n        \"hit\". If you would like to execute a callback on every mouse tap,\n        please see :ref:`userguide_interaction_jscallbacks_customjs_interactions`.",
        "default": null
      },
      {
        "name": "renderers",
        "type": "Either(Auto, List(Instance(Renderer)))",
        "desc": "An explicit list of renderers to hit test against. If unset,\n    defaults to all renderers on a plot.",
        "default": "auto"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TeeHead": {
    "name": "TeeHead",
    "bases": [
      "bokeh.models.arrow_heads.ArrowHead"
    ],
    "desc": "Render a tee-style arrow head.",
    "proto": "{\"id\": \"5995\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"line_alpha\": 1.0, \"line_cap\": \"butt\", \"line_color\": \"black\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"name\": null, \"size\": 25, \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the arrow head outline.",
        "default": "butt"
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the arrow head outline.",
        "default": []
      },
      {
        "name": "size",
        "type": "Float",
        "desc": "The size, in pixels, of the arrow head.",
        "default": 25
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the arrow head outline.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the arrow head outline.",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the arrow head outline.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the arrow head outline.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the arrow head outline.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Text": {
    "name": "Text",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.TextGlyph"
    ],
    "desc": "Render text.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Text.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0}, \"id\": \"6011\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"text\": {\"field\": \"text\"}, \"text_align\": \"left\", \"text_alpha\": {\"value\": 1.0}, \"text_baseline\": \"bottom\", \"text_color\": {\"value\": \"#444444\"}, \"text_font\": \"helvetica\", \"text_font_size\": {\"value\": \"16px\"}, \"text_font_style\": \"normal\", \"text_line_height\": 1.2, \"x\": null, \"x_offset\": {\"value\": 0}, \"y\": null, \"y_offset\": {\"value\": 0}}",
    "props": [
      {
        "name": "text_line_height",
        "type": "Float",
        "desc": "The text line height values for the text.",
        "default": 1.2
      },
      {
        "name": "text_align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "The text align values for the text.",
        "default": "left"
      },
      {
        "name": "text_font_size",
        "type": "FontSizeSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), FontSize)), FontSize)",
        "desc": "The text font size values for the text.",
        "default": {
          "value": "16px"
        }
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "The text font style values for the text.",
        "default": "normal"
      },
      {
        "name": "text_baseline",
        "type": "Enum('top', 'middle', 'bottom', 'alphabetic', 'hanging', 'ideographic')",
        "desc": "The text baseline values for the text.",
        "default": "bottom"
      },
      {
        "name": "text_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The text alpha values for the text.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates to locate the text anchors.",
        "default": null
      },
      {
        "name": "y_offset",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "Offset values to apply to the y-coordinates.\n\n    This is useful, for instance, if it is desired to \"float\" text a fixed\n    distance in screen units from a given data position.",
        "default": 0
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the text, as measured from the horizontal.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "text",
        "type": "StringSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), List(String))), List(String))",
        "desc": "The text values to render.",
        "default": "text"
      },
      {
        "name": "text_font",
        "type": "String",
        "desc": "The text font values for the text.",
        "default": "helvetica"
      },
      {
        "name": "text_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The text color values for the text.",
        "default": "#444444"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "x_offset",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "Offset values to apply to the x-coordinates.\n\n    This is useful, for instance, if it is desired to \"float\" text a fixed\n    distance in screen units from a given data position.",
        "default": 0
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates to locate the text anchors.",
        "default": null
      }
    ]
  },
  "TextAnnotation": {
    "name": "TextAnnotation",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Base class for text annotation models such as labels and titles.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"6032\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"name\": null, \"render_mode\": \"canvas\", \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "render_mode",
        "type": "Enum('canvas', 'css')",
        "desc": "Specifies whether the text is rendered as a canvas element or as a\n    CSS element overlaid on the canvas. The default mode is \"canvas\".\n\n    .. note::\n        The CSS labels won't be present in the output using the \"save\" tool.\n\n    .. warning::\n        Not all visual styling properties are supported if the render_mode is\n        set to \"css\". The border_line_dash property isn't fully supported and\n        border_line_dash_offset isn't supported at all. Setting text_alpha will\n        modify the opacity of the entire background box and border in addition\n        to the text. Finally, clipping Label annotations inside of the plot\n        area isn't supported in \"css\" mode.",
        "default": "canvas"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TextAreaInput": {
    "name": "TextAreaInput",
    "bases": [
      "bokeh.models.widgets.inputs.TextInput"
    ],
    "desc": "Multi-line input widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"cols\": 20, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"6041\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_length\": 500, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"placeholder\": \"\", \"rows\": 2, \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"value\": \"\", \"value_input\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_length",
        "type": "Int",
        "desc": "Max count of characters in field",
        "default": 500
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "rows",
        "type": "Int",
        "desc": "Specifies the height of the text area (in lines). Default: 2",
        "default": 2
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "cols",
        "type": "Int",
        "desc": "Specifies the width of the text area (in average character width). Default: 20",
        "default": 20
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "placeholder",
        "type": "String",
        "desc": "Placeholder for empty input field.",
        "default": ""
      },
      {
        "name": "value",
        "type": "String",
        "desc": "Initial or entered text value.\n\n    Change events are triggered whenever <enter> is pressed.",
        "default": ""
      },
      {
        "name": "value_input",
        "type": "String",
        "desc": "Initial or current value.\n\n    Change events are triggered whenever any update happens, i.e. on every\n    keypress.",
        "default": ""
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "TextEditor": {
    "name": "TextEditor",
    "bases": [
      "bokeh.models.widgets.tables.CellEditor"
    ],
    "desc": "Multi-line string cell editor.",
    "proto": "{\"id\": \"6072\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TextGlyph": {
    "name": "TextGlyph",
    "bases": [
      "bokeh.models.glyph.Glyph"
    ],
    "desc": "Glyphs with text properties\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"6078\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TextInput": {
    "name": "TextInput",
    "bases": [
      "bokeh.models.widgets.inputs.InputWidget"
    ],
    "desc": "Single-line input widget.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"6084\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"placeholder\": \"\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"title\": \"\", \"value\": \"\", \"value_input\": \"\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "title",
        "type": "String",
        "desc": "Widget's label.",
        "default": ""
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "placeholder",
        "type": "String",
        "desc": "Placeholder for empty input field.",
        "default": ""
      },
      {
        "name": "value",
        "type": "String",
        "desc": "Initial or entered text value.\n\n    Change events are triggered whenever <enter> is pressed.",
        "default": ""
      },
      {
        "name": "value_input",
        "type": "String",
        "desc": "Initial or current value.\n\n    Change events are triggered whenever any update happens, i.e. on every\n    keypress.",
        "default": ""
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Texture": {
    "name": "Texture",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Base class for ``Texture`` models that represent fill patterns.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"6112\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"repetition\": \"repeat\", \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "repetition",
        "type": "Enum('repeat', 'repeat_x', 'repeat_y', 'no_repeat')",
        "desc": "",
        "default": "repeat"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TickFormatter": {
    "name": "TickFormatter",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A base class for all tick formatter types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"6119\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Ticker": {
    "name": "Ticker",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A base class for all ticker types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"6125\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TileRenderer": {
    "name": "TileRenderer",
    "bases": [
      "bokeh.models.renderers.DataRenderer"
    ],
    "desc": "",
    "proto": "{\"alpha\": 1.0, \"id\": \"6131\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"glyph\", \"name\": null, \"render_parents\": true, \"smoothing\": true, \"subscribed_events\": [], \"tags\": [], \"tile_source\": {\"id\": \"6132\"}, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "render_parents",
        "type": "Bool",
        "desc": "Flag enable/disable drawing of parent tiles while waiting for new tiles to arrive. Default value is True.",
        "default": true
      },
      {
        "name": "alpha",
        "type": "Float",
        "desc": "tile opacity 0.0 - 1.0",
        "default": 1.0
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering glyphs on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "glyph"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "smoothing",
        "type": "Bool",
        "desc": "Enable image smoothing for the rendered tiles.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tile_source",
        "type": "Instance(TileSource)",
        "desc": "Local data source to use when rendering glyphs on the plot.",
        "default": "{\"id\": \"6144\"}"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering glyphs on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "TileSource": {
    "name": "TileSource",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A base class for all tile source types.\n\n    In general, tile sources are used as a required input for ``TileRenderer``.",
    "proto": "{\"attribution\": \"\", \"extra_url_vars\": {}, \"id\": \"6147\", \"initial_resolution\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_zoom\": 30, \"min_zoom\": 0, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"tile_size\": 256, \"url\": \"\", \"x_origin_offset\": null, \"y_origin_offset\": null}",
    "props": [
      {
        "name": "url",
        "type": "String",
        "desc": "Tile service url e.g., http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png",
        "default": ""
      },
      {
        "name": "extra_url_vars",
        "type": "Dict(String, Any)",
        "desc": "A dictionary that maps url variable template keys to values.\n\n    These variables are useful for parts of tile urls which do not change from\n    tile to tile (e.g. server host name, or layer name).",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "initial_resolution",
        "type": "Float",
        "desc": "Resolution (plot_units / pixels) of minimum zoom level of tileset\n    projection. None to auto-compute.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "y_origin_offset",
        "type": "Float",
        "desc": "A y-offset in plot coordinates",
        "default": null
      },
      {
        "name": "x_origin_offset",
        "type": "Float",
        "desc": "An x-offset in plot coordinates",
        "default": null
      },
      {
        "name": "max_zoom",
        "type": "Int",
        "desc": "A maximum zoom level for the tile layer. This is the most zoomed-in level.",
        "default": 30
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "min_zoom",
        "type": "Int",
        "desc": "A minimum zoom level for the tile layer. This is the most zoomed-out level.",
        "default": 0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tile_size",
        "type": "Int",
        "desc": "Tile size in pixels (e.g. 256)",
        "default": 256
      },
      {
        "name": "attribution",
        "type": "String",
        "desc": "Data provider attribution content. This can include HTML content.",
        "default": ""
      }
    ]
  },
  "TimeEditor": {
    "name": "TimeEditor",
    "bases": [
      "bokeh.models.widgets.tables.CellEditor"
    ],
    "desc": "Spinner-based time cell editor.",
    "proto": "{\"id\": \"6162\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Title": {
    "name": "Title",
    "bases": [
      "bokeh.models.annotations.TextAnnotation"
    ],
    "desc": "Render a single title box as an annotation.\n\n    See :ref:`userguide_plotting_titles` for information on plotting titles.",
    "proto": "{\"align\": \"left\", \"background_fill_alpha\": 1.0, \"background_fill_color\": null, \"border_line_alpha\": 1.0, \"border_line_cap\": \"butt\", \"border_line_color\": null, \"border_line_dash\": [], \"border_line_dash_offset\": 0, \"border_line_join\": \"bevel\", \"border_line_width\": 1, \"id\": \"6168\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"name\": null, \"offset\": 0, \"render_mode\": \"canvas\", \"subscribed_events\": [], \"tags\": [], \"text\": null, \"text_alpha\": {\"value\": 1.0}, \"text_color\": {\"value\": \"#444444\"}, \"text_font\": \"helvetica\", \"text_font_size\": {\"value\": \"13px\"}, \"text_font_style\": \"bold\", \"text_line_height\": 1.0, \"vertical_align\": \"bottom\", \"visible\": true}",
    "props": [
      {
        "name": "border_line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the text bounding box.",
        "default": "butt"
      },
      {
        "name": "text_line_height",
        "type": "Float",
        "desc": "How much additional space should be allocated for the title. The value is provided\n    as a number, but should be treated as a percentage of font size. The default is\n    100%, which means no additional space will be used.",
        "default": 1.0
      },
      {
        "name": "text_font_size",
        "type": "FontSizeSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), FontSize)), FontSize)",
        "desc": "",
        "default": "13px"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "offset",
        "type": "Float",
        "desc": "Offset the text by a number of pixels (can be positive or negative). Shifts the text in\n    different directions based on the location of the title:\n\n        * above: shifts title right\n        * right: shifts title down\n        * below: shifts title right\n        * left: shifts title up",
        "default": 0
      },
      {
        "name": "border_line_width",
        "type": "Float",
        "desc": "The line width values for the text bounding box.",
        "default": 1
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "text_font_style",
        "type": "Enum('normal', 'italic', 'bold', 'bold italic')",
        "desc": "A style to use for rendering text.\n\n    Acceptable values are:\n\n    - ``'normal'`` normal text\n    - ``'italic'`` *italic text*\n    - ``'bold'`` **bold text**",
        "default": "bold"
      },
      {
        "name": "text_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "An alpha value to use to fill text with.\n\n    Acceptable values are floating point numbers between 0 (transparent)\n    and 1 (opaque).",
        "default": 1.0
      },
      {
        "name": "align",
        "type": "Enum('left', 'right', 'center')",
        "desc": "Alignment of the text in its enclosing space, *along* the direction of the text.",
        "default": "left"
      },
      {
        "name": "border_line_color",
        "type": "Color",
        "desc": "The line color values for the text bounding box.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "border_line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the text bounding box.",
        "default": []
      },
      {
        "name": "background_fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the text bounding box.",
        "default": 1.0
      },
      {
        "name": "vertical_align",
        "type": "Enum('top', 'middle', 'bottom')",
        "desc": "Alignment of the text in its enclosing space, *across* the direction of the text.",
        "default": "bottom"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "border_line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the text bounding box.",
        "default": 0
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "border_line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the text bounding box.",
        "default": "bevel"
      },
      {
        "name": "text",
        "type": "String",
        "desc": "The text value to render.",
        "default": null
      },
      {
        "name": "text_font",
        "type": "String",
        "desc": "Name of a font to use for rendering text, e.g., ``'times'``,\n    ``'helvetica'``.",
        "default": "helvetica"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "text_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "A color to use to fill text with.\n\n    Acceptable values are:\n\n    - any of the 147 named `CSS colors`_, e.g ``'green'``, ``'indigo'``\n    - an RGB(A) hex value, e.g., ``'#FF0000'``, ``'#44444444'``\n    - a 3-tuple of integers (r,g,b) between 0 and 255\n    - a 4-tuple of (r,g,b,a) where r,g,b are integers between 0..255 and a is between 0..1\n\n    .. _CSS colors: http://www.w3schools.com/cssref/css_colornames.asp",
        "default": "#444444"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "render_mode",
        "type": "Enum('canvas', 'css')",
        "desc": "Specifies whether the text is rendered as a canvas element or as a\n    CSS element overlaid on the canvas. The default mode is \"canvas\".\n\n    .. note::\n        The CSS labels won't be present in the output using the \"save\" tool.\n\n    .. warning::\n        Not all visual styling properties are supported if the render_mode is\n        set to \"css\". The border_line_dash property isn't fully supported and\n        border_line_dash_offset isn't supported at all. Setting text_alpha will\n        modify the opacity of the entire background box and border in addition\n        to the text. Finally, clipping Label annotations inside of the plot\n        area isn't supported in \"css\" mode.",
        "default": "canvas"
      },
      {
        "name": "background_fill_color",
        "type": "Color",
        "desc": "The fill color values for the text bounding box.",
        "default": null
      },
      {
        "name": "border_line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the text bounding box.",
        "default": 1.0
      }
    ]
  },
  "Toggle": {
    "name": "Toggle",
    "bases": [
      "bokeh.models.widgets.buttons.AbstractButton"
    ],
    "desc": "A two-state toggle button.",
    "proto": "{\"active\": false, \"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"button_type\": \"default\", \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"icon\": null, \"id\": \"6196\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"label\": \"Toggle\", \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "button_type",
        "type": "Enum('default', 'primary', 'success', 'warning', 'danger')",
        "desc": "A style for the button, signifying it's role.",
        "default": "default"
      },
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "label",
        "type": "String",
        "desc": "The text label for the button to display.",
        "default": "Toggle"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "icon",
        "type": "Instance(AbstractIcon)",
        "desc": "An optional image appearing to the left of button's text.",
        "default": null
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "active",
        "type": "Bool",
        "desc": "The initial state of a button. Also used to trigger ``on_click`` event\n    handler.",
        "default": false
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "Tool": {
    "name": "Tool",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A base class for all interactive tool types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"6224\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Toolbar": {
    "name": "Toolbar",
    "bases": [
      "bokeh.models.tools.ToolbarBase"
    ],
    "desc": "Collect tools to display for a single plot.",
    "proto": "{\"active_drag\": \"auto\", \"active_inspect\": \"auto\", \"active_multi\": null, \"active_scroll\": \"auto\", \"active_tap\": \"auto\", \"autohide\": false, \"id\": \"6230\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"logo\": \"normal\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"tools\": []}",
    "props": [
      {
        "name": "logo",
        "type": "Enum('normal', 'grey')",
        "desc": "What version of the Bokeh logo to display on the toolbar. If\n    set to None, no logo will be displayed.",
        "default": "normal"
      },
      {
        "name": "autohide",
        "type": "Bool",
        "desc": "Whether the toolbar will be hidden by default. Default: False.\n    If True, hides toolbar when cursor is not in canvas.",
        "default": false
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "active_multi",
        "type": "Instance(Gesture)",
        "desc": "Specify an active multi-gesture tool, for instance an edit tool or a range\n    tool.\n\n    Note that activating a multi-gesture tool will deactivate any other gesture\n    tools as appropriate. For example, if a pan tool is set as the active drag,\n    and this property is set to a ``BoxEditTool`` instance, the pan tool will\n    be deactivated (i.e. the multi-gesture tool will take precedence).",
        "default": null
      },
      {
        "name": "active_tap",
        "type": "Either(Auto, Instance(Tap))",
        "desc": "Specify a tap/click tool to be active when the plot is displayed.",
        "default": "auto"
      },
      {
        "name": "active_inspect",
        "type": "Either(Auto, Instance(Inspection), Seq(Instance(Inspection)))",
        "desc": "Specify an inspection tool or sequence of inspection tools to be active when\n    the plot is displayed.",
        "default": "auto"
      },
      {
        "name": "active_drag",
        "type": "Either(Auto, Instance(Drag))",
        "desc": "Specify a drag tool to be active when the plot is displayed.",
        "default": "auto"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "active_scroll",
        "type": "Either(Auto, Instance(Scroll))",
        "desc": "Specify a scroll/pinch tool to be active when the plot is displayed.",
        "default": "auto"
      },
      {
        "name": "tools",
        "type": "List(Instance(Tool))",
        "desc": "A list of tools to add to the plot.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ToolbarBase": {
    "name": "ToolbarBase",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "A base class for different toolbars.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"autohide\": false, \"id\": \"6244\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"logo\": \"normal\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"tools\": []}",
    "props": [
      {
        "name": "logo",
        "type": "Enum('normal', 'grey')",
        "desc": "What version of the Bokeh logo to display on the toolbar. If\n    set to None, no logo will be displayed.",
        "default": "normal"
      },
      {
        "name": "autohide",
        "type": "Bool",
        "desc": "Whether the toolbar will be hidden by default. Default: False.\n    If True, hides toolbar when cursor is not in canvas.",
        "default": false
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tools",
        "type": "List(Instance(Tool))",
        "desc": "A list of tools to add to the plot.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ToolbarBox": {
    "name": "ToolbarBox",
    "bases": [
      "bokeh.models.layouts.LayoutDOM"
    ],
    "desc": "A layoutable toolbar that can accept the tools of multiple plots, and\n    can merge the tools into a single button for convenience.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"6253\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"toolbar\": null, \"toolbar_location\": \"right\", \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "toolbar",
        "type": "Instance(ToolbarBase)",
        "desc": "A toolbar associated with a plot which holds all its tools.",
        "default": null
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "toolbar_location",
        "type": "Enum('above', 'below', 'left', 'right')",
        "desc": "",
        "default": "right"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "ToolbarPanel": {
    "name": "ToolbarPanel",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "",
    "proto": "{\"id\": \"6277\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"name\": null, \"subscribed_events\": [], \"tags\": [], \"toolbar\": null, \"visible\": true}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "toolbar",
        "type": "Instance(Toolbar)",
        "desc": "A toolbar to display.",
        "default": null
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Tooltip": {
    "name": "Tooltip",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render a tooltip.\n\n    .. note::\n        This model is currently managed by BokehJS and is not useful\n        directly from python.",
    "proto": "{\"attachment\": \"horizontal\", \"id\": \"6286\", \"inner_only\": true, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"overlay\", \"name\": null, \"show_arrow\": true, \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "inner_only",
        "type": "Bool",
        "desc": "Whether to display outside a central plot frame area.",
        "default": true
      },
      {
        "name": "attachment",
        "type": "Enum('horizontal', 'vertical', 'left', 'right', 'above', 'below')",
        "desc": "Whether the tooltip should be displayed to the left or right of the cursor\n    position or above or below it, or if it should be automatically placed\n    in the horizontal or vertical dimension.",
        "default": "horizontal"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "overlay"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "show_arrow",
        "type": "Bool",
        "desc": "Whether tooltip's arrow should be shown.",
        "default": true
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Transform": {
    "name": "Transform",
    "bases": [
      "bokeh.model.Model"
    ],
    "desc": "Base class for ``Transform`` models that represent a computation\n    to be carried out on the client-side.\n\n    JavaScript implementations should implement the following methods:\n\n    .. code-block\n\n        compute(x: number): number {\n            # compute and return the transform of a single value\n        }\n\n        v_compute(xs: Arrayable<number>): Arrayable<number> {\n            # compute and return the transform of an array of values\n        }\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"6297\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Triangle": {
    "name": "Triangle",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render triangle markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Triangle.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"6303\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "TriangleDot": {
    "name": "TriangleDot",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render triangle markers with center dots. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/TriangleDot.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"6323\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "TrianglePin": {
    "name": "TrianglePin",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render pin-cushion triangle markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/TrianglePin.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"6343\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "UndoTool": {
    "name": "UndoTool",
    "bases": [
      "bokeh.models.tools.Action"
    ],
    "desc": "*toolbar icon*: |undo_icon|\n\n    Undo tool allows to restore previous state of the plot.\n\n    .. |undo_icon| image:: /_images/icons/Undo.png\n        :height: 24px",
    "proto": "{\"id\": \"6363\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "UnionRenderers": {
    "name": "UnionRenderers",
    "bases": [
      "bokeh.models.selections.SelectionPolicy"
    ],
    "desc": "When a data source is shared between multiple renderers, selecting a point on\n    from any renderer will cause that row in the data source to be selected. The\n    selection is made from the union of hit test results from all renderers.",
    "proto": "{\"id\": \"6369\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "VArea": {
    "name": "VArea",
    "bases": [
      "bokeh.models.glyph.FillGlyph",
      "bokeh.models.glyph.HatchGlyph"
    ],
    "desc": "Render a vertically directed area between two equal length sequences\n    of y-coordinates with the same x-coordinates.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/VArea.py\n        :source-position: below",
    "proto": "{\"fill_alpha\": 1.0, \"fill_color\": \"gray\", \"hatch_alpha\": {\"value\": 1.0}, \"hatch_color\": {\"value\": \"black\"}, \"hatch_extra\": {}, \"hatch_pattern\": null, \"hatch_scale\": {\"value\": 12.0}, \"hatch_weight\": {\"value\": 1.0}, \"id\": \"6375\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y1\": null, \"y2\": null}",
    "props": [
      {
        "name": "y2",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates for the points of the other side of the area.",
        "default": null
      },
      {
        "name": "fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the vertical directed area",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "hatch_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The hatch color values for the horizontal bars.",
        "default": "black"
      },
      {
        "name": "hatch_pattern",
        "type": "HatchPatternSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), HatchPatternType)), HatchPatternType)",
        "desc": "The hatch pattern values for the horizontal bars.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "hatch_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch alpha values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "fill_color",
        "type": "Color",
        "desc": "The fill color values for the vertical directed area",
        "default": "gray"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "hatch_weight",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch weight values for the horizontal bars.",
        "default": 1.0
      },
      {
        "name": "y1",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates for the points of one side of the area.",
        "default": null
      },
      {
        "name": "hatch_extra",
        "type": "Dict(String, Instance(Texture))",
        "desc": "The hatch extra values for the horizontal bars.",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "hatch_scale",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch scale values for the horizontal bars.",
        "default": 12.0
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates for the points of the area.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "VBar": {
    "name": "VBar",
    "bases": [
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph",
      "bokeh.models.glyph.HatchGlyph"
    ],
    "desc": "Render vertical bars, given a center coordinate, width and (top, bottom) coordinates.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/VBar.py\n        :source-position: below",
    "proto": "{\"bottom\": {\"value\": 0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"hatch_alpha\": {\"value\": 1.0}, \"hatch_color\": {\"value\": \"black\"}, \"hatch_extra\": {}, \"hatch_pattern\": null, \"hatch_scale\": {\"value\": 12.0}, \"hatch_weight\": {\"value\": 1.0}, \"id\": \"6392\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"subscribed_events\": [], \"tags\": [], \"top\": null, \"width\": null, \"x\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the vertical bars.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the vertical bars.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the vertical bars.",
        "default": "black"
      },
      {
        "name": "bottom",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the bottom edges.",
        "default": 0
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the vertical bars.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the vertical bars.",
        "default": 1
      },
      {
        "name": "hatch_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch alpha values for the vertical bars.",
        "default": 1.0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "hatch_weight",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch weight values for the vertical bars.",
        "default": 1.0
      },
      {
        "name": "hatch_scale",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The hatch scale values for the vertical bars.",
        "default": 12.0
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the vertical bars.",
        "default": 1.0
      },
      {
        "name": "width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The widths of the vertical bars.",
        "default": null
      },
      {
        "name": "hatch_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The hatch color values for the vertical bars.",
        "default": "black"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the vertical bars.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the vertical bars.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "hatch_pattern",
        "type": "HatchPatternSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), HatchPatternType)), HatchPatternType)",
        "desc": "The hatch pattern values for the vertical bars.",
        "default": null
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "hatch_extra",
        "type": "Dict(String, Instance(Texture))",
        "desc": "The hatch extra values for the vertical bars.",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the vertical bars.",
        "default": "bevel"
      },
      {
        "name": "top",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the top edges.",
        "default": null
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the centers of the vertical bars.",
        "default": null
      }
    ]
  },
  "VeeHead": {
    "name": "VeeHead",
    "bases": [
      "bokeh.models.arrow_heads.ArrowHead"
    ],
    "desc": "Render a vee-style arrow head.",
    "proto": "{\"fill_alpha\": 1.0, \"fill_color\": \"black\", \"id\": \"6417\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"annotation\", \"line_alpha\": 1.0, \"line_cap\": \"butt\", \"line_color\": \"black\", \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": 1, \"name\": null, \"size\": 25, \"subscribed_events\": [], \"tags\": [], \"visible\": true}",
    "props": [
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the arrow head outline.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "Percent",
        "desc": "The fill alpha values for the arrow head interior.",
        "default": 1.0
      },
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the arrow head outline.",
        "default": []
      },
      {
        "name": "size",
        "type": "Float",
        "desc": "The size, in pixels, of the arrow head.",
        "default": 25
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the arrow head outline.",
        "default": 0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "line_color",
        "type": "Color",
        "desc": "The line color values for the arrow head outline.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "Color",
        "desc": "The fill color values for the arrow head interior.",
        "default": "black"
      },
      {
        "name": "line_width",
        "type": "Float",
        "desc": "The line width values for the arrow head outline.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "annotation"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "Percent",
        "desc": "The line alpha values for the arrow head outline.",
        "default": 1.0
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the arrow head outline.",
        "default": "bevel"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "WMTSTileSource": {
    "name": "WMTSTileSource",
    "bases": [
      "bokeh.models.tiles.MercatorTileSource"
    ],
    "desc": "Behaves much like ``TMSTileSource`` but has its tile-origin in the\n    top-left.\n\n    This is the most common used tile source for web mapping applications.\n    Such companies as Google, MapQuest, Stamen, Esri, and OpenStreetMap provide\n    service which use the WMTS specification e.g. ``http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png``.",
    "proto": "{\"attribution\": \"\", \"extra_url_vars\": {}, \"id\": \"6435\", \"initial_resolution\": 156543.03392804097, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_zoom\": 30, \"min_zoom\": 0, \"name\": null, \"snap_to_zoom\": false, \"subscribed_events\": [], \"tags\": [], \"tile_size\": 256, \"url\": \"\", \"wrap_around\": true, \"x_origin_offset\": 20037508.34, \"y_origin_offset\": 20037508.34}",
    "props": [
      {
        "name": "url",
        "type": "String",
        "desc": "Tile service url e.g., http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png",
        "default": ""
      },
      {
        "name": "wrap_around",
        "type": "Bool",
        "desc": "Enables continuous horizontal panning by wrapping the x-axis based on\n    bounds of map.\n\n    ..note::\n        Axis coordinates are not wrapped. To toggle axis label visibility,\n        use ``plot.axis.visible = False``.",
        "default": true
      },
      {
        "name": "tile_size",
        "type": "Int",
        "desc": "Tile size in pixels (e.g. 256)",
        "default": 256
      },
      {
        "name": "extra_url_vars",
        "type": "Dict(String, Any)",
        "desc": "A dictionary that maps url variable template keys to values.\n\n    These variables are useful for parts of tile urls which do not change from\n    tile to tile (e.g. server host name, or layer name).",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "initial_resolution",
        "type": "Float",
        "desc": "Resolution (plot_units / pixels) of minimum zoom level of tileset\n    projection. None to auto-compute.",
        "default": 156543.03392804097
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "y_origin_offset",
        "type": "Float",
        "desc": "A y-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "x_origin_offset",
        "type": "Float",
        "desc": "An x-offset in plot coordinates",
        "default": 20037508.34
      },
      {
        "name": "max_zoom",
        "type": "Int",
        "desc": "A maximum zoom level for the tile layer. This is the most zoomed-in level.",
        "default": 30
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "min_zoom",
        "type": "Int",
        "desc": "A minimum zoom level for the tile layer. This is the most zoomed-out level.",
        "default": 0
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "snap_to_zoom",
        "type": "Bool",
        "desc": "Forces initial extents to snap to the closest larger zoom level.",
        "default": false
      },
      {
        "name": "attribution",
        "type": "String",
        "desc": "Data provider attribution content. This can include HTML content.",
        "default": ""
      }
    ]
  },
  "WebSource": {
    "name": "WebSource",
    "bases": [
      "bokeh.models.sources.ColumnDataSource"
    ],
    "desc": "Base class for web column data sources that can update from data\n    URLs.\n\n    .. note::\n        This base class is typically not useful to instantiate on its own.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"adapter\": null, \"data\": {}, \"data_url\": null, \"id\": \"6452\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"max_size\": null, \"mode\": \"replace\", \"name\": null, \"selected\": {\"id\": \"6453\"}, \"selection_policy\": {\"id\": \"6454\"}, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "mode",
        "type": "Enum('replace', 'append')",
        "desc": "Whether to append new data to existing data (up to ``max_size``), or to\n    replace existing data entirely.",
        "default": "replace"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_size",
        "type": "Int",
        "desc": "Maximum size of the data columns. If a new fetch would result in columns\n    larger than ``max_size``, then earlier data is dropped to make room.",
        "default": null
      },
      {
        "name": "selected",
        "type": "Instance(Selection)",
        "desc": "An instance of a ``Selection`` that indicates selected indices on this ``DataSource``.\n    This is a read-only property. You may only change the attributes of this object\n    to change the selection (e.g., ``selected.indices``).",
        "default": "{\"id\": \"6460\"}"
      },
      {
        "name": "selection_policy",
        "type": "Instance(SelectionPolicy)",
        "desc": "An instance of a ``SelectionPolicy`` that determines how selections are set.",
        "default": "{\"id\": \"6462\"}"
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "adapter",
        "type": "Instance(CustomJS)",
        "desc": "A JavaScript callback to adapt raw JSON responses to Bokeh ``ColumnDataSource``\n    format.\n\n    If provided, this callback is executes immediately after the JSON data is\n    received, but before appending or replacing data in the data source. The\n    ``CustomJS`` callback will receive the ``AjaxDataSource`` as ``cb_obj`` and\n    will receive the raw JSON response as ``cb_data.response``. The callback\n    code should return a ``data`` object suitable for a Bokeh ``ColumnDataSource``\n    (i.e.  a mapping of string column names to arrays of data).",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "data",
        "type": "ColumnData(String, Seq(Any))",
        "desc": "Mapping of column names to sequences of data. The columns can be, e.g,\n    Python lists or tuples, NumPy arrays, etc.\n\n    The .data attribute can also be set from Pandas DataFrames or GroupBy\n    objects. In these cases, the behaviour is identical to passing the objects\n    to the ``ColumnDataSource`` initializer.",
        "default": {}
      },
      {
        "name": "data_url",
        "type": "String",
        "desc": "A URL to to fetch data from.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Wedge": {
    "name": "Wedge",
    "bases": [
      "bokeh.models.glyph.XYGlyph",
      "bokeh.models.glyph.LineGlyph",
      "bokeh.models.glyph.FillGlyph"
    ],
    "desc": "Render wedges.\n\n    \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Wedge.py\n        :source-position: below",
    "proto": "{\"direction\": \"anticlock\", \"end_angle\": null, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"6469\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"radius\": null, \"start_angle\": null, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the wedges.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the wedges.",
        "default": 0
      },
      {
        "name": "start_angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the wedges.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the wedges.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the wedges.",
        "default": 1
      },
      {
        "name": "end_angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to end the wedges, as measured from the horizontal.",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the wedges.",
        "default": 1.0
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-coordinates of the points of the wedges.",
        "default": null
      },
      {
        "name": "radius_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the wedges.",
        "default": "butt"
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the wedges.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "end_angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "direction",
        "type": "Enum('clock', 'anticlock')",
        "desc": "Which direction to stroke between the start and end angles.",
        "default": "anticlock"
      },
      {
        "name": "radius",
        "type": "DistanceSpec(units_default='data')",
        "desc": "Radii of the wedges.",
        "default": null
      },
      {
        "name": "start_angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to start the wedges, as measured from the horizontal.",
        "default": null
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the wedges.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-coordinates of the points of the wedges.",
        "default": null
      }
    ]
  },
  "WheelPanTool": {
    "name": "WheelPanTool",
    "bases": [
      "bokeh.models.tools.Scroll"
    ],
    "desc": "*toolbar icon*: |wheel_pan_icon|\n\n    The wheel pan tool allows the user to pan the plot along the configured\n    dimension using the scroll wheel.\n\n    .. |wheel_pan_icon| image:: /_images/icons/WheelPan.png\n        :height: 24px",
    "proto": "{\"dimension\": \"width\", \"id\": \"6493\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "dimension",
        "type": "Enum('width', 'height')",
        "desc": "Which dimension the wheel pan tool is constrained to act in. By default the\n    wheel pan tool will pan the plot along the x-axis.",
        "default": "width"
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "WheelZoomTool": {
    "name": "WheelZoomTool",
    "bases": [
      "bokeh.models.tools.Scroll"
    ],
    "desc": "*toolbar icon*: |wheel_zoom_icon|\n\n    The wheel zoom tool will zoom the plot in and out, centered on the\n    current mouse location.\n\n    The wheel zoom tool also activates the border regions of a Plot for\n    \"single axis\" zooming. For instance, zooming in the vertical border or\n    axis will effect a zoom in the vertical direction only, with the\n    horizontal dimension kept fixed.\n\n    .. |wheel_zoom_icon| image:: /_images/icons/WheelZoom.png\n        :height: 24px",
    "proto": "{\"dimensions\": \"both\", \"id\": \"6500\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"maintain_focus\": true, \"name\": null, \"speed\": 0.0016666666666666668, \"subscribed_events\": [], \"tags\": [], \"zoom_on_axis\": true}",
    "props": [
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "speed",
        "type": "Float",
        "desc": "Speed at which the wheel zooms. Default is 1/600. Optimal range is between\n    0.001 and 0.09. High values will be clipped. Speed may very between browsers.",
        "default": 0.0016666666666666668
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "maintain_focus",
        "type": "Bool",
        "desc": "Whether or not zooming tool maintains its focus position. Setting to False\n    results in a more \"gliding\" behavior, allowing one to zoom out more\n    smoothly, at the cost of losing the focus position.",
        "default": true
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "dimensions",
        "type": "Enum('width', 'height', 'both')",
        "desc": "Which dimensions the wheel zoom tool is constrained to act in. By default\n    the wheel zoom tool will zoom in any dimension, but can be configured to\n    only zoom horizontally across the width of the plot, or vertically across\n    the height of the plot.",
        "default": "both"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "zoom_on_axis",
        "type": "Bool",
        "desc": "Whether scrolling on an axis (outside the central plot area) should zoom\n    that dimension.",
        "default": true
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Whisker": {
    "name": "Whisker",
    "bases": [
      "bokeh.models.annotations.Annotation"
    ],
    "desc": "Render a whisker along a dimension.\n\n    See :ref:`userguide_plotting_whiskers` for information on plotting whiskers.",
    "proto": "{\"base\": null, \"dimension\": \"height\", \"id\": \"6510\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"level\": \"underlay\", \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"lower\": null, \"lower_head\": {\"id\": \"6513\"}, \"name\": null, \"source\": {\"id\": \"6511\"}, \"subscribed_events\": [], \"tags\": [], \"upper\": null, \"upper_head\": {\"id\": \"6512\"}, \"visible\": true, \"x_range_name\": \"default\", \"y_range_name\": \"default\"}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the whisker body.",
        "default": []
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the whisker body.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the whisker body.",
        "default": "black"
      },
      {
        "name": "source",
        "type": "Instance(DataSource)",
        "desc": "Local data source to use when rendering annotations on the plot.",
        "default": "{\"data\": {}, \"id\": \"6518\"}"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the whisker body.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "x_range_name",
        "type": "String",
        "desc": "A particular (named) x-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default x-range.",
        "default": "default"
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Is the renderer visible.",
        "default": true
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the whisker body.",
        "default": 1.0
      },
      {
        "name": "dimension",
        "type": "Enum('width', 'height')",
        "desc": "The direction of the whisker can be specified by setting this property\n    to \"height\" (``y`` direction) or \"width\" (``x`` direction).",
        "default": "height"
      },
      {
        "name": "y_range_name",
        "type": "String",
        "desc": "A particular (named) y-range to use for computing screen locations when\n    rendering annotations on the plot. If unset, use the default y-range.",
        "default": "default"
      },
      {
        "name": "base",
        "type": "PropertyUnitsSpec(units_default='data')",
        "desc": "The orthogonal coordinates of the upper and lower values.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the whisker body.",
        "default": "butt"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "upper",
        "type": "PropertyUnitsSpec(units_default='data')",
        "desc": "The coordinates of the upper end of the whiskers.",
        "default": null
      },
      {
        "name": "upper_head",
        "type": "Instance(ArrowHead)",
        "desc": "Instance of ``ArrowHead``.",
        "default": "{\"id\": \"6533\", \"level\": \"underlay\", \"size\": 10}"
      },
      {
        "name": "upper_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "base_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      },
      {
        "name": "lower",
        "type": "PropertyUnitsSpec(units_default='data')",
        "desc": "The coordinates of the lower end of the whiskers.",
        "default": null
      },
      {
        "name": "lower_head",
        "type": "Instance(ArrowHead)",
        "desc": "Instance of ``ArrowHead``.",
        "default": "{\"id\": \"6538\", \"level\": \"underlay\", \"size\": 10}"
      },
      {
        "name": "level",
        "type": "Enum('image', 'underlay', 'glyph', 'guide', 'annotation', 'overlay')",
        "desc": "Specifies the level in which to paint this renderer.",
        "default": "underlay"
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the whisker body.",
        "default": "bevel"
      },
      {
        "name": "lower_units",
        "type": "Enum('screen', 'data')",
        "desc": "",
        "default": "data"
      }
    ]
  },
  "Widget": {
    "name": "Widget",
    "bases": [
      "bokeh.models.layouts.LayoutDOM"
    ],
    "desc": "A base class for all interactive widget types.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"css_classes\": [], \"default_size\": 300, \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"6543\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [5, 5, 5, 5], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"orientation\": \"horizontal\", \"sizing_mode\": null, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "orientation",
        "type": "Enum('horizontal', 'vertical')",
        "desc": "Orient the widget either horizontally (default) or vertically.\n\n    Note that not all widgets support vertical orientation.",
        "default": "horizontal"
      },
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "default_size",
        "type": "Int",
        "desc": "The default size (width or height) in the dominating dimension.\n\n    The dominating dimension is determined by widget orientation.",
        "default": 300
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          5,
          5,
          5,
          5
        ]
      }
    ]
  },
  "WidgetBox": {
    "name": "WidgetBox",
    "bases": [
      "bokeh.models.layouts.Column"
    ],
    "desc": "Create a column of bokeh widgets with predefined styling.\n\n    WidgetBox is DEPRECATED and will beremoved in Bokeh 3.0, use 'Column' instead.",
    "proto": "{\"align\": \"start\", \"aspect_ratio\": null, \"background\": null, \"children\": [], \"css_classes\": [], \"disabled\": false, \"height\": null, \"height_policy\": \"auto\", \"id\": \"6567\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"margin\": [0, 0, 0, 0], \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"name\": null, \"rows\": \"auto\", \"sizing_mode\": null, \"spacing\": 0, \"subscribed_events\": [], \"tags\": [], \"visible\": true, \"width\": null, \"width_policy\": \"auto\"}",
    "props": [
      {
        "name": "sizing_mode",
        "type": "Enum('stretch_width', 'stretch_height', 'stretch_both', 'scale_width', 'scale_height', 'scale_both', 'fixed')",
        "desc": "How the component should size itself.\n\n    This is a high-level setting for maintaining width and height of the component. To\n    gain more fine grained control over sizing, use ``width_policy``, ``height_policy``\n    and ``aspect_ratio`` instead (those take precedence over ``sizing_mode``).\n\n    Possible scenarios:\n\n    ``\"fixed\"``\n        Component is not responsive. It will retain its original width and height\n        regardless of any subsequent browser window resize events.\n\n    ``\"stretch_width\"``\n        Component will responsively resize to stretch to the available width, without\n        maintaining any aspect ratio. The height of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_height\"``\n        Component will responsively resize to stretch to the available height, without\n        maintaining any aspect ratio. The width of the component depends on the type\n        of the component and may be fixed or fit to component's contents.\n\n    ``\"stretch_both\"``\n        Component is completely responsive, independently in width and height, and\n        will occupy all the available horizontal and vertical space, even if this\n        changes the aspect ratio of the component.\n\n    ``\"scale_width\"``\n        Component will responsively resize to stretch to the available width, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_height\"``\n        Component will responsively resize to stretch to the available height, while\n        maintaining the original or provided aspect ratio.\n\n    ``\"scale_both\"``\n        Component will responsively resize to both the available width and height, while\n        maintaining the original or provided aspect ratio.",
        "default": null
      },
      {
        "name": "max_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "aspect_ratio",
        "type": "Either(Enum('auto'), Float)",
        "desc": "Describes the proportional relationship between component's width and height.\n\n    This works if any of component's dimensions are flexible in size. If set to\n    a number, ``width / height = aspect_ratio`` relationship will be maintained.\n    Otherwise, if set to ``\"auto\"``, component's preferred width and height will\n    be used to determine the aspect (if not set, no aspect will be preserved).",
        "default": null
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "visible",
        "type": "Bool",
        "desc": "Whether the component will be visible and a part of a layout.",
        "default": true
      },
      {
        "name": "children",
        "type": "List(Instance(LayoutDOM))",
        "desc": "The list of children, which can be other components including plots, rows, columns, and widgets.",
        "default": []
      },
      {
        "name": "width",
        "type": "NonNegativeInt",
        "desc": "The width of the component (in pixels).\n\n    This can be either fixed or preferred width, depending on width sizing policy.",
        "default": null
      },
      {
        "name": "min_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "align",
        "type": "Either(Enum('start', 'center', 'end'), Tuple(Enum('start', 'center', 'end'), Enum('start', 'center', 'end')))",
        "desc": "The alignment point within the parent container.\n\n    This property is useful only if this component is a child element of a layout\n    (e.g. a grid). Self alignment can be overridden by the parent container (e.g.\n    grid track align).",
        "default": "start"
      },
      {
        "name": "rows",
        "type": "Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Dict(Either(Int, String), Either(Either(Enum('auto', 'min', 'fit', 'max'), Int), Struct(policy=Enum('auto', 'min'), align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fixed'), height=Int, align=Either(Auto, Enum('start', 'center', 'end'))), Struct(policy=Enum('fit', 'max'), flex=Float, align=Either(Auto, Enum('start', 'center', 'end'))))))",
        "desc": "Describes how the component should maintain its rows' heights.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion.",
        "default": "auto"
      },
      {
        "name": "background",
        "type": "Color",
        "desc": "Background color of the component.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "min_height",
        "type": "NonNegativeInt",
        "desc": "Minimal height of the component (in pixels) if height is adjustable.",
        "default": null
      },
      {
        "name": "height",
        "type": "NonNegativeInt",
        "desc": "The height of the component (in pixels).\n\n    This can be either fixed or preferred height, depending on height sizing policy.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "max_width",
        "type": "NonNegativeInt",
        "desc": "Minimal width of the component (in pixels) if width is adjustable.",
        "default": null
      },
      {
        "name": "disabled",
        "type": "Bool",
        "desc": "Whether the widget will be disabled when rendered.\n\n    If ``True``, the widget will be greyed-out and not responsive to UI events.",
        "default": false
      },
      {
        "name": "css_classes",
        "type": "List(String)",
        "desc": "A list of CSS class names to add to this DOM element. Note: the class names are\n    simply added as-is, no other guarantees are provided.\n\n    It is also permissible to assign from tuples, however these are adapted -- the\n    property will always contain a list.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "height_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its height.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``height`` pixels. Component will overflow if it can't fit in the\n        available vertical space.\n\n    ``\"fit\"``\n        Use component's preferred height (if set) and allow to fit into the available\n        vertical space within the minimum and maximum height bounds (if set). Component's\n        height neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little vertical space as possible, not less than the minimum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much vertical space as possible, not more than the maximum height (if set).\n        The starting point is the preferred height (if set). The height of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "spacing",
        "type": "Int",
        "desc": "The gap between children (in pixels).",
        "default": 0
      },
      {
        "name": "width_policy",
        "type": "Either(Auto, Enum('fixed', 'fit', 'min', 'max'))",
        "desc": "Describes how the component should maintain its width.\n\n    ``\"auto\"``\n        Use component's preferred sizing policy.\n\n    ``\"fixed\"``\n        Use exactly ``width`` pixels. Component will overflow if it can't fit in the\n        available horizontal space.\n\n    ``\"fit\"``\n        Use component's preferred width (if set) and allow it to fit into the available\n        horizontal space within the minimum and maximum width bounds (if set). Component's\n        width neither will be aggressively minimized nor maximized.\n\n    ``\"min\"``\n        Use as little horizontal space as possible, not less than the minimum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    ``\"max\"``\n        Use as much horizontal space as possible, not more than the maximum width (if set).\n        The starting point is the preferred width (if set). The width of the component may\n        shrink or grow depending on the parent layout, aspect management and other factors.\n\n    .. note::\n        This is an experimental feature and may change in future. Use it at your\n        own discretion. Prefer using ``sizing_mode`` if this level of control isn't\n        strictly necessary.",
        "default": "auto"
      },
      {
        "name": "margin",
        "type": "Tuple(Int, Int, Int, Int)",
        "desc": "Allows to create additional space around the component.\n    The values in the tuple are ordered as follows - Margin-Top, Margin-Right, Margin-Bottom and Margin-Left,\n    similar to CSS standards.\n    Negative margin values may be used to shrink the space from any direction.",
        "default": [
          0,
          0,
          0,
          0
        ]
      }
    ]
  },
  "X": {
    "name": "X",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render 'X' markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/X.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"6592\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "XYGlyph": {
    "name": "XYGlyph",
    "bases": [
      "bokeh.models.glyph.Glyph"
    ],
    "desc": "Base class of glyphs with `x` and `y` coordinate attributes.\n\n    \n    .. note::\n        This is an abstract base class used to help organize the hierarchy of Bokeh\n        model types. **It is not useful to instantiate on its own.**",
    "proto": "{\"id\": \"6612\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "Y": {
    "name": "Y",
    "bases": [
      "bokeh.models.markers.Marker"
    ],
    "desc": "Render 'Y' markers. \n\n    Example\n    -------\n\n    .. bokeh-plot:: ../../examples/reference/models/Y.py\n        :source-position: below",
    "proto": "{\"angle\": {\"units\": \"rad\", \"value\": 0.0}, \"fill_alpha\": {\"value\": 1.0}, \"fill_color\": {\"value\": \"gray\"}, \"id\": \"6618\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"line_alpha\": {\"value\": 1.0}, \"line_cap\": \"butt\", \"line_color\": {\"value\": \"black\"}, \"line_dash\": [], \"line_dash_offset\": 0, \"line_join\": \"bevel\", \"line_width\": {\"value\": 1}, \"name\": null, \"size\": {\"units\": \"screen\", \"value\": 4}, \"subscribed_events\": [], \"tags\": [], \"x\": null, \"y\": null}",
    "props": [
      {
        "name": "line_dash",
        "type": "DashPattern",
        "desc": "The line dash values for the markers.",
        "default": []
      },
      {
        "name": "size",
        "type": "ScreenDistanceSpec(units_default='screen')",
        "desc": "The size (diameter) values for the markers in screen space units.",
        "default": 4
      },
      {
        "name": "line_dash_offset",
        "type": "Int",
        "desc": "The line dash offset values for the markers.",
        "default": 0
      },
      {
        "name": "line_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The line color values for the markers.",
        "default": "black"
      },
      {
        "name": "fill_color",
        "type": "ColorSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Color)), Color)",
        "desc": "The fill color values for the markers.",
        "default": "gray"
      },
      {
        "name": "line_width",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line width values for the markers.",
        "default": 1
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "line_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The line alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "angle_units",
        "type": "Enum('deg', 'rad')",
        "desc": "",
        "default": "rad"
      },
      {
        "name": "y",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The y-axis coordinates for the center of the markers.",
        "default": null
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "line_cap",
        "type": "Enum('butt', 'round', 'square')",
        "desc": "The line cap values for the markers.",
        "default": "butt"
      },
      {
        "name": "angle",
        "type": "AngleSpec(units_default='rad')",
        "desc": "The angles to rotate the markers.",
        "default": 0.0
      },
      {
        "name": "fill_alpha",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The fill alpha values for the markers.",
        "default": 1.0
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "line_join",
        "type": "Enum('miter', 'round', 'bevel')",
        "desc": "The line join values for the markers.",
        "default": "bevel"
      },
      {
        "name": "x",
        "type": "NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float)",
        "desc": "The x-axis coordinates for the center of the markers.",
        "default": null
      }
    ]
  },
  "YearsTicker": {
    "name": "YearsTicker",
    "bases": [
      "bokeh.models.tickers.SingleIntervalTicker"
    ],
    "desc": "Generate ticks spaced apart even numbers of years.",
    "proto": "{\"desired_num_ticks\": 6, \"id\": \"6638\", \"interval\": null, \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"num_minor_ticks\": 5, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "interval",
        "type": "Float",
        "desc": "The interval between adjacent ticks.",
        "default": null
      },
      {
        "name": "desired_num_ticks",
        "type": "Int",
        "desc": "A desired target number of major tick positions to generate across\n    the plot range.\n\n    .. note:\n        This value is a suggestion, and ticker subclasses may ignore\n        it entirely, or use it only as an ideal goal to approach as well\n        as can be, in the context of a specific ticking strategy.",
        "default": 6
      },
      {
        "name": "num_minor_ticks",
        "type": "Int",
        "desc": "The number of minor tick positions to generate between\n    adjacent major tick values.",
        "default": 5
      }
    ]
  },
  "ZoomInTool": {
    "name": "ZoomInTool",
    "bases": [
      "bokeh.models.tools.Action"
    ],
    "desc": "*toolbar icon*: |zoom_in_icon|\n\n    The zoom-in tool allows users to click a button to zoom in\n    by a fixed amount.\n\n    .. |zoom_in_icon| image:: /_images/icons/ZoomIn.png\n        :height: 24px",
    "proto": "{\"dimensions\": \"both\", \"factor\": 0.1, \"id\": \"6647\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "dimensions",
        "type": "Enum('width', 'height', 'both')",
        "desc": "Which dimensions the zoom-in tool is constrained to act in. By default the\n    zoom-in zoom tool will zoom in any dimension, but can be configured to only\n    zoom horizontally across the width of the plot, or vertically across the\n    height of the plot.",
        "default": "both"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "factor",
        "type": "Percent",
        "desc": "Percentage to zoom for each click of the zoom-in tool.",
        "default": 0.1
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  },
  "ZoomOutTool": {
    "name": "ZoomOutTool",
    "bases": [
      "bokeh.models.tools.Action"
    ],
    "desc": "*toolbar icon*: |zoom_out_icon|\n\n    The zoom-out tool allows users to click a button to zoom out\n    by a fixed amount.\n\n    .. |zoom_out_icon| image:: /_images/icons/ZoomOut.png\n        :height: 24px",
    "proto": "{\"dimensions\": \"both\", \"factor\": 0.1, \"id\": \"6655\", \"js_event_callbacks\": {}, \"js_property_callbacks\": {}, \"name\": null, \"subscribed_events\": [], \"tags\": []}",
    "props": [
      {
        "name": "js_event_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of event names to lists of ``CustomJS`` callbacks.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_event`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('tap event occurred')\")\n        plot.js_on_event('tap', callback)",
        "default": {}
      },
      {
        "name": "dimensions",
        "type": "Enum('width', 'height', 'both')",
        "desc": "Which dimensions the zoom-out tool is constrained to act in. By default the\n    zoom-out tool will zoom in any dimension, but can be configured to only\n    zoom horizontally across the width of the plot, or vertically across the\n    height of the plot.",
        "default": "both"
      },
      {
        "name": "subscribed_events",
        "type": "List(String)",
        "desc": "List of events that are subscribed to by Python callbacks. This is\n    the set of events that will be communicated from BokehJS back to\n    Python for this model.",
        "default": []
      },
      {
        "name": "js_property_callbacks",
        "type": "Dict(String, List(Instance(CustomJS)))",
        "desc": "A mapping of attribute names to lists of ``CustomJS`` callbacks, to be set up on\n    BokehJS side when the document is created.\n\n    Typically, rather then modifying this property directly, callbacks should be\n    added using the ``Model.js_on_change`` method:\n\n    .. code:: python\n\n        callback = CustomJS(code=\"console.log('stuff')\")\n        plot.x_range.js_on_change('start', callback)",
        "default": {}
      },
      {
        "name": "factor",
        "type": "Percent",
        "desc": "Percentage to zoom for each click of the zoom-in tool.",
        "default": 0.1
      },
      {
        "name": "tags",
        "type": "List(Any)",
        "desc": "An optional list of arbitrary, user-supplied values to attach to this\n    model.\n\n    This data can be useful when querying the document to retrieve specific\n    Bokeh models:\n\n    .. code:: python\n\n        >>> r = plot.circle([1,2,3], [4,5,6])\n        >>> r.tags = [\"foo\", 10]\n        >>> plot.select(tags=['foo', 10])\n        [GlyphRenderer(id='1de4c3df-a83d-480a-899b-fb263d3d5dd9', ...)]\n\n    Or simply a convenient way to attach any necessary metadata to a model\n    that can be accessed by ``CustomJS`` callbacks, etc.\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any tags\n        that are provided, nor are the tags used directly by Bokeh for any\n        reason.",
        "default": []
      },
      {
        "name": "name",
        "type": "String",
        "desc": "An arbitrary, user-supplied name for this model.\n\n    This name can be useful when querying the document to retrieve specific\n    Bokeh models.\n\n    .. code:: python\n\n        >>> plot.circle([1,2,3], [4,5,6], name=\"temp\")\n        >>> plot.select(name=\"temp\")\n        [GlyphRenderer(id='399d53f5-73e9-44d9-9527-544b761c7705', ...)]\n\n    .. note::\n        No uniqueness guarantees or other conditions are enforced on any names\n        that are provided, nor is the name used directly by Bokeh for any\n        reason.",
        "default": null
      }
    ]
  }
}
